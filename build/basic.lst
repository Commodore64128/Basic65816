
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass --m65816 -f -q -o basic.bin -L basic.lst ../source/start.asm
; Mon Jun 24 18:01:39 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: ../source/start.asm

.0000	18		clc				clc											; switch into 65816 16 bit mode.
.0001	fb		xce				xce
.0002	c2 30		rep #$30			rep 	#$30
.0004	a2 fe f3	ldx #$f3fe			ldx 	#DirectPage+CPUStack 				; 65816 Stack
.0007	9a		txs				txs
.0008	a9 00 f0	lda #$f000			lda 	#DirectPage 						; set Direct Page.
.000b	5b		tcd				tcd
.000c	a9 02 00	lda #$0002			lda 	#CodeSpace >> 16 					; put the page number in A ($2)
.000f	a2 00 40	ldx #$4000			ldx 	#CodeSpace & $FFFF 					; and the base address in X ($4000)
.0012	a0 00 c0	ldy #$c000			ldy 	#CodeEndSpace & $FFFF				; and the end address in Y ($C000)
.0015	5c 49 1f 01	jmp $011f49			jmp 	SwitchBasicInstance

;******  Processing file: ../source/basic.asm

.010000					StartOfBasicCode:

;******  Processing file: ../source/temp/block.inc

=$0010					Block_FastVariables = $0010
=$0080					Block_HashTable = $0080
=$000f					Block_HashMask = $000f
=$0008					Block_LowMemoryPtr = $0008
=$000a					Block_HighMemoryPtr = $000a
=$000c					Block_NullString = $000c
=$000e					Block_BootFlag = $000e
=$0200					Block_ProgramStart = $0200
=$0100					Block_TokenBuffer = $0100
=$0010					Block_HashTableEntrySize = $0010

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/temp/tokens.inc

.010000					CommandJumpTable:
>010000	ab 05					.word IllegalToken & $FFFF ; for the $0000 token.
>010002	fd 0a					.word Binary_And               & $FFFF ; token $2001 "&"
>010004	0d 0b					.word Binary_Or                & $FFFF ; token $2002 "|"
>010006	1d 0b					.word Binary_Xor               & $FFFF ; token $2003 "^"
>010008	61 0b					.word Binary_Less              & $FFFF ; token $2204 "<"
>01000a	c8 0b					.word Binary_Greater           & $FFFF ; token $2205 ">"
>01000c	2d 0b					.word Binary_Equals            & $FFFF ; token $2206 "="
>01000e	aa 0b					.word Binary_LessEqual         & $FFFF ; token $2207 "<="
>010010	8c 0b					.word Binary_GreaterEqual      & $FFFF ; token $2208 ">="
>010012	47 0b					.word Binary_NotEquals         & $FFFF ; token $2209 "<>"
>010014	47 0a					.word Binary_Add               & $FFFF ; token $240a "+"
>010016	c8 0a					.word Binary_Subtract          & $FFFF ; token $240b "-"
>010018	d8 0c					.word Binary_Multiply          & $FFFF ; token $260c "*"
>01001a	51 0c					.word Binary_Divide            & $FFFF ; token $260d "/"
>01001c	cc 0c					.word Binary_Modulus           & $FFFF ; token $260e "%"
>01001e	d9 0a					.word Binary_ShiftRight        & $FFFF ; token $260f ">>"
>010020	eb 0a					.word Binary_ShiftLeft         & $FFFF ; token $2610 "<<"
>010022	66 0d					.word Function_Random          & $FFFF ; token $3011 "rnd("
>010024	46 0d					.word Function_Sgn             & $FFFF ; token $3012 "sgn("
>010026	22 0d					.word Function_Abs             & $FFFF ; token $3013 "abs("
>010028	0c 0d					.word Function_Len             & $FFFF ; token $3014 "len("
>01002a	8e 0f					.word Function_VAL             & $FFFF ; token $3015 "val("
>01002c	ae 10					.word Function_Str             & $FFFF ; token $3016 "str$("
>01002e	a0 0d					.word Function_Chr             & $FFFF ; token $3017 "chr$("
>010030	d8 0d					.word Function_Asc             & $FFFF ; token $3018 "asc("
>010032	0c 0e					.word Function_SPC             & $FFFF ; token $3019 "spc("
>010034	42 0f					.word Function_Peek            & $FFFF ; token $301a "peek("
>010036	5c 0f					.word Function_Deek            & $FFFF ; token $301b "deek("
>010038	73 0f					.word Function_Leek            & $FFFF ; token $301c "leek("
>01003a	17 12					.word Function_LOWER           & $FFFF ; token $301d "lower$("
>01003c	d5 11					.word Function_UPPER           & $FFFF ; token $301e "upper$("
>01003e	56 0e					.word Function_LEFT            & $FFFF ; token $301f "left$("
>010040	ed 0e					.word Function_MID             & $FFFF ; token $3020 "mid$("
>010042	7f 0e					.word Function_RIGHT           & $FFFF ; token $3021 "right$("
>010044	6e 11					.word Function_INSTR           & $FFFF ; token $3022 "instr("
>010046	48 0e					.word Function_Inkey           & $FFFF ; token $3023 "inkey("
>010048	ab 05					.word IllegalToken             & $FFFF ; token $3224 ","
>01004a	ab 05					.word IllegalToken             & $FFFF ; token $3225 ";"
>01004c	ab 05					.word IllegalToken             & $FFFF ; token $3226 ":"
>01004e	ab 05					.word IllegalToken             & $FFFF ; token $3227 "("
>010050	ab 05					.word IllegalToken             & $FFFF ; token $3228 ")"
>010052	ab 05					.word IllegalToken             & $FFFF ; token $3229 "'"
>010054	ab 05					.word IllegalToken             & $FFFF ; token $382a "to"
>010056	ab 05					.word IllegalToken             & $FFFF ; token $382b "step"
>010058	7d 1d					.word Command_REM              & $FFFF ; token $3e2c "rem"
>01005a	59 12					.word Command_Let              & $FFFF ; token $3e2d "let"
>01005c	5e 1d					.word Command_ASSERT           & $FFFF ; token $3e2e "assert"
>01005e	8a 1b					.word Command_END              & $FFFF ; token $3e2f "end"
>010060	8d 1b					.word Command_RUN              & $FFFF ; token $3e30 "run"
>010062	1c 1c					.word Command_STOP             & $FFFF ; token $3e31 "stop"
>010064	18 1c					.word Command_CLEAR            & $FFFF ; token $3e32 "clear"
>010066	75 1c					.word Function_Dim             & $FFFF ; token $3e33 "dim"
>010068	79 1d					.word Command_CLS              & $FFFF ; token $3e34 "cls"
>01006a	28 17					.word Command_PRINT            & $FFFF ; token $3e35 "print"
>01006c	18 1a					.word Command_GOTO             & $FFFF ; token $3e36 "goto"
>01006e	77 1a					.word Command_GOSUB            & $FFFF ; token $3e37 "gosub"
>010070	93 1a					.word Command_RETURN           & $FFFF ; token $3e38 "return"
>010072	d5 19					.word Command_ONGOTO           & $FFFF ; token $3e39 "on"
>010074	db 17					.word Handler_ELSE             & $FFFF ; token $3e3a "else"
>010076	18 1d					.word Command_POKE             & $FFFF ; token $3e3b "poke"
>010078	30 1d					.word Command_DOKE             & $FFFF ; token $3e3c "doke"
>01007a	44 1d					.word Command_LOKE             & $FFFF ; token $3e3d "loke"
>01007c	f0 14					.word Command_List             & $FFFF ; token $3e3e "list"
>01007e	94 1d					.word Command_LINK             & $FFFF ; token $3e3f "link"
>010080	09 1c					.word Command_NEW              & $FFFF ; token $3e40 "new"
>010082	cf 12					.word Command_PROC             & $FFFF ; token $3e41 "proc"
>010084	1a 14					.word Command_LOCAL            & $FFFF ; token $3e42 "local"
>010086	d7 1d					.word Command_VDU              & $FFFF ; token $3e43 "vdu"
>010088	c5 1a					.word Command_REPEAT           & $FFFF ; token $3c44 "repeat"
>01008a	23 1b					.word Command_WHILE            & $FFFF ; token $3c45 "while"
>01008c	74 17					.word Command_IF               & $FFFF ; token $3c46 "if"
>01008e	b0 18					.word Command_FOR              & $FFFF ; token $3c47 "for"
>010090	ab 05					.word IllegalToken             & $FFFF ; token $3c48 "defproc"
>010092	5a 1b					.word Command_WEND             & $FFFF ; token $3a49 "wend"
>010094	dc 1a					.word Command_UNTIL            & $FFFF ; token $3a4a "until"
>010096	ab 05					.word IllegalToken             & $FFFF ; token $3a4b "then"
>010098	09 18					.word Handler_ENDIF            & $FFFF ; token $3a4c "endif"
>01009a	19 19					.word Command_NEXT             & $FFFF ; token $3a4d "next"
>01009c	e5 13					.word Command_ENDPROC          & $FFFF ; token $3a4e "endproc"
.01009e					TokenText:
>01009e	02 26					 .text $02,"&"        ; token $2001
>0100a0	02 7c					 .text $02,"|"        ; token $2002
>0100a2	02 5e					 .text $02,"^"        ; token $2003
>0100a4	12 3c					 .text $12,"<"        ; token $2204
>0100a6	12 3e					 .text $12,">"        ; token $2205
>0100a8	12 3d					 .text $12,"="        ; token $2206
>0100aa	13 3c 3d				 .text $13,"<="       ; token $2207
>0100ad	13 3e 3d				 .text $13,">="       ; token $2208
>0100b0	13 3c 3e				 .text $13,"<>"       ; token $2209
>0100b3	22 2b					 .text $22,"+"        ; token $240a
>0100b5	22 2d					 .text $22,"-"        ; token $240b
>0100b7	32 2a					 .text $32,"*"        ; token $260c
>0100b9	32 2f					 .text $32,"/"        ; token $260d
>0100bb	32 25					 .text $32,"%"        ; token $260e
>0100bd	33 3e 3e				 .text $33,">>"       ; token $260f
>0100c0	33 3c 3c				 .text $33,"<<"       ; token $2610
>0100c3	85 52 4e 44 28				 .text $85,"RND("     ; token $3011
>0100c8	85 53 47 4e 28				 .text $85,"SGN("     ; token $3012
>0100cd	85 41 42 53 28				 .text $85,"ABS("     ; token $3013
>0100d2	85 4c 45 4e 28				 .text $85,"LEN("     ; token $3014
>0100d7	85 56 41 4c 28				 .text $85,"VAL("     ; token $3015
>0100dc	86 53 54 52 24 28			 .text $86,"STR$("    ; token $3016
>0100e2	86 43 48 52 24 28			 .text $86,"CHR$("    ; token $3017
>0100e8	85 41 53 43 28				 .text $85,"ASC("     ; token $3018
>0100ed	85 53 50 43 28				 .text $85,"SPC("     ; token $3019
>0100f2	86 50 45 45 4b 28			 .text $86,"PEEK("    ; token $301a
>0100f8	86 44 45 45 4b 28			 .text $86,"DEEK("    ; token $301b
>0100fe	86 4c 45 45 4b 28			 .text $86,"LEEK("    ; token $301c
>010104	88 4c 4f 57 45 52 24 28			 .text $88,"LOWER$("  ; token $301d
>01010c	88 55 50 50 45 52 24 28			 .text $88,"UPPER$("  ; token $301e
>010114	87 4c 45 46 54 24 28			 .text $87,"LEFT$("   ; token $301f
>01011b	86 4d 49 44 24 28			 .text $86,"MID$("    ; token $3020
>010121	88 52 49 47 48 54 24 28			 .text $88,"RIGHT$("  ; token $3021
>010129	87 49 4e 53 54 52 28			 .text $87,"INSTR("   ; token $3022
>010130	87 49 4e 4b 45 59 28			 .text $87,"INKEY("   ; token $3023
>010137	92 2c					 .text $92,","        ; token $3224
>010139	92 3b					 .text $92,";"        ; token $3225
>01013b	92 3a					 .text $92,":"        ; token $3226
>01013d	92 28					 .text $92,"("        ; token $3227
>01013f	92 29					 .text $92,")"        ; token $3228
>010141	92 27					 .text $92,"'"        ; token $3229
>010143	c3 54 4f				 .text $c3,"TO"       ; token $382a
>010146	c5 53 54 45 50				 .text $c5,"STEP"     ; token $382b
>01014b	f4 52 45 4d				 .text $f4,"REM"      ; token $3e2c
>01014f	f4 4c 45 54				 .text $f4,"LET"      ; token $3e2d
>010153	f7 41 53 53 45 52 54			 .text $f7,"ASSERT"   ; token $3e2e
>01015a	f4 45 4e 44				 .text $f4,"END"      ; token $3e2f
>01015e	f4 52 55 4e				 .text $f4,"RUN"      ; token $3e30
>010162	f5 53 54 4f 50				 .text $f5,"STOP"     ; token $3e31
>010167	f6 43 4c 45 41 52			 .text $f6,"CLEAR"    ; token $3e32
>01016d	f4 44 49 4d				 .text $f4,"DIM"      ; token $3e33
>010171	f4 43 4c 53				 .text $f4,"CLS"      ; token $3e34
>010175	f6 50 52 49 4e 54			 .text $f6,"PRINT"    ; token $3e35
>01017b	f5 47 4f 54 4f				 .text $f5,"GOTO"     ; token $3e36
>010180	f6 47 4f 53 55 42			 .text $f6,"GOSUB"    ; token $3e37
>010186	f7 52 45 54 55 52 4e			 .text $f7,"RETURN"   ; token $3e38
>01018d	f3 4f 4e				 .text $f3,"ON"       ; token $3e39
>010190	f5 45 4c 53 45				 .text $f5,"ELSE"     ; token $3e3a
>010195	f5 50 4f 4b 45				 .text $f5,"POKE"     ; token $3e3b
>01019a	f5 44 4f 4b 45				 .text $f5,"DOKE"     ; token $3e3c
>01019f	f5 4c 4f 4b 45				 .text $f5,"LOKE"     ; token $3e3d
>0101a4	f5 4c 49 53 54				 .text $f5,"LIST"     ; token $3e3e
>0101a9	f5 4c 49 4e 4b				 .text $f5,"LINK"     ; token $3e3f
>0101ae	f4 4e 45 57				 .text $f4,"NEW"      ; token $3e40
>0101b2	f5 50 52 4f 43				 .text $f5,"PROC"     ; token $3e41
>0101b7	f6 4c 4f 43 41 4c			 .text $f6,"LOCAL"    ; token $3e42
>0101bd	f4 56 44 55				 .text $f4,"VDU"      ; token $3e43
>0101c1	e7 52 45 50 45 41 54			 .text $e7,"REPEAT"   ; token $3c44
>0101c8	e6 57 48 49 4c 45			 .text $e6,"WHILE"    ; token $3c45
>0101ce	e3 49 46				 .text $e3,"IF"       ; token $3c46
>0101d1	e4 46 4f 52				 .text $e4,"FOR"      ; token $3c47
>0101d5	e8 44 45 46 50 52 4f 43			 .text $e8,"DEFPROC"  ; token $3c48
>0101dd	d5 57 45 4e 44				 .text $d5,"WEND"     ; token $3a49
>0101e2	d6 55 4e 54 49 4c			 .text $d6,"UNTIL"    ; token $3a4a
>0101e8	d5 54 48 45 4e				 .text $d5,"THEN"     ; token $3a4b
>0101ed	d6 45 4e 44 49 46			 .text $d6,"ENDIF"    ; token $3a4c
>0101f3	d5 4e 45 58 54				 .text $d5,"NEXT"     ; token $3a4d
>0101f8	d8 45 4e 44 50 52 4f 43			 .text $d8,"ENDPROC"  ; token $3a4e
>010200	00					.byte $00
=$2001					ampersandTokenID                 = $2001
=$2002					barTokenID                       = $2002
=$2003					hatTokenID                       = $2003
=$2204					lessTokenID                      = $2204
=$2205					greaterTokenID                   = $2205
=$2206					equalTokenID                     = $2206
=$2207					lessequalTokenID                 = $2207
=$2208					greaterequalTokenID              = $2208
=$2209					lessgreaterTokenID               = $2209
=$240a					plusTokenID                      = $240a
=$240b					minusTokenID                     = $240b
=$260c					starTokenID                      = $260c
=$260d					slashTokenID                     = $260d
=$260e					percentTokenID                   = $260e
=$260f					greatergreaterTokenID            = $260f
=$2610					lesslessTokenID                  = $2610
=$3011					rndlparenTokenID                 = $3011
=$3012					sgnlparenTokenID                 = $3012
=$3013					abslparenTokenID                 = $3013
=$3014					lenlparenTokenID                 = $3014
=$3015					vallparenTokenID                 = $3015
=$3016					strdollarlparenTokenID           = $3016
=$3017					chrdollarlparenTokenID           = $3017
=$3018					asclparenTokenID                 = $3018
=$3019					spclparenTokenID                 = $3019
=$301a					peeklparenTokenID                = $301a
=$301b					deeklparenTokenID                = $301b
=$301c					leeklparenTokenID                = $301c
=$301d					lowerdollarlparenTokenID         = $301d
=$301e					upperdollarlparenTokenID         = $301e
=$301f					leftdollarlparenTokenID          = $301f
=$3020					middollarlparenTokenID           = $3020
=$3021					rightdollarlparenTokenID         = $3021
=$3022					instrlparenTokenID               = $3022
=$3023					inkeylparenTokenID               = $3023
=$3224					commaTokenID                     = $3224
=$3225					semicolonTokenID                 = $3225
=$3226					colonTokenID                     = $3226
=$3227					lparenTokenID                    = $3227
=$3228					rparenTokenID                    = $3228
=$3229					squoteTokenID                    = $3229
=$382a					toTokenID                        = $382a
=$382b					stepTokenID                      = $382b
=$3e2c					remTokenID                       = $3e2c
=$3e2d					letTokenID                       = $3e2d
=$3e2e					assertTokenID                    = $3e2e
=$3e2f					endTokenID                       = $3e2f
=$3e30					runTokenID                       = $3e30
=$3e31					stopTokenID                      = $3e31
=$3e32					clearTokenID                     = $3e32
=$3e33					dimTokenID                       = $3e33
=$3e34					clsTokenID                       = $3e34
=$3e35					printTokenID                     = $3e35
=$3e36					gotoTokenID                      = $3e36
=$3e37					gosubTokenID                     = $3e37
=$3e38					returnTokenID                    = $3e38
=$3e39					onTokenID                        = $3e39
=$3e3a					elseTokenID                      = $3e3a
=$3e3b					pokeTokenID                      = $3e3b
=$3e3c					dokeTokenID                      = $3e3c
=$3e3d					lokeTokenID                      = $3e3d
=$3e3e					listTokenID                      = $3e3e
=$3e3f					linkTokenID                      = $3e3f
=$3e40					newTokenID                       = $3e40
=$3e41					procTokenID                      = $3e41
=$3e42					localTokenID                     = $3e42
=$3e43					vduTokenID                       = $3e43
=$3c44					repeatTokenID                    = $3c44
=$3c45					whileTokenID                     = $3c45
=$3c46					ifTokenID                        = $3c46
=$3c47					forTokenID                       = $3c47
=$3c48					defprocTokenID                   = $3c48
=$3a49					wendTokenID                      = $3a49
=$3a4a					untilTokenID                     = $3a4a
=$3a4b					thenTokenID                      = $3a4b
=$3a4c					endifTokenID                     = $3a4c
=$3a4d					nextTokenID                      = $3a4d
=$3a4e					endprocTokenID                   = $3a4e

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/data.asm

=$f000					DirectPage = $F000
=$00					DPBaseAddress = $00 						; Base address used for direct page.
=0					DPageNumber = DPBaseAddress+0 				; page number of workspace area (upper 8 bits of address)
=2					DBaseAddress = DPBaseAddress+2 				; low memory for workspace area
=4					DHighAddress = DPBaseAddress+4 				; high memory for workspace area
=6					DCodePtr = DPBaseAddress+6 					; address of code - current token.
=8					DTemp1 = DPBaseAddress + 8 					; *** LONG *** Temporary value
=12					DTemp2 = DPBaseAddress + 12 				; *** LONG *** Temporary value
=16					DRandom = DPBaseAddress + 16 				; *** LONG *** Random Seed
=20					DSignCount = DPBaseAddress + 20 			; Sign count in division.
=22					DTempStringPointer = DPBaseAddress + 22 	; memory allocated to temp string pointer, going down.
=24					DStartTempString = DPBaseAddress + 24 		; start of current temporary string
=26					DCurrentTempString = DPBaseAddress + 26 	; current position in temporary string.
=28					DConstantShift = DPBaseAddress + 28 		; constant shift store.
=30					DVariablePtr = DPBaseAddress + 30 			; address of found variable.
=32					DHashTablePtr = DPBaseAddress + 32 			; address of hash entry of searched variable.
=34					DLineNumber = DPBaseAddress + 34 			; current line number.
=36					DTemp3 = DPBaseAddress + 36 				; *** LONG *** Temporary Value.
=40					DCursor = DPBaseAddress + 40 				; cursor (for external routines, not used by BASIC)
=42					DStack = DPBaseAddress + 42 				; BASIC stack pointer.
=44					DIndent = DPBaseAddress + 44 				; indent for LIST
=46					DIndent2 = DPBaseAddress + 46 				; previous indent.
=48					DListBuffer = DPBaseAddress + 48 			; list buffer address.
=50					DTemp4 = DPBaseAddress + 50 				; *** LONG *** Temporary Value
=54					DTemp5 = DPBaseAddress + 54 				; *** LONG *** Temporary Value
=58					DStack65816 = DPBaseAddress + 58 			; 65816 Stack pointer.
=60					DTarget = DPBaseAddress + 60 				; target address for PROC call.
=62					DArrayType = DPBaseAddress + 62 			; type of array being created.
=$80					BASStack = $80 								; start of Basic stack.
=$180					BASStackSize = $180 						; maximum size of BASIC stack.
=$200					EXSBase = $200 								; Initial value of X at lowest stack level.
=16					EXSStackElements = 16 						; depth of stack.
=0					EXSValueL = 0 								; Low word
=2					EXSValueH = 2  								; High word
=4					EXSPrecType = 4								; Precedence level / type is in bit 15, 1 = string.
=6					EXSNext = 6 								; offset to next level.
=608					PRMBuffer = EXSBase+EXSStackElements*3*2 	; buffer for parameter values.
=1022					CPUStack = EXSBase+$200-2 					; CPU Stack initial value.

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/expression.asm

.010201					Evaluate:
.010201	a2 00 02	ldx #$0200			ldx		#EXSBase 					; reset the stack
.010204	a9 00 00	lda #$0000			lda 	#0<<TokenShift 				; start at the lowest precedence level.
.010207					EvaluateLevel:
.010207	29 ff 7f	and #$7fff			and 	#$7FFF 						; zero type bit, which means integer unless we change it.
.01020a	95 04		sta $04,x			sta 	EXSPrecType+0,x 			; save precedence level.
.01020c	b2 06		lda ($06)			lda 	(DCodePtr)					; look at the next token
.01020e	c9 00 c0	cmp #$c000			cmp 	#$C000 						; if $C000-$CFFF then variable.
.010211	b0 75		bcs $010288			bcs 	_ELVariable
.010213	c9 00 40	cmp #$4000			cmp 	#$4000 						; if $4000-$BFFF then constant
.010216	b0 16		bcs $01022e			bcs 	_ELConstant
.010218	c9 00 10	cmp #$1000			cmp 	#$1000 						; if $0000-$00FF then it's a end of line or string.
.01021b	90 7b		bcc $010298			bcc 	_ELStringConstant
.01021d	c9 00 20	cmp #$2000			cmp 	#$2000 						; if $1000-$1FFF then it's a constant shift
.010220	90 03		bcc $010225			bcc 	_ELConstantShift
.010222	82 90 00	brl $0102b5			brl 	_ELUnaryKeyword 			; if $2000-$3FFF then it's a unary operator/keyword
.010225					_ELConstantShift:
.010225	29 ff 0f	and #$0fff			and 	#$0FFF 						; mask out bits 11-0
.010228	85 1c		sta $1c				sta 	DConstantShift 				; save in constant shift
.01022a	e6 06		inc $06				inc 	DCodePtr 					; skip over the token.
.01022c	e6 06		inc $06				inc 	DCodePtr
.01022e					_ELConstant:
.01022e	b2 06		lda ($06)			lda 	(DCodePtr)					; get the constant value
.010230	38		sec				sec  								; shift it in the range 0-32767
.010231	e9 00 40	sbc #$4000			sbc 	#$4000
.010234	0a		asl a				asl 	a 							; shift it left, losing bit 15
.010235	46 1c		lsr $1c				lsr 	DConstantShift 				; shift constant right into carry.
.010237	6a		ror a				ror 	a 							; rotate that into the constant value
.010238	95 00		sta $00,x			sta 	EXSValueL+0,x 				; save as low word
.01023a	a5 1c		lda $1c				lda 	DConstantShift 				; constant shift is high word.
.01023c	95 02		sta $02,x			sta 	EXSValueH+0,x
.01023e	64 1c		stz $1c				stz 	DConstantShift 				; clear the constant shift
.010240	e6 06		inc $06				inc 	DCodePtr 					; skip over constant
.010242	e6 06		inc $06				inc 	DCodePtr
.010244					_ELGotAtom:
.010244	b2 06		lda ($06)			lda 	(DCodePtr) 					; get code pointer.
.010246	a8		tay				tay 								; save in Y
.010247	29 00 f0	and #$f000			and 	#$F000 						; is it 0010 xxxk e.g. a binary operator.
.01024a	c9 00 20	cmp #$2000			cmp 	#$2000 						; if not then exit
.01024d	d0 31		bne $010280			bne 	_ELExit
.01024f	b5 04		lda $04,x			lda 	EXSPrecType+0,x 			; get precedence/type
.010251	29 00 1e	and #$1e00			and 	#15 << TokenShift 			; mask out the precedence bits.
.010254	85 08		sta $08				sta 	DTemp1 						; save in temporary register
.010256	98		tya				tya 								; get the keyword token back
.010257	29 00 1e	and #$1e00			and 	#15 << TokenShift 			; mask out the precedence bits.
.01025a	c5 08		cmp $08				cmp 	DTemp1 						; compare against precedence of the new binary operator.
.01025c	90 22		bcc $010280			bcc 	_ELExit 					; precedence too low, then exit.
.01025e	5a		phy				phy 								; save the binary operator on the stack
.01025f	e6 06		inc $06				inc 	DCodePtr 					; skip over the binary operator.
.010261	e6 06		inc $06				inc 	DCodePtr
.010263	18		clc				clc 								; try the next level up
.010264	69 00 02	adc #$0200			adc 	#1 << TokenShift
.010267	20 01 03	jsr $010301			jsr 	EvaluateNextGivenLevel
.01026a	7a		ply				ply 								; get operator token back into Y
.01026b					_ELExecuteY:
.01026b	98		tya				tya
.01026c	29 ff 01	and #$01ff			and 	#$01FF 						; keyword ID.
.01026f	0a		asl a				asl 	a 							; double it as keyword vector table is word data
.010270	9b		txy				txy 								; save X in Y
.010271	aa		tax				tax 								; double keyword ID in X
.010272	bf 00 00 01	lda $010000,x			lda 	CommandJumpTable,x 			; this is the vector address
.010276	bb		tyx				tyx 								; restore X.
.010277	8f 7c 02 01	sta $01027c			sta 	_ELCallRoutine+1 			; Self modifying, will not work in ROM.
.01027b					_ELCallRoutine:
.01027b	20 7b 02	jsr $01027b			jsr 	_ELCallRoutine 				; call the new address *MODIFIED*
.01027e	80 c4		bra $010244			bra 	_ELGotAtom 					; go round operator level again.
.010280	b5 04		lda $04,x	_ELExit:lda 	EXSPrecType+0,x 			; type into carry
.010282	0a		asl a				asl 	a
.010283	b5 00		lda $00,x			lda 	EXSValueL+0,x 				; put result into YA
.010285	b4 02		ldy $02,x			ldy 	EXSValueH+0,x
.010287	60		rts				rts
.010288					_ELVariable:
.010288	16 04		asl $04,x			asl 	EXSPrecType+0,x 			; shift it left
.01028a	20 4b 03	jsr $01034b			jsr 	VariableAccessExpression	; this will be 'find variable, error if failed', get value.
.01028d	95 00		sta $00,x			sta 	EXSValueL+0,x 				; save variable contents in stack
.01028f	94 02		sty $02,x			sty 	EXSValueH+0,x
.010291	76 04		ror $04,x			ror 	EXSPrecType+0,x 			; shift right rotating the carry in.
.010293	80 af		bra $010244			bra 	_ELGotAtom
.010295					_ELSyntax
.010295	82 24 03	brl $0105bc			brl 	SyntaxError
.010298					_ELStringConstant:
.010298	09 00 00	ora #$0000			ora 	#0000 						; if it is $0000 then we have an error, end of line.
.01029b	f0 f8		beq $010295			beq 	_ELSyntax
.01029d	a5 06		lda $06				lda 	DCodePtr 					; get the code pointer and add 2, to point to the string
.01029f	1a		inc a				inc 	a
.0102a0	1a		inc a				inc 	a
.0102a1	95 00		sta $00,x			sta 	EXSValueL+0,x 				; this is the low word
.0102a3	74 02		stz $02,x			stz 	EXSValueH+0,x 				; high word is zero.
.0102a5	b2 06		lda ($06)			lda 	(DCodePtr)					; get length to skip
.0102a7	18		clc				clc 								; add to string constant.
.0102a8	65 06		adc $06				adc 	DCodePtr
.0102aa	85 06		sta $06				sta 	DCodePtr
.0102ac	b5 04		lda $04,x			lda 	EXSPrecType+0,x 			; set type to string
.0102ae	09 00 80	ora #$8000			ora 	#$8000
.0102b1	95 04		sta $04,x			sta 	EXSPrecType+0,x
.0102b3	80 8f		bra $010244			bra 	_ELGotAtom
.0102b5					_ELUnaryKeyword:
.0102b5	b2 06		lda ($06)			lda 	(DCodePtr)					; look at the next token
.0102b7	a8		tay				tay 								; put the token in Y.
.0102b8	e6 06		inc $06				inc 	DCodePtr 					; skip over it
.0102ba	e6 06		inc $06				inc 	DCodePtr
.0102bc	29 00 1e	and #$1e00			and 	#15 << TokenShift			; mask out the keyword type.
.0102bf	c9 00 10	cmp #$1000			cmp 	#UnaryFunction<<TokenShift 	; if it is xxx1 000x then it's a unary function
.0102c2	f0 a7		beq $01026b			beq 	_ELExecuteY					; go back and execute it
.0102c4	c0 27 32	cpy #$3227			cpy 	#lparenTokenID 				; is it an open bracket ?
.0102c7	d0 11		bne $0102da			bne 	_ELUnaryOperator 			; it not, try unary operators.
.0102c9	20 fe 02	jsr $0102fe			jsr 	EvaluateNext 				; evaluate the expression
.0102cc	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket 			; consume the right bracket.
.0102cf					_ELCopy:
.0102cf	b5 06		lda $06,x			lda 	EXSValueL+EXSNext,x 		; just copy the value
.0102d1	95 00		sta $00,x			sta 	EXSValueL+0,x
.0102d3	b5 08		lda $08,x			lda 	EXSValueH+EXSNext,x
.0102d5	95 02		sta $02,x			sta 	EXSValueH+0,x
.0102d7	82 6a ff	brl $010244			brl 	_ELGotAtom 					; and continue.
.0102da					_ELUnaryOperator:
.0102da	5a		phy				phy 								; save the operator on the stack.
.0102db	20 f9 02	jsr $0102f9			jsr 	EvaluateNextAtomic 			; evaluate atom to be operated on.
.0102de	68		pla				pla 								; restore the unary operator.
.0102df	c9 0b 24	cmp #$240b			cmp 	#minusTokenID				; -xxx is unary negation
.0102e2	f0 03		beq $0102e7			beq 	_ELMinus
.0102e4	4c bc 05	jmp $0105bc			jmp 	SyntaxError
.0102e7					_ELMinus:
.0102e7	38		sec				sec 								; do the negation calculation.
.0102e8	a9 00 00	lda #$0000			lda 	#0
.0102eb	f5 06		sbc $06,x			sbc 	EXSValueL+EXSNext,x
.0102ed	95 00		sta $00,x			sta 	EXSValueL+0,x
.0102ef	a9 00 00	lda #$0000			lda 	#0
.0102f2	f5 08		sbc $08,x			sbc 	EXSValueH+EXSNext,x
.0102f4	95 02		sta $02,x			sta 	EXSValueH+0,x
.0102f6	82 4b ff	brl $010244			brl 	_ELGotAtom					; and continue.
.0102f9					EvaluateNextAtomic:
.0102f9	a9 00 0e	lda #$0e00			lda 	#7<<TokenShift
.0102fc	80 03		bra $010301			bra 	EvaluateNextGivenLevel
.0102fe					EvaluateNext:
.0102fe	a9 00 00	lda #$0000			lda 	#0<<TokenShift
.010301					EvaluateNextGivenLevel:
.010301	da		phx				phx
.010302	e8		inx				inx
.010303	e8		inx				inx
.010304	e8		inx				inx
.010305	e8		inx				inx
.010306	e8		inx				inx
.010307	e8		inx				inx
.010308	20 07 02	jsr $010207			jsr 	EvaluateLevel
.01030b	fa		plx				plx
.01030c	60		rts				rts
.01030d					EvaluateInteger:
.01030d	20 01 02	jsr $010201			jsr 	Evaluate
.010310	b0 01		bcs $010313			bcs 	EIType
.010312	60		rts				rts
.010313					EIType:
.010313	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>010316	4e 75 6d 62 65 72 20 65				.text 	"Number expected",$00 								; with this message
>01031e	78 70 65 63 74 65 64 00
.010326					EvaluateNextInteger:
.010326	20 fe 02	jsr $0102fe			jsr 	EvaluateNext
.010329	b0 e8		bcs $010313			bcs 	EIType
.01032b	60		rts				rts
.01032c					EvaluateString:
.01032c	20 01 02	jsr $010201			jsr 	Evaluate
.01032f	90 01		bcc $010332			bcc 	ESType
.010331	60		rts				rts
.010332					ESType:
.010332	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>010335	53 74 72 69 6e 67 20 65				.text 	"String expected",$00 								; with this message
>01033d	78 70 65 63 74 65 64 00
.010345					EvaluateNextString:
.010345	20 fe 02	jsr $0102fe			jsr 	EvaluateNext
.010348	90 e8		bcc $010332			bcc 	ESType
.01034a	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/variable.asm

.01034b					VariableAccessExpression:
.01034b	b2 06		lda ($06)			lda 	(DCodePtr)					; get the first token, push on stack
.01034d	48		pha				pha
.01034e	20 9a 03	jsr $01039a			jsr 	VariableFind 				; try to find the variables
.010351	85 1e		sta $1e				sta 	DVariablePtr 				; store the result in DVariablePtr
.010353	90 31		bcc $010386			bcc 	_VANError 					; not found, so report an error.
.010355	68		pla				pla 								; get and save that first token
.010356	48		pha				pha 								; we use it for typing.
.010357	a8		tay				tay 								; put first token in Y.
.010358	29 00 10	and #$1000			and 	#IDArrayMask 				; is it an array ?
.01035b	f0 07		beq $010364			beq 	_VANNotArray
.01035d	a5 1e		lda $1e				lda 	DVariablePtr 				; variable pointer into A
.01035f	20 11 04	jsr $010411			jsr 	VariableSubscript			; index calculation
.010362	85 1e		sta $1e				sta 	DVariablePtr 				; and write it back.
.010364					_VANNotArray:
.010364	68		pla				pla 								; get the token back.
.010365	29 00 20	and #$2000			and 	#IDTypeMask 				; this is the integer/string bit. $2000 if string, $0000 if int
.010368	49 00 20	eor #$2000			eor 	#IDTypeMask 				; now $0000 if string, $2000 if integer.
.01036b	f0 0a		beq $010377			beq 	_VANIsString 				; if zero, Y = 0 and just load the lower address with the variable (string)
.01036d	18		clc				clc 								; returning a number, read high data word
.01036e	a0 02 00	ldy #$0002			ldy 	#2
.010371	b1 1e		lda ($1e),y			lda 	(DVariablePtr),y
.010373	a8		tay				tay 								; put A into Y (this is the high byte)
.010374	b2 1e		lda ($1e)			lda 	(DVariablePtr)				; read the low data word
.010376	60		rts				rts
.010377					_VANIsString:
.010377	a0 00 00	ldy #$0000			ldy 	#0 							; load string into YA
.01037a	b2 1e		lda ($1e)			lda 	(DVariablePtr)
.01037c	d0 06		bne $010384			bne 	_VANNotEmptyString
.01037e	a9 0c 00	lda #$000c			lda 	#Block_NullString 			; if value is $0000 then return the empty string
.010381	18		clc				clc 								; which is always maintained.
.010382	65 02		adc $02				adc 	DBaseAddress
.010384					_VANNotEmptyString:
.010384	38		sec				sec
.010385	60		rts				rts
.010386					_VANError:
.010386	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>010389	56 61 72 69 61 62 6c 65				.text 	"Variable unknown",$00 								; with this message
>010391	20 75 6e 6b 6e 6f 77 6e 00
.01039a					VariableFind:
.01039a	b2 06		lda ($06)			lda 	(DCodePtr)					; look at the first token
.01039c	c9 00 c0	cmp #$c000			cmp 	#$C000 						; must be $C000-$FFFF, an identifier.
.01039f	90 5c		bcc $0103fd			bcc 	_VFError
.0103a1	c9 1b c0	cmp #$c01b			cmp 	#$C01A+1					; C01A is identifier, no continuation Z
.0103a4	b0 11		bcs $0103b7			bcs 	_VFSlowVariable 			; < this it is the fast variable A-Z
.0103a6	29 1f 00	and #$001f			and 	#$001F 						; now it is 1-26.
.0103a9	3a		dec a				dec 	a 							; now 0-25
.0103aa	0a		asl a				asl 	a 							; x 4 and clear carry
.0103ab	0a		asl a				asl 	a
.0103ac	69 10 00	adc #$0010			adc 	#Block_FastVariables 		; offset to fast variables
.0103af	65 02		adc $02				adc 	DBaseAddress 				; now an actual address in A
.0103b1	e6 06		inc $06				inc 	DCodePtr 					; skip over the token (only one)
.0103b3	e6 06		inc $06				inc 	DCodePtr
.0103b5	38		sec				sec 								; return with carry set.
.0103b6	60		rts				rts
.0103b7					_VFSlowVariable:
.0103b7	b2 06		lda ($06)			lda 	(DCodePtr)					; get the token
.0103b9	29 00 30	and #$3000			and 	#(IDTypeMask+IDArrayMask) 	; get the type bits out --tt ---- ---- ----
.0103bc	eb		xba				xba 								; now this is 0000 0000 00tt 0000 e.g. tt x 16
.0103bd	0a		asl a				asl 	a 							; 32 bytes (16 x 2 byteentries) per table, also clc
.0103be	69 80 00	adc #$0080			adc 	#Block_HashTable 			; now its the correct has table offset
.0103c1	65 02		adc $02				adc 	DBaseAddress 				; now the actual address
.0103c3	85 08		sta $08				sta 	DTemp1 						; so this is the base of the hash table for the type
.0103c5	b2 06		lda ($06)			lda 	(DCodePtr) 					; get the token - building the hash code.
.0103c7	29 0f 00	and #$000f			and 	#Block_HashMask 			; now a mask value, very simple but okay I think.
.0103ca	0a		asl a				asl 	a 							; double (word entries) and clear carry
.0103cb	65 08		adc $08				adc 	DTemp1 						; add to the base hash table
.0103cd	85 20		sta $20				sta 	DHashTablePtr 				; save pointer for later
.0103cf	85 08		sta $08				sta 	DTemp1 						; save in DTemp1, which we will use to follow the chain.
.0103d1					_VFNext:
.0103d1	b2 08		lda ($08)			lda 	(DTemp1) 					; normally the link, first time will be the header.
.0103d3	f0 26		beq $0103fb			beq 	_VFFail 					; if zero, then it's the end of the list.
.0103d5	85 08		sta $08				sta 	DTemp1 						; this is the new variable record to check
.0103d7	a8		tay				tay 								; read the address of the name at $0002,y
.0103d8	b9 02 00	lda $0002,y			lda 	$0002,y
.0103db	85 0c		sta $0c				sta 	DTemp2 						; save in DTemp2
.0103dd	a0 00 00	ldy #$0000			ldy 	#0 							; start matching lists of tokens, we can do it in words
.0103e0					_VFCompare:
.0103e0	b1 0c		lda ($0c),y			lda 	(DTemp2),y 					; see if they match
.0103e2	d1 06		cmp ($06),y			cmp 	(DCodePtr),y
.0103e4	d0 eb		bne $0103d1			bne 	_VFNext 					; if not, go to the next one.
.0103e6	c8		iny				iny 								; advance token pointer
.0103e7	c8		iny				iny
.0103e8	29 00 08	and #$0800			and 	#IDContMask 				; if continuation bit set, keep going (if they match)
.0103eb	d0 f3		bne $0103e0			bne 	_VFCompare
.0103ed	98		tya				tya 								; this is the length of the word.
.0103ee	18		clc				clc 								; so we add it to the code pointer
.0103ef	65 06		adc $06				adc 	DCodePtr
.0103f1	85 06		sta $06				sta 	DCodePtr 					; now points to the token after the identifier.
.0103f3	a5 08		lda $08				lda 	DTemp1 						; this is the variable record
.0103f5	18		clc				clc 								; four on is the actual data
.0103f6	69 04 00	adc #$0004			adc 	#4 							; or it's the reference for the data for arrays.
.0103f9	38		sec				sec 								; return with CS indicating success
.0103fa	60		rts				rts
.0103fb					_VFFail:
.0103fb	18		clc				clc
.0103fc	60		rts				rts
.0103fd					_VFError:
.0103fd	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>010400	4d 69 73 73 69 6e 67 20				.text 	"Missing variable",$00 								; with this message
>010408	76 61 72 69 61 62 6c 65 00
.010411					VariableSubscript:
.010411	5a		phy				phy 								; save Y
.010412	a8		tay				tay 								; put the link pointer into Y
.010413	b9 00 00	lda $0000,y			lda 	$0000,y 					; read the link, this is the array data block.
.010416	48		pha				pha		 							; save array data block address on stack.
.010417	20 26 03	jsr $010326			jsr		EvaluateNextInteger 		; get the subscript
.01041a	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket 			; skip right bracket.
.01041d	c0 00 00	cpy #$0000			cpy 	#0 							; msword must be zero
.010420	d0 14		bne $010436			bne 	_VANSubscript
.010422	7a		ply				ply 								; start of array memory block.
.010423	d9 00 00	cmp $0000,y			cmp 	$0000,y						; the max index is at the start, so check against that.
.010426	f0 02		beq $01042a			beq 	_VANSubOkay 				; fail if subscript > high subscript
.010428	b0 0c		bcs $010436			bcs 	_VANSubscript
.01042a					_VANSubOkay:
.01042a	0a		asl a				asl 	a 							; double lsword
.01042b	0a		asl a				asl 	a 							; and again, also clears carry.
.01042c	85 08		sta $08				sta 	DTemp1	 					; 4 x subscript in DTemp1
.01042e	98		tya				tya 								; restore the address of the array memory block.
.01042f	1a		inc a				inc 	a 							; add 2 to get it past the high subscript
.010430	1a		inc a				inc 	a
.010431	18		clc				clc
.010432	65 08		adc $08				adc 	DTemp1 						; add the subscript x 4
.010434	7a		ply				ply 								; restore Y
.010435	60		rts				rts
.010436					_VANSubscript:
.010436	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>010439	42 61 64 20 41 72 72 61				.text 	"Bad Array Subscript",$00 								; with this message
>010441	79 20 53 75 62 73 63 72 69 70 74 00
.01044d					VariableCreate:
.01044d	a0 08 00	ldy #$0008			ldy 	#Block_LowMemoryPtr 		; get low memory
.010450	b1 02		lda ($02),y			lda 	(DBaseAddress),y
.010452	48		pha				pha 								; save it
.010453	18		clc				clc
.010454	69 08 00	adc #$0008			adc 	#8
.010457	91 02		sta ($02),y			sta 	(DBaseAddress),y 			; update low memory
.010459	a0 0a 00	ldy #$000a			ldy 	#Block_HighMemoryPtr 		; check allocation.
.01045c	d1 02		cmp ($02),y			cmp 	(DBaseAddress),y
.01045e	b0 38		bcs $010498			bcs 	_VCOutOfMemory
.010460	7a		ply				ply 								; restore new variable address to Y.
.010461	a9 00 00	lda #$0000			lda 	#$0000 						; clear that word to empty string/zero.
.010464	99 04 00	sta $0004,y			sta 	$0004,y 					; data from +4..+7 is zeroed.
.010467	99 06 00	sta $0006,y			sta 	$0006,y
.01046a	b2 20		lda ($20)			lda 	(DHashTablePtr)				; get the link to next.
.01046c	99 00 00	sta $0000,y			sta 	$0000,y 					; save at offset +0
.01046f	a9 00 02	lda #$0200			lda 	#Block_ProgramStart 		; work out the program start
.010472	18		clc				clc 								; in DTemp1.
.010473	65 02		adc $02				adc 	DBaseAddress
.010475	85 08		sta $08				sta 	DTemp1
.010477	a5 06		lda $06				lda 	DCodePtr 					; get the address of the token.
.010479	c5 08		cmp $08				cmp 	DTemp1 						; if it is below the program start we need to clone it.
.01047b	b0 03		bcs $010480			bcs 	_VCDontClone 				; because the variable being created has its identifier
.01047d	20 9b 04	jsr $01049b			jsr 	VCCloneIdentifier	 		; in the token workspace, done via the command line
.010480					_VCDontClone:
.010480	99 02 00	sta $0002,y			sta 	$0002,y 					; save at offset +2
.010483	98		tya				tya 								; update the head link
.010484	92 20		sta ($20)			sta 	(DHashTablePtr)
.010486	18		clc				clc 								; advance pointer to the data part.
.010487	69 04 00	adc #$0004			adc 	#4
.01048a	48		pha				pha 								; save on stack.
.01048b					_VCSkipToken:
.01048b	b2 06		lda ($06)			lda 	(DCodePtr) 					; skip over the token
.01048d	e6 06		inc $06				inc 	DCodePtr
.01048f	e6 06		inc $06				inc 	DCodePtr
.010491	29 00 08	and #$0800			and 	#IDContMask 				; if there is a continuation
.010494	d0 f5		bne $01048b			bne 	_VCSkipToken
.010496	68		pla				pla 								; restore data address
.010497	60		rts				rts 								; and done.
.010498					_VCOutOfMemory:
.010498	82 31 01	brl $0105cc			brl 	OutOfMemoryError
.01049b					VCCloneIdentifier:
.01049b	da		phx				phx 								; save XY
.01049c	5a		phy				phy
.01049d	aa		tax				tax 								; identifier address in Y.
.01049e	a0 08 00	ldy #$0008			ldy 	#Block_LowMemoryPtr		 	; get low memory address, this will be the new identifier.
.0104a1	b1 02		lda ($02),y			lda 	(DBaseAddress),y
.0104a3	48		pha				pha
.0104a4					_VCCloneLoop:
.0104a4	a0 08 00	ldy #$0008			ldy 	#Block_LowMemoryPtr 		; get low memory
.0104a7	b1 02		lda ($02),y			lda 	(DBaseAddress),y
.0104a9	48		pha				pha 								; save on stack
.0104aa	1a		inc a				inc 	a 							; space for one token.
.0104ab	1a		inc a				inc 	a
.0104ac	91 02		sta ($02),y			sta 	(DBaseAddress),y
.0104ae	7a		ply				ply 								; address of word in Y
.0104af	bd 00 00	lda $0000,x			lda 	@w$0000,x 					; read the token
.0104b2	99 00 00	sta $0000,y			sta 	$0000,y 					; copy it into that new byte.
.0104b5	e8		inx				inx 								; advance the token pointer
.0104b6	e8		inx				inx
.0104b7	29 00 08	and #$0800			and 	#IDContMask 				; continuation ?
.0104ba	d0 e8		bne $0104a4			bne 	_VCCloneLoop
.0104bc	68		pla				pla 								; restore start address
.0104bd	7a		ply				ply 								; and the others
.0104be	fa		plx				plx
.0104bf	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/utility/editline.asm

.0104c0					LineDelete:
.0104c0	aa		tax				tax 	 							; this is the one we're looking for ....
.0104c1	a5 02		lda $02				lda 	DBaseAddress 				; work the start position
.0104c3	18		clc				clc
.0104c4	69 00 02	adc #$0200			adc 	#Block_ProgramStart
.0104c7	a8		tay				tay
.0104c8					_LDLoop:
.0104c8	b9 00 00	lda $0000,y			lda 	$0000,y 					; look at the link
.0104cb	f0 2d		beq $0104fa			beq 	_LDExit						; exit if zero ; line does not exist
.0104cd	8a		txa				txa 								; found a match
.0104ce	d9 02 00	cmp $0002,y			cmp 	$0002,y
.0104d1	f0 08		beq $0104db			beq		_LDFound
.0104d3	98		tya				tya 								; follow the link.
.0104d4	18		clc				clc
.0104d5	79 00 00	adc $0000,y			adc 	$0000,y
.0104d8	a8		tay				tay
.0104d9	80 ed		bra $0104c8			bra 	_LDLoop
.0104db					_LDFound:
.0104db	84 08		sty $08				sty 	DTemp1 						; copy to DTemp1
.0104dd	98		tya				tya 								; follow link to next.
.0104de	18		clc				clc
.0104df	79 00 00	adc $0000,y			adc 	$0000,y
.0104e2	85 0c		sta $0c				sta 	DTemp2 						; copy from DTemp2
.0104e4	20 5f 1c	jsr $011c5f			jsr 	FindCodeEnd 				; find the end of the code.
.0104e7	38		sec				sec
.0104e8	e5 0c		sbc $0c				sbc 	DTemp2 						; copy count
.0104ea	1a		inc a				inc 	a 							; copy the $0000 trailer (e.g. the last link/offset)
.0104eb	1a		inc a				inc 	a
.0104ec	aa		tax				tax
.0104ed	a0 00 00	ldy #$0000			ldy 	#0 							; block copy memory down.
.0104f0	b1 0c		lda ($0c),y	_LDCopy:lda 	(DTemp2),y
.0104f2	91 08		sta ($08),y			sta 	(DTemp1),y
.0104f4	c8		iny				iny
.0104f5	c8		iny				iny
.0104f6	ca		dex				dex
.0104f7	ca		dex				dex
.0104f8	d0 f6		bne $0104f0			bne 	_LDCopy
.0104fa					_LDExit:
.0104fa	60		rts				rts
.0104fb					LineInsert:
.0104fb	84 08		sty $08				sty 	DTemp1 						; save code in DTemp1
.0104fd	85 0c		sta $0c				sta 	DTemp2 						; save Line # in DTemp2
.0104ff	a0 00 00	ldy #$0000			ldy 	#0
.010502					_LIFindLength:
.010502	b1 08		lda ($08),y			lda 	(DTemp1),y 					; examine token
.010504	c9 00 00	cmp #$0000			cmp 	#$0000 						; if $0000 then found the end
.010507	f0 10		beq $010519			beq 	_LIFindEnd
.010509	c9 00 01	cmp #$0100			cmp 	#$0100 						; if < $0100 then just skip it
.01050c	90 04		bcc $010512			bcc 	_LIQString
.01050e	c8		iny				iny 								; otherwise just skip it.
.01050f	c8		iny				iny
.010510	80 f0		bra $010502			bra 	_LIFindLength
.010512					_LIQString:
.010512	98		tya				tya 								; skip quoted strings
.010513	18		clc				clc
.010514	71 08		adc ($08),y			adc 	(DTemp1),y
.010516	a8		tay				tay
.010517	80 e9		bra $010502			bra 	_LIFindLength
.010519					_LIFindEnd:
.010519	98		tya				tya 								; the tokens in the line
.01051a	18		clc				clc
.01051b	69 06 00	adc #$0006			adc 	#6 							; add 6. One for the ending zero, one for line, one for offset.
.01051e	85 24		sta $24				sta 	DTemp3 						; save this in DTemp3
.010520	a9 00 02	lda #$0200			lda 	#Block_ProgramStart
.010523	18		clc				clc
.010524	65 02		adc $02				adc 	DBaseAddress
.010526	a8		tay				tay
.010527					_LIFindInsertPoint:
.010527	b9 00 00	lda $0000,y			lda 	$0000,y						; if offset is zero, end, so insert here.
.01052a	f0 0f		beq $01053b			beq		_LIFoundInsertPoint
.01052c	b9 02 00	lda $0002,y			lda 	$0002,y 					; if line number here > line number required insert here.
.01052f	c5 0c		cmp $0c				cmp 	DTemp2
.010531	b0 08		bcs $01053b			bcs 	_LIFoundInsertPoint
.010533	98		tya				tya 								; if < go to the next line.
.010534	18		clc				clc
.010535	79 00 00	adc $0000,y			adc 	$0000,y
.010538	a8		tay				tay
.010539	80 ec		bra $010527			bra 	_LIFindInsertPoint
.01053b					_LIFoundInsertPoint:
.01053b	84 36		sty $36				sty 	DTemp5 						; save in DTemp5
.01053d	20 5f 1c	jsr $011c5f			jsr 	FindCodeEnd 				; get the end of the code.
.010540	85 32		sta $32				sta 	DTemp4 						; save in DTemp4
.010542	18		clc				clc
.010543	65 24		adc $24				adc 	DTemp3
.010545	85 34		sta $34				sta 	DTemp4+2 					; copying it to DTemp4 + length.
.010547					_LICopyMove:
.010547	b2 32		lda ($32)			lda 	(DTemp4) 					; copy the word
.010549	92 34		sta ($34)			sta 	(DTemp4+2)
.01054b	a5 32		lda $32				lda 	DTemp4 						; reached the insert point
.01054d	c5 36		cmp $36				cmp 	DTemp5
.01054f	f0 0a		beq $01055b			beq 	_LICopyMoveOver
.010551	c6 32		dec $32				dec 	DTemp4 						; shift all pointers.
.010553	c6 32		dec $32				dec 	DTemp4
.010555	c6 34		dec $34				dec 	DTemp4+2
.010557	c6 34		dec $34				dec 	DTemp4+2
.010559	80 ec		bra $010547			bra 	_LICopyMove
.01055b					_LICopyMoveOver:
.01055b	a5 24		lda $24				lda 	DTemp3 						; copy the length in, this is the offset
.01055d	92 36		sta ($36)			sta 	(DTemp5)
.01055f	a0 02 00	ldy #$0002			ldy 	#2
.010562	a5 0c		lda $0c				lda 	DTemp2 						; copy the line number in.
.010564	91 36		sta ($36),y			sta 	(DTemp5),y
.010566	a0 04 00	ldy #$0004			ldy 	#4
.010569					_LICopyTokens:
.010569	b2 08		lda ($08)			lda 	(DTemp1) 					; copy token over.
.01056b	91 36		sta ($36),y			sta 	(DTemp5),y
.01056d	c8		iny				iny
.01056e	c8		iny				iny
.01056f	e6 08		inc $08				inc 	DTemp1
.010571	e6 08		inc $08				inc 	DTemp1
.010573	c6 24		dec $24				dec 	DTemp3 						; count - 4 times.
.010575	c6 24		dec $24				dec 	DTemp3
.010577	a5 24		lda $24				lda 	DTemp3
.010579	c9 04 00	cmp #$0004			cmp 	#4
.01057c	d0 eb		bne $010569			bne 	_LICopyTokens
.01057e	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/utility/utility.asm

.01057f					ErrorHandler:
.01057f	c2 30		rep #$30			rep 	#$30 						; in case we changed it.
.010581	fa		plx				plx 								; address of error message -1
.010582	e8		inx				inx 								; error message.
.010583	20 39 06	jsr $010639			jsr 	PrintROMMessage 			; print message in ROM
.010586	a5 22		lda $22				lda 	DLineNumber 				; is it line 0 (e.g. typed in)
.010588	f0 15		beq $01059f			beq 	_EHEndMessage
.01058a	a2 a6 05	ldx #$05a6			ldx 	#_EHAt & $FFFF 				; print " at "
.01058d	20 39 06	jsr $010639			jsr 	PrintROMMessage
.010590	a5 22		lda $22				lda 	DLineNumber 				; Line# in YA
.010592	a0 00 00	ldy #$0000			ldy 	#0
.010595	a2 0a 00	ldx #$000a			ldx 	#10 						; base 10
.010598	20 c9 10	jsr $0110c9			jsr 	ConvertToString 			; convert and print it.
.01059b	a8		tay				tay
.01059c	20 57 06	jsr $010657			jsr 	PrintBASICString
.01059f					_EHEndMessage:
.01059f	20 6f 1e	jsr $011e6f			jsr 	HWNewLine
.0105a2	ea		nop				nop
.0105a3	4c 73 1f	jmp $011f73			jmp 	NextCommand 				; get next command.
>0105a6	20 61 74 20 00			_EHAt:	.text 	" at ",$00
.0105ab					IllegalToken:
.0105ab	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>0105ae	49 6c 6c 65 67 61 6c 20				.text 	"Illegal Token",$00 								; with this message
>0105b6	54 6f 6b 65 6e 00
.0105bc					SyntaxError:
.0105bc	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>0105bf	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",$00 								; with this message
>0105c7	72 72 6f 72 00
.0105cc					OutOfMemoryError:
.0105cc	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>0105cf	4f 75 74 20 6f 66 20 6d				.text 	"Out of memory",$00 								; with this message
>0105d7	65 6d 6f 72 79 00
.0105dd					ExpectToken:
.0105dd	d2 06		cmp ($06)			cmp 	(DCodePtr) 					; does it match the next token
.0105df	d0 05		bne $0105e6			bne 	_CTKError					; error if not
.0105e1	e6 06		inc $06				inc 	DCodePtr 					; skip the token
.0105e3	e6 06		inc $06				inc 	DCodePtr
.0105e5	60		rts				rts
.0105e6					_CTKError:
.0105e6	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>0105e9	4d 69 73 73 69 6e 67 20				.text 	"Missing token",$00 								; with this message
>0105f1	74 6f 6b 65 6e 00
.0105f7					ExpectRightBracket:
.0105f7	48		pha				pha
.0105f8	a9 28 32	lda #$3228			lda 	#rparenTokenID
.0105fb	20 dd 05	jsr $0105dd			jsr 	ExpectToken
.0105fe	68		pla				pla
.0105ff	60		rts				rts
.010600					ExpectComma:
.010600	48		pha				pha
.010601	a9 24 32	lda #$3224			lda 	#commaTokenID 				; shorthand because comma is used a fair bit.
.010604	20 dd 05	jsr $0105dd			jsr 	ExpectToken
.010607	68		pla				pla
.010608	60		rts				rts
.010609					CheckBothNumeric:
.010609	b5 04		lda $04,x			lda 	EXSPrecType+0,x 			; OR together their prec/type
.01060b	15 0a		ora $0a,x			ora 	EXSPrecType+EXSNext,x
.01060d	30 01		bmi $010610			bmi 	_CBNFail 					; need to both be zero in bit 15
.01060f	60		rts				rts
.010610					_CBNFail:
.010610	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>010613	4f 70 65 72 61 74 6f 72				.text 	"Operator integer only",$00 								; with this message
>01061b	20 69 6e 74 65 67 65 72 20 6f 6e 6c 79 00
.010629					ResetTypeInteger:
.010629	b5 04		lda $04,x			lda 	EXSPrecType+0,x 			; clear bit 15
.01062b	29 ff 7f	and #$7fff			and 	#$7FFF
.01062e	95 04		sta $04,x			sta 	EXSPrecType+0,x
.010630	60		rts				rts
.010631					ResetTypeString:
.010631	b5 04		lda $04,x			lda 	EXSPrecType+0,x 			; clear bit 15
.010633	09 00 80	ora #$8000			ora 	#$8000
.010636	95 04		sta $04,x			sta 	EXSPrecType+0,x
.010638	60		rts				rts
.010639					PrintROMMessage:
.010639	48		pha				pha
.01063a	da		phx				phx
.01063b					_PRMLoop:
.01063b	bf 00 00 01	lda $010000,x			lda 	StartOfBasicCode,x 			; print characters until $00 found.
.01063f	29 ff 00	and #$00ff			and 	#$00FF
.010642	f0 10		beq $010654			beq 	_PRMExit
.010644	c9 0d 00	cmp #$000d			cmp 	#13
.010647	d0 05		bne $01064e			bne 	_PRMChar
.010649	20 6f 1e	jsr $011e6f			jsr 	HWNewLine
.01064c	80 03		bra $010651			bra 	_PRMNext
.01064e					_PRMChar:
.01064e	20 1e 1e	jsr $011e1e			jsr 	HWPrintChar
.010651					_PRMNext:
.010651	e8		inx				inx
.010652	80 e7		bra $01063b			bra 	_PRMLoop
.010654					_PRMExit:
.010654	fa		plx				plx
.010655	68		pla				pla
.010656	60		rts				rts
.010657					PrintBASICString:
.010657	48		pha				pha
.010658	da		phx				phx
.010659	5a		phy				phy
.01065a	b9 00 00	lda $0000,y			lda 	$0000,y 					; get length
.01065d	29 ff 00	and #$00ff			and 	#$00FF
.010660	f0 0b		beq $01066d			beq 	_PBSExit 					; null string
.010662	aa		tax				tax
.010663					_PBSLoop:
.010663	c8		iny				iny
.010664	b9 00 00	lda $0000,y			lda 	$0000,y
.010667	20 1e 1e	jsr $011e1e			jsr 	HWPrintChar
.01066a	ca		dex				dex
.01066b	d0 f6		bne $010663			bne 	_PBSLoop
.01066d					_PBSExit:
.01066d	7a		ply				ply
.01066e	fa		plx				plx
.01066f	68		pla				pla
.010670	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/utility/stringconcrete.asm

.010671					StringResetPermanent:
.010671	a5 04		lda $04				lda 	DHighAddress				; the end of memory
.010673	a8		tay				tay
.010674	a0 0a 00	ldy #$000a			ldy 	#Block_HighMemoryPtr		; save the high memory pointer, which is the first link.
.010677	91 02		sta ($02),y			sta 	(DBaseAddress),y
.010679	60		rts				rts
.01067a					StringAssign:
.01067a	da		phx				phx 								; save X
.01067b	aa		tax				tax 								; new string address to X.
.01067c	b9 00 00	lda $0000,y			lda 	$0000,y 					; does the string pointer we replace have an address yet.
.01067f	f0 49		beq $0106ca			beq 	_SAAllocate 				; if not , allocate space for it and copy the string.
.010681	5a		phy				phy
.010682	b9 00 00	lda $0000,y			lda 	$0000,y 					; compare calculate saved address - high memory pointer
.010685	a0 0a 00	ldy #$000a			ldy 	#Block_HighMemoryPtr
.010688	d1 02		cmp ($02),y			cmp 	(DBaseAddress),y
.01068a	7a		ply				ply
.01068b	90 3d		bcc $0106ca			bcc 	_SAAllocate					; if < high memory pointer, first allocation.
.01068d	5a		phy				phy
.01068e	b9 00 00	lda $0000,y			lda 	$0000,y 					; address of the string
.010691	a8		tay				tay
.010692	88		dey				dey 								; point to the max length of the old string.
.010693	b9 00 00	lda $0000,y			lda 	$0000,y 					; length of string
.010696	7a		ply				ply
.010697	29 ff 00	and #$00ff			and 	#$00FF 						; max length of old string
.01069a	e2 20		sep #$20			sep 	#$20
.01069c	dd 00 00	cmp $0000,x			cmp 	@w$0000,x 					; compare against length of new string
.01069f	c2 20		rep #$20			rep 	#$20
.0106a1	b0 5a		bcs $0106fd			bcs 	_SACopyString 				; just copy it in if old max length >= new
.0106a3	b9 00 00	lda $0000,y			lda 	$0000,y 					; get the address of the string.
.0106a6	3a		dec a				dec 	a 							; if bottom, compare the previous byte address
.0106a7	5a		phy				phy 								; which is the max length.
.0106a8	a0 0a 00	ldy #$000a			ldy 	#Block_HighMemoryPtr
.0106ab	51 02		eor ($02),y			eor 	(DBaseAddress),y
.0106ad	7a		ply				ply
.0106ae	09 00 00	ora #$0000			ora 	#$0000 						; if not, then allocate memory.
.0106b1	d0 17		bne $0106ca			bne 	_SAAllocate
.0106b3	5a		phy				phy
.0106b4	b9 00 00	lda $0000,y			lda 	$0000,y 					; address of old string
.0106b7	a8		tay				tay 								; to Y
.0106b8	88		dey				dey 								; get maximum length.
.0106b9	b9 00 00	lda $0000,y			lda 	$0000,y
.0106bc	29 ff 00	and #$00ff			and 	#$00FF
.0106bf	1a		inc a				inc 	a 							; add 2 (string,max)
.0106c0	1a		inc a				inc 	a
.0106c1	a0 0a 00	ldy #$000a			ldy 	#Block_HighMemoryPtr 		; return memory back
.0106c4	18		clc				clc
.0106c5	71 02		adc ($02),y			adc 	(DBaseAddress),y
.0106c7	91 02		sta ($02),y			sta 	(DBaseAddress),y
.0106c9	7a		ply				ply
.0106ca					_SAAllocate:
.0106ca	bd 00 00	lda $0000,x			lda 	@w$0000,x 					; get the length of the string
.0106cd	29 ff 00	and #$00ff			and 	#$00FF
.0106d0	18		clc				clc
.0106d1	69 08 00	adc #$0008			adc 	#8 							; allocate extra space if needed.
.0106d4	c9 ff 00	cmp #$00ff			cmp 	#255 						; can't be larger than this.
.0106d7	90 03		bcc $0106dc			bcc 	_SASizeOkay
.0106d9	a9 ff 00	lda #$00ff			lda 	#255
.0106dc					_SASizeOkay:
.0106dc	5a		phy				phy 								; push [string] on the stack.
.0106dd	48		pha				pha 								; push largest string size on the stack.
.0106de	1a		inc a				inc 	a  							; one more for the string size byte
.0106df	1a		inc a				inc 	a 							; one more for the maximum size byte
.0106e0	49 ff ff	eor #$ffff			eor 	#$FFFF 						; subtract from the high memory pointer
.0106e3	38		sec				sec
.0106e4	a0 0a 00	ldy #$000a			ldy 	#Block_HighMemoryPtr
.0106e7	71 02		adc ($02),y			adc 	(DBaseAddress),y
.0106e9	91 02		sta ($02),y			sta 	(DBaseAddress),y
.0106eb	a0 08 00	ldy #$0008			ldy 	#Block_LowMemoryPtr 		; out of memory ? - if below the lowmemorypointer
.0106ee	d1 02		cmp ($02),y			cmp 	(DBaseAddress),y
.0106f0	90 29		bcc $01071b			bcc 	_SAMemory
.0106f2	a8		tay				tay 								; address of start of space in Y.
.0106f3	68		pla				pla 								; restore largest string size and save it
.0106f4	99 00 00	sta $0000,y			sta 	@w$0000,y 					; doesn't matter it's a word.
.0106f7	c8		iny				iny 								; Y now points to the first byte of the string we'll copy
.0106f8	98		tya				tya 								; in A now
.0106f9	7a		ply				ply 								; Y is the address of the variable pointer.
.0106fa	99 00 00	sta $0000,y			sta 	@w$0000,y 					; make that pointer the first byte
.0106fd					_SACopyString
.0106fd	bd 00 00	lda $0000,x			lda 	@w$0000,x 					; get length
.010700	29 ff 00	and #$00ff			and 	#$00FF
.010703	85 08		sta $08				sta 	DTemp1 						; save it.
.010705	b9 00 00	lda $0000,y			lda 	@w$0000,y 					; Y now contains the actual address of the string
.010708	a8		tay				tay
.010709					_SACopyStringLoop:
.010709	e2 20		sep #$20			sep 	#$20
.01070b	bd 00 00	lda $0000,x			lda 	@w$0000,x
.01070e	99 00 00	sta $0000,y			sta 	@w$0000,y
.010711	c2 20		rep #$20			rep 	#$20
.010713	e8		inx				inx
.010714	c8		iny				iny
.010715	c6 08		dec $08				dec 	DTemp1
.010717	10 f0		bpl $010709			bpl 	_SACopyStringLoop
.010719	fa		plx				plx 								; restore X
.01071a	60		rts				rts
.01071b					_SAMemory:
.01071b	82 ae fe	brl $0105cc			brl 	OutOfMemoryError

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/utility/stringtemp.asm

.01071e					StringTempAllocate:
.01071e	48		pha				pha
.01071f	a5 16		lda $16				lda 	DTempStringPointer 			; needs resetting ? we do this by zeroing this
.010721	d0 0d		bne $010730			bne 	_STANoReset 				; string pointer.
.010723	5a		phy				phy 								; reset the temp string pointer.
.010724	a0 0a 00	ldy #$000a			ldy 	#Block_HighMemoryPtr 		; this is at high memory - 256, so we can
.010727	b1 02		lda ($02),y			lda 	(DBaseAddress),y 			; create permanent strings if needed.
.010729	38		sec				sec
.01072a	e9 00 01	sbc #$0100			sbc 	#256
.01072d	85 16		sta $16				sta 	DTempStringPointer
.01072f	7a		ply				ply
.010730					_STANoReset:
.010730	68		pla				pla 								; get length.
.010731	29 ff 00	and #$00ff			and 	#$00FF 						; check it's a byte size
.010734	49 ff ff	eor #$ffff			eor 	#$FFFF 						; 2's complement add to temporary pointer.
.010737	18		clc				clc 								; this adds one, for the length.
.010738	65 16		adc $16				adc 	DTempStringPointer
.01073a	85 16		sta $16				sta 	DTempStringPointer
.01073c	48		pha				pha 								; save start address
.01073d	a9 00 00	lda #$0000			lda 	#$0000
.010740	e2 20		sep #$20			sep 	#$20 						; zero the length of this new string.
.010742	92 16		sta ($16)			sta		(DTempStringPointer)
.010744	c2 20		rep #$20			rep 	#$20
.010746	68		pla				pla 								; restore start address
.010747	85 18		sta $18				sta 	DStartTempString 			; start of new temporary string.
.010749	85 1a		sta $1a				sta 	DCurrentTempString 			; save current temporary string
.01074b	e6 1a		inc $1a				inc 	DCurrentTempString 			; step over length byte.
.01074d	60		rts				rts
.01074e					StringWriteCharacter:
.01074e	e2 20		sep #$20			sep 	#$20						; 8 bit mode
.010750	92 1a		sta ($1a)			sta 	(DCurrentTempString) 		; save character
.010752	b2 18		lda ($18)			lda 	(DStartTempString) 			; bump length
.010754	1a		inc a				inc 	a
.010755	92 18		sta ($18)			sta 	(DStartTempString)
.010757	c2 20		rep #$20			rep 	#$20						; 16 bit mode
.010759	e6 1a		inc $1a				inc 	DCurrentTempString 			; increment write pointer
.01075b	60		rts				rts
.01075c					StringCreateCopy:
.01075c	a8		tay				tay 								; put pointer to string in Y
.01075d	b9 00 00	lda $0000,y			lda 	$0000,y 					; read the first byte, the length.
.010760	29 ff 00	and #$00ff			and 	#$00FF 						; mask out the length byte.
.010763	f0 17		beq $01077c			beq 	_SCCExit 					; do nothing if length zero (the length byte is reset when allocated)
.010765	da		phx				phx 								; save X and put the character count in X
.010766	aa		tax				tax
.010767					_SCCCopy:
.010767	c8		iny				iny 								; advance and read (first time skips length)
.010768	e2 20		sep #$20			sep 	#$20 						; switch to 8 bit mode.
.01076a	b9 00 00	lda $0000,y			lda 	$0000,y
.01076d	92 1a		sta ($1a)			sta 	(DCurrentTempString) 		; write into target
.01076f	b2 18		lda ($18)			lda 	(DStartTempString)			; one more character
.010771	1a		inc a				inc 	a
.010772	92 18		sta ($18)			sta 	(DStartTempString)
.010774	c2 20		rep #$20			rep 	#$20 						; switch back to 16 bit mode
.010776	e6 1a		inc $1a				inc 	DCurrentTempString 			; bump target pointer
.010778	ca		dex				dex 								; do X times
.010779	d0 ec		bne $010767			bne 	_SCCCopy
.01077b	fa		plx				plx
.01077c					_SCCExit:
.01077c	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/utility/tokeniser.asm

.01077d					Tokenise:
.01077d	85 08		sta $08				sta 	DTemp1						; DTemp1 is the string to tokenise.
.01077f	84 0a		sty $0a				sty 	DTemp1+2
.010781	a9 00 01	lda #$0100			lda 	#Block_TokenBuffer 			; reset workspace pointer.
.010784	18		clc				clc
.010785	65 02		adc $02				adc 	DBaseAddress
.010787	85 0c		sta $0c				sta 	DTemp2 						; which is DTemp2
.010789	a0 ff ff	ldy #$ffff			ldy 	#-1 						; index
.01078c	a2 00 00	ldx #$0000			ldx 	#0 							; bit 0 1 when in quotes.
.01078f					_TOKCap:
.01078f	c8		iny				iny 								; go to next
.010790	b7 08		lda [$08],y			lda 	[DTemp1],y
.010792	29 ff 00	and #$00ff			and 	#$00FF
.010795	f0 22		beq $0107b9			beq 	_TOKEndCap
.010797	c9 22 00	cmp #$0022			cmp 	#'"'						; quote mark
.01079a	d0 01		bne $01079d			bne 	_TOKNotQuote
.01079c	e8		inx				inx  								; X counts them, bit 0 is yes/no.
.01079d					_TOKNotQuote:
.01079d	c9 61 00	cmp #$0061			cmp 	#"a"						; skip if L/C
.0107a0	90 ed		bcc $01078f			bcc 	_TOKCap
.0107a2	c9 7b 00	cmp #$007b			cmp 	#"z"+1
.0107a5	b0 e8		bcs $01078f			bcs 	_TOKCap
.0107a7	8a		txa				txa 								; check if in quotes
.0107a8	4a		lsr a				lsr 	a
.0107a9	b0 e4		bcs $01078f			bcs 	_TOKCap
.0107ab	b7 08		lda [$08],y			lda 	[DTemp1],y 					; capitalise
.0107ad	38		sec				sec
.0107ae	e9 20 00	sbc #$0020			sbc 	#32
.0107b1	e2 20		sep #$20			sep 	#$20
.0107b3	97 08		sta [$08],y			sta 	[DTemp1],y
.0107b5	c2 20		rep #$20			rep 	#$20
.0107b7	80 d6		bra $01078f			bra 	_TOKCap
.0107b9					_TOKEndCap:
.0107b9	c6 08		dec $08				dec 	DTemp1
.0107bb					_TOKMainNext:
.0107bb	e6 08		inc $08				inc 	DTemp1
.0107bd					_TOKMainLoop:
.0107bd	a7 08		lda [$08]			lda 	[DTemp1] 					; get first character
.0107bf	29 ff 00	and #$00ff			and 	#$00FF
.0107c2	c9 20 00	cmp #$0020			cmp 	#32
.0107c5	90 1d		bcc $0107e4			bcc 	_TOKExit 					; 0-31 exit.
.0107c7	f0 f2		beq $0107bb			beq 	_TOKMainNext 				; 32 (space) skip.
.0107c9	c9 22 00	cmp #$0022			cmp 	#34 						; if 34 (quote marks) do a string.
.0107cc	f0 1d		beq $0107eb			beq 	_TOKString
.0107ce	c9 30 00	cmp #$0030			cmp 	#48 						; 33-47 (not 34) check for punctuation.
.0107d1	90 1d		bcc $0107f0			bcc 	_TOKPunctuation
.0107d3	c9 3a 00	cmp #$003a			cmp 	#58 						; 48-57 tokenise a number
.0107d6	90 42		bcc $01081a			bcc 	_TOKNumber
.0107d8	c9 41 00	cmp #$0041			cmp 	#65 						; 58-64 more punctuation
.0107db	90 13		bcc $0107f0			bcc 	_TOKPunctuation
.0107dd	c9 5b 00	cmp #$005b			cmp 	#91 						; 65-90 identifier/keyword.
.0107e0	90 3d		bcc $01081f			bcc 	_TOKIdentifier
.0107e2	80 0c		bra $0107f0			bra 	_TOKPunctuation 			; 91-   punctuation.
.0107e4					_TOKExit:
.0107e4	a9 00 00	lda #$0000			lda 	#$0000
.0107e7	20 24 08	jsr $010824			jsr 	TOKWriteToken
.0107ea	60		rts				rts
.0107eb					_TOKString:
.0107eb	20 c2 08	jsr $0108c2			jsr 	TOKQuotedString
.0107ee	80 cd		bra $0107bd			bra 	_TOKMainLoop
.0107f0					_TOKPunctuation:
.0107f0	a2 02 00	ldx #$0002			ldx 	#2 							; try 2 character tokens.
.0107f3	20 29 09	jsr $010929			jsr 	TOKKeywordSearch
.0107f6	b0 1d		bcs $010815			bcs 	_TOKFoundPunctuation
.0107f8	a2 01 00	ldx #$0001			ldx 	#1 							; failed, try 1 character token.
.0107fb	20 29 09	jsr $010929			jsr 	TOKKeywordSearch
.0107fe	b0 15		bcs $010815			bcs 	_TOKFoundPunctuation
.010800	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>010803	43 61 6e 6e 6f 74 20 70				.text 	"Cannot parse line",$00 								; with this message
>01080b	61 72 73 65 20 6c 69 6e 65 00
.010815					_TOKFoundPunctuation:
.010815	20 24 08	jsr $010824			jsr 	TOKWriteToken 				; output the token and go round again.
.010818	80 a3		bra $0107bd			bra 	_TOKMainLoop
.01081a					_TOKNumber:
.01081a	20 43 08	jsr $010843			jsr 	TOKInteger 					; tokenise integer out of the token text.
.01081d	80 9e		bra $0107bd			bra 	_TOKMainLoop
.01081f					_TOKIdentifier:
.01081f	20 84 09	jsr $010984			jsr 	TOKIdentifier
.010822	80 99		bra $0107bd			bra 	_TOKMainLoop
.010824					TOKWriteToken:
.010824	92 0c		sta ($0c)			sta 	(DTemp2)					; write out
.010826	e6 0c		inc $0c				inc 	DTemp2 						; bump pointer
.010828	e6 0c		inc $0c				inc 	DTemp2
.01082a	a5 0c		lda $0c				lda 	DTemp2 						; overflow ??
.01082c	29 ff 00	and #$00ff			and 	#$00FF
.01082f	f0 01		beq $010832			beq 	_TOKWriteOverflow
.010831	60		rts				rts
.010832					_TOKWriteOverflow:
.010832	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>010835	4c 69 6e 65 20 74 6f 6f				.text 	"Line too long",$00 								; with this message
>01083d	20 6c 6f 6e 67 00
.010843					TOKInteger:
.010843	64 24		stz $24				stz 	DTemp3 						; we're going to build it in DTemp3
.010845	64 26		stz $26				stz 	DTemp3+2
.010847					_TOKINLoop:
.010847	a5 26		lda $26				lda 	DTemp3+2 					; push DTemp3+2 on the stack/A
.010849	48		pha				pha
.01084a	a5 24		lda $24				lda 	DTemp3
.01084c	06 24		asl $24				asl 	DTemp3 						; multiply it by 4
.01084e	26 26		rol $26				rol 	DTemp3+2
.010850	06 24		asl $24				asl 	DTemp3
.010852	26 26		rol $26				rol 	DTemp3+2
.010854	18		clc				clc
.010855	65 24		adc $24				adc 	DTemp3 						; add saved value, so it's x 5
.010857	85 24		sta $24				sta 	DTemp3
.010859	68		pla				pla
.01085a	65 26		adc $26				adc 	DTemp3+2
.01085c	85 26		sta $26				sta 	DTemp3+2
.01085e	06 24		asl $24				asl 	DTemp3 						; multiply it by 2, e.g. x 10
.010860	26 26		rol $26				rol 	DTemp3+2
.010862	a5 26		lda $26				lda 	DTemp3+2 					; we can't cope with that big an integer
.010864	29 00 f0	and #$f000			and 	#$F000						; can't directly tokenise MAXINT.
.010867	d0 44		bne $0108ad			bne 	_TOKINSize
.010869	a7 08		lda [$08]			lda 	[DTemp1]					; get the character value, we know this is 0-9
.01086b	29 0f 00	and #$000f			and 	#15
.01086e	18		clc				clc
.01086f	65 24		adc $24				adc 	DTemp3 						; add to the running count
.010871	85 24		sta $24				sta 	DTemp3
.010873	90 02		bcc $010877			bcc 	_TOKINNoCarry
.010875	e6 26		inc $26				inc 	DTemp3+2
.010877					_TOKINNoCarry:
.010877	e6 08		inc $08				inc 	DTemp1 						; look at next
.010879	a7 08		lda [$08]			lda 	[DTemp1] 					; loop back if 0..9
.01087b	29 ff 00	and #$00ff			and 	#$00FF
.01087e	c9 30 00	cmp #$0030			cmp 	#"0"
.010881	90 05		bcc $010888			bcc 	_TOKINGotInteger
.010883	c9 3a 00	cmp #$003a			cmp 	#"9"+1
.010886	90 bf		bcc $010847			bcc		_TOKINLoop
.010888					_TOKINGotInteger:
.010888	a5 24		lda $24				lda 	DTemp3 						; lower word
.01088a	29 ff 7f	and #$7fff			and 	#$7FFF 						; convert to a token
.01088d	18		clc				clc
.01088e	69 00 40	adc #$4000			adc 	#$4000
.010891	48		pha				pha 								; save it.
.010892	06 24		asl $24				asl 	DTemp3 						; shift bit15 into the high word
.010894	26 26		rol $26				rol 	DTemp3+2 					; which is the constant shift.
.010896	a5 26		lda $26				lda 	DTemp3+2 					; look at C/Shift
.010898	c9 00 10	cmp #$1000			cmp 	#$1000	 					; overflow ?
.01089b	b0 10		bcs $0108ad			bcs 	_TOKINSize 					; if so, we can't tokenise the number.
.01089d	29 ff 0f	and #$0fff			and 	#$0FFF 						; get bits / check zero
.0108a0	f0 06		beq $0108a8			beq 	_TOKINNoShift 				; don't need constant shift.
.0108a2	09 00 10	ora #$1000			ora 	#$1000	 					; make token $1xxx
.0108a5	20 24 08	jsr $010824			jsr 	TOKWriteToken
.0108a8					_TOKINNoShift:
.0108a8	68		pla				pla 								; get lower its token
.0108a9	20 24 08	jsr $010824			jsr 	TOKWriteToken 				; output it
.0108ac	60		rts				rts
.0108ad					_TOKINSize:
.0108ad	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>0108b0	49 6e 74 65 67 65 72 20				.text 	"Integer too large",$00 								; with this message
>0108b8	74 6f 6f 20 6c 61 72 67 65 00
.0108c2					TOKQuotedString:
.0108c2	e6 08		inc $08				inc 	DTemp1 						; skip over the initial quote
.0108c4	a5 08		lda $08				lda 	DTemp1 						; save start of string in DTemp4
.0108c6	85 32		sta $32				sta 	DTemp4
.0108c8	a5 0a		lda $0a				lda 	DTemp1+2
.0108ca	85 34		sta $34				sta 	DTemp4+2
.0108cc					_TOKQFindSize:
.0108cc	a7 08		lda [$08]			lda 	[DTemp1]					; get character, bump pointer
.0108ce	e6 08		inc $08				inc 	DTemp1
.0108d0	29 ff 00	and #$00ff			and 	#$00FF						; mask 8 bits
.0108d3	f0 3b		beq $010910			beq 	_TOQImbalance 				; end of line, and no quote found.
.0108d5	c9 22 00	cmp #$0022			cmp 	#34
.0108d8	d0 f2		bne $0108cc			bne 	_TOKQFindSize 				; at end DTemp1 points after quote.
.0108da	a5 08		lda $08				lda 	DTemp1 						; work out length, save in DTemp3+2
.0108dc	38		sec				sec
.0108dd	e5 32		sbc $32				sbc 	DTemp4
.0108df	3a		dec a				dec 	a 							; one less character for closing quote
.0108e0	85 26		sta $26				sta 	DTemp3+2
.0108e2	18		clc				clc
.0108e3	69 04 00	adc #$0004			adc 	#2+1+1 						; two for header, 1 for size, 1 for round up.
.0108e6	29 fe ff	and #$fffe			and 	#$FFFE 						; force to even gives token.
.0108e9	20 24 08	jsr $010824			jsr 	TOKWriteToken
.0108ec	a5 26		lda $26				lda 	DTemp3+2 					; this is the count.
.0108ee	20 24 08	jsr $010824			jsr 	TOKWriteToken 				; effectively a byte-write.
.0108f1	c6 0c		dec $0c				dec 	DTemp2
.0108f3	a6 26		ldx $26				ldx 	DTemp3+2 					; this the count.
.0108f5	f0 0f		beq $010906			beq		_TOKQWriteEnd 				; if zero, no need to write anything
.0108f7					_TOKQWriteString:
.0108f7	a7 32		lda [$32]			lda 	[DTemp4] 					; read character from start
.0108f9	29 ff 00	and #$00ff			and 	#$00FF
.0108fc	20 24 08	jsr $010824			jsr 	TOKWriteToken 				; effectively a byte-write.
.0108ff	c6 0c		dec $0c				dec 	DTemp2
.010901	e6 32		inc $32				inc 	DTemp4 						; advance character
.010903	ca		dex				dex 								; do X times
.010904	d0 f1		bne $0108f7			bne 	_TOKQWriteString
.010906					_TOKQWriteEnd:
.010906	a5 0c		lda $0c				lda 	DTemp2 						; are we on an even byte.
.010908	29 01 00	and #$0001			and 	#1
.01090b	f0 02		beq $01090f			beq 	_TOKQExit
.01090d	e6 0c		inc $0c				inc 	DTemp2 						; we wrote values with the high byte 0, so just correct
.01090f					_TOKQExit:
.01090f	60		rts				rts
.010910					_TOQImbalance:
.010910	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>010913	4d 69 73 73 69 6e 67 20				.text 	"Missing closing quote",$00 								; with this message
>01091b	63 6c 6f 73 69 6e 67 20 71 75 6f 74 65 00
.010929					TOKKeywordSearch:
.010929	86 32		stx $32				stx 	DTemp4 						; save length in DTemp4
.01092b	a9 01 00	lda #$0001			lda 	#1 							; token number in DTemp4+2
.01092e	85 34		sta $34				sta 	DTemp4+2
.010930	a2 00 00	ldx #$0000			ldx 	#0
.010933					_TOKScan:
.010933	bf 9e 00 01	lda $01009e,x			lda 	TokenText,x 				; read the first byte
.010937	29 0f 00	and #$000f			and 	#$000F 						; and the Nibble which is skip to the next.
.01093a	f0 46		beq $010982			beq 	_TOKFail 					; if zero then we have failed.
.01093c	3a		dec a				dec 	a 							; -1 gives the length.
.01093d	c5 32		cmp $32				cmp 	DTemp4 						; is this token that length.
.01093f	d0 2f		bne $010970			bne 	_TOKNext 					; no, then skip to next token.
.010941	da		phx				phx 								; save X
.010942	a0 00 00	ldy #$0000			ldy 	#0 							; start comparing
.010945					_TOKCompare:
.010945	b7 08		lda [$08],y			lda 	[DTemp1],y 					; get character
.010947	5f 9f 00 01	eor $01009f,x			eor 	TokenText+1,x
.01094b	29 ff 00	and #$00ff			and 	#$00FF
.01094e	d0 1f		bne $01096f			bne 	_TOKPopNext 				; if different, pop and goto next.
.010950	e8		inx				inx 								; bump X and Y.
.010951	c8		iny				iny
.010952	c4 32		cpy $32				cpy 	DTemp4 						; matched whole length
.010954	d0 ef		bne $010945			bne 	_TOKCompare
.010956	98		tya				tya 								; add length to the text pointer
.010957	18		clc				clc
.010958	65 08		adc $08				adc 	DTemp1
.01095a	85 08		sta $08				sta 	DTemp1
.01095c	fa		plx				plx 								; restore X.
.01095d	bf 9e 00 01	lda $01009e,x			lda 	TokenText,x 				; get the type/token bit.
.010961	29 f0 00	and #$00f0			and 	#$00F0 						; get the type out
.010964	4a		lsr a				lsr 	a 							; shift into bit 1, then swap into bit 9
.010965	4a		lsr a				lsr		a
.010966	4a		lsr a				lsr 	a
.010967	eb		xba				xba
.010968	05 34		ora $34				ora 	DTemp4+2 					; OR in keyword number
.01096a	09 00 20	ora #$2000			ora 	#$2000 						; set upper bits
.01096d	38		sec				sec
.01096e	60		rts				rts
.01096f					_TOKPopNext:
.01096f	fa		plx				plx 								; restore X.
.010970					_TOKNext:
.010970	bf 9e 00 01	lda $01009e,x			lda 	TokenText,x 				; get the token skip again.
.010974	29 0f 00	and #$000f			and 	#$000F
.010977	85 14		sta $14				sta 	DSignCount 					; save it in DTemp3 so we can add it to X
.010979	8a		txa				txa
.01097a	18		clc				clc
.01097b	65 14		adc $14				adc 	DSignCount
.01097d	aa		tax				tax
.01097e	e6 34		inc $34				inc 	DTemp4+2 					; bump keyword index
.010980	80 b1		bra $010933			bra 	_TOKScan
.010982					_TOKFail:
.010982	18		clc				clc
.010983	60		rts				rts
.010984					TOKIdentifier:
.010984	a5 08		lda $08				lda 	DTemp1 						; save start of identifier in DTemp3
.010986	85 24		sta $24				sta 	DTemp3
.010988					_TOKIFindLength:
.010988	e6 08		inc $08				inc 	DTemp1						; we know the first one is A-Z
.01098a	a7 08		lda [$08]			lda 	[DTemp1]
.01098c	29 ff 00	and #$00ff			and 	#$00FF
.01098f	20 2f 0a	jsr $010a2f			jsr 	TOKIsIdentifierCharacter
.010992	b0 f4		bcs $010988			bcs 	_TOKIFindLength
.010994	a5 08		lda $08				lda 	DTemp1 						; calculate base identifier length.
.010996	38		sec				sec
.010997	e5 24		sbc $24				sbc 	DTemp3 						; i.e. the # characters in the actual name
.010999	85 36		sta $36				sta 	DTemp5
.01099b	85 38		sta $38				sta 	DTemp5+2 					; this is the name length including $(
.01099d	a9 00 c0	lda #$c000			lda 	#$C000						; this is the upper bits - 11<type><arr> 1xxx
.0109a0	85 26		sta $26				sta 	DTemp3+2 					; used for building an identifier.
.0109a2	a7 08		lda [$08]			lda 	[DTemp1]					; string follows
.0109a4	29 ff 00	and #$00ff			and 	#$00FF
.0109a7	c9 24 00	cmp #$0024			cmp 	#"$"
.0109aa	d0 0b		bne $0109b7			bne 	_TOKINotString
.0109ac	e6 08		inc $08				inc 	DTemp1 						; skip $
.0109ae	e6 38		inc $38				inc 	DTemp5+2 					; token length.
.0109b0	a5 26		lda $26				lda 	DTemp3+2 					; set type mask bit
.0109b2	09 00 20	ora #$2000			ora 	#IDTypeMask
.0109b5	85 26		sta $26				sta 	DTemp3+2
.0109b7					_TOKINotString:
.0109b7	a7 08		lda [$08]			lda 	[DTemp1]					; string follows
.0109b9	29 ff 00	and #$00ff			and 	#$00FF
.0109bc	c9 28 00	cmp #$0028			cmp 	#"("
.0109bf	d0 0b		bne $0109cc			bne 	_TOKINotArray
.0109c1	e6 08		inc $08				inc 	DTemp1 						; skip (
.0109c3	e6 38		inc $38				inc 	DTemp5+2 					; token length.
.0109c5	a5 26		lda $26				lda 	DTemp3+2 					; set type mask bit
.0109c7	09 00 10	ora #$1000			ora 	#IDArrayMask
.0109ca	85 26		sta $26				sta 	DTemp3+2
.0109cc					_TOKINotArray:
.0109cc	a5 24		lda $24				lda 	DTemp3 						; reset the scan position
.0109ce	85 08		sta $08				sta 	DTemp1
.0109d0	a6 38		ldx $38				ldx 	DTemp5+2 					; so see if it is a token first.
.0109d2	20 29 09	jsr $010929			jsr 	TOKKeywordSearch
.0109d5	90 04		bcc $0109db			bcc 	_TOKIIdentifier 			; if CC it's an identifier.
.0109d7	20 24 08	jsr $010824			jsr 	TOKWriteToken 				; if CS write token and exit.
.0109da	60		rts				rts
.0109db					_TOKIIdentifier:
.0109db	a7 08		lda [$08]			lda 	[DTemp1]					; get the first character
.0109dd	e6 08		inc $08				inc 	DTemp1
.0109df	20 1b 0a	jsr $010a1b			jsr		_TOKIToConstant 			; convert to range 0-35
.0109e2	05 26		ora $26				ora 	DTemp3+2 					; put in the upper bits.
.0109e4	c6 36		dec $36				dec 	DTemp5 						; decrement the identifier length
.0109e6	f0 1d		beq $010a05			beq 	_TOKINoSecond
.0109e8	48		pha				pha 								; save current on stack.
.0109e9	a7 08		lda [$08]			lda 	[DTemp1]					; get the next character
.0109eb	e6 08		inc $08				inc 	DTemp1
.0109ed	20 1b 0a	jsr $010a1b			jsr		_TOKIToConstant 			; convert to range 0-35
.0109f0	85 14		sta $14				sta 	DSignCount 					; save it.
.0109f2	0a		asl a				asl 	a 							; x 4
.0109f3	0a		asl a				asl 	a
.0109f4	65 14		adc $14				adc 	DSignCount 					; x 5
.0109f6	0a		asl a				asl 	a 							; x 10
.0109f7	65 14		adc $14				adc 	DSignCount 					; x 11
.0109f9	0a		asl a				asl 	a 							; x 22
.0109fa	0a		asl a				asl 	a 							; x 44
.0109fb	65 14		adc $14				adc 	DSignCount 					; x 45
.0109fd	85 14		sta $14				sta 	DSignCount
.0109ff	68		pla				pla 								; get old token and add x 45
.010a00	18		clc				clc
.010a01	65 14		adc $14				adc 	DSignCount
.010a03	c6 36		dec $36				dec 	DTemp5 						; decrement the count.
.010a05					_TOKINoSecond:
.010a05	a6 36		ldx $36				ldx 	DTemp5 						; is the count now zero.
.010a07	f0 03		beq $010a0c			beq 	_TOKINotLast				; if yes
.010a09	09 00 08	ora #$0800			ora 	#IDContMask 				; set the continuation bit.
.010a0c					_TOKINotLast:
.010a0c	20 24 08	jsr $010824			jsr 	TOKWriteToken 				; output the token
.010a0f	a5 36		lda $36				lda 	DTemp5						; loop back if more to do.
.010a11	d0 c8		bne $0109db			bne 	_TOKIIdentifier
.010a13					_TOKIOut:
.010a13	a5 24		lda $24				lda 	DTemp3 						; get original start position
.010a15	18		clc				clc
.010a16	65 38		adc $38				adc 	DTemp5+2					; add overall length
.010a18	85 08		sta $08				sta 	DTemp1 						; this is the end position
.010a1a	60		rts				rts
.010a1b					_TOKIToConstant:
.010a1b	29 ff 00	and #$00ff			and 	#$00FF 						; byte value
.010a1e	c9 41 00	cmp #$0041			cmp 	#65
.010a21	90 04		bcc $010a27			bcc 	_TOKITInteger
.010a23	29 1f 00	and #$001f			and 	#31 						; it's A-Z, so return 1-26
.010a26	60		rts				rts
.010a27					_TOKITInteger:
.010a27	29 0f 00	and #$000f			and 	#15 						; its 0-9 which are 27-36
.010a2a	18		clc				clc
.010a2b	69 1b 00	adc #$001b			adc 	#27
.010a2e	60		rts				rts
.010a2f					TOKIsIdentifierCharacter:
.010a2f	c9 30 00	cmp #$0030			cmp 	#"0"
.010a32	90 0f		bcc $010a43			bcc 	_TOKIIFail
.010a34	c9 3a 00	cmp #$003a			cmp 	#"9"+1
.010a37	90 0c		bcc $010a45			bcc 	_TOKIIOk
.010a39	c9 41 00	cmp #$0041			cmp 	#"A"
.010a3c	90 05		bcc $010a43			bcc 	_TOKIIFail
.010a3e	c9 5b 00	cmp #$005b			cmp 	#"Z"+1
.010a41	90 02		bcc $010a45			bcc 	_TOKIIOk
.010a43					_TOKIIFail:
.010a43	18		clc				clc
.010a44	60		rts				rts
.010a45					_TOKIIOk:
.010a45	38		sec				sec
.010a46	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/binary/arithmetic.asm

.010a47					Binary_Add:
.010a47	b5 04		lda $04,x		lda 	EXSPrecType+0,x 					; check both same type
.010a49	55 0a		eor $0a,x		eor 	EXSPrecType+EXSNext,x
.010a4b	30 12		bmi $010a5f		bmi 	_BATypeError
.010a4d	b5 04		lda $04,x		lda 	EXSPrecType+0,x 					; see if they are strings
.010a4f	30 3f		bmi $010a90		bmi 	_BAConcatenateString 				; if so , do the concatenation code.
.010a51	18		clc			clc 										; add the results
.010a52	b5 00		lda $00,x		lda		EXSValueL+0,x
.010a54	75 06		adc $06,x		adc 	EXSValueL+EXSNext,x
.010a56	95 00		sta $00,x		sta 	EXSValueL+0,x
.010a58	b5 02		lda $02,x		lda		EXSValueH+0,x
.010a5a	75 08		adc $08,x		adc 	EXSValueH+EXSNext,x
.010a5c	95 02		sta $02,x		sta 	EXSValueH+0,x
.010a5e	60		rts			rts
.010a5f					_BATypeError:
.010a5f	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>010a62	2b 20 6f 70 65 72 61 74				.text 	"+ operator can't mix types",$00 								; with this message
>010a6a	6f 72 20 63 61 6e 27 74 20 6d 69 78 20 74 79 70
>010a7a	65 73 00
.010a7d					_BALengthError:
.010a7d	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>010a80	53 74 72 69 6e 67 20 74				.text 	"String too long",$00 								; with this message
>010a88	6f 6f 20 6c 6f 6e 67 00
.010a90					_BAConcatenateString:
.010a90	b5 00		lda $00,x		lda 	EXSValueL+0,x 						; save pointers in DTemp1/DTemp2
.010a92	85 08		sta $08			sta 	DTemp1 								; they are the first and second strings.
.010a94	b5 06		lda $06,x		lda 	EXSValueL+EXSNext,x
.010a96	85 0c		sta $0c			sta 	DTemp2
.010a98	e2 20		sep #$20		sep 	#$20								; switch into byte mode.
.010a9a	18		clc			clc 										; work out the total length
.010a9b	b2 08		lda ($08)		lda 	(DTemp1)
.010a9d	72 0c		adc ($0c)		adc 	(DTemp2)
.010a9f	b0 14		bcs $010ab5		bcs 	_BAConcatLengthError 				; string is too long.
.010aa1	c2 20		rep #$20		rep 	#$20 								; back to 16 bit mode.
.010aa3	20 1e 07	jsr $01071e		jsr 	StringTempAllocate 					; allocate string of that size in temp memory.
.010aa6	95 00		sta $00,x		sta 	EXSValueL+0,x 						; update the return value to that address.
.010aa8	74 02		stz $02,x		stz 	EXSValueH+0,x
.010aaa	a5 08		lda $08			lda 	DTemp1 								; copy first string there.
.010aac	20 5c 07	jsr $01075c		jsr 	StringCreateCopy
.010aaf	a5 0c		lda $0c			lda 	DTemp2 								; copy second string there.
.010ab1	20 5c 07	jsr $01075c		jsr 	StringCreateCopy
.010ab4	60		rts			rts
.010ab5					_BAConcatLengthError:
.010ab5	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>010ab8	53 74 72 69 6e 67 20 74				.text 	"String too long",$00 								; with this message
>010ac0	6f 6f 20 6c 6f 6e 67 00
.010ac8					Binary_Subtract:
.010ac8	20 09 06	jsr $010609		jsr 	CheckBothNumeric 					; check both values are numeric
.010acb	38		sec			sec
.010acc	b5 00		lda $00,x		lda		EXSValueL+0,x
.010ace	f5 06		sbc $06,x		sbc 	EXSValueL+EXSNext,x
.010ad0	95 00		sta $00,x		sta 	EXSValueL+0,x
.010ad2	b5 02		lda $02,x		lda		EXSValueH+0,x
.010ad4	f5 08		sbc $08,x		sbc 	EXSValueH+EXSNext,x
.010ad6	95 02		sta $02,x		sta 	EXSValueH+0,x
.010ad8	60		rts			rts
.010ad9					Binary_ShiftRight:
.010ad9	20 09 06	jsr $010609		jsr 	CheckBothNumeric 					; check both values are numeric
.010adc	b5 06		lda $06,x		lda 	EXSValueL+EXSNext,x
.010ade	29 3f 00	and #$003f		and 	#63
.010ae1	f0 07		beq $010aea		beq		_Binary_SRExit
.010ae3					_Binary_SRLoop:
.010ae3	56 02		lsr $02,x		lsr 	EXSValueH+0,x
.010ae5	76 00		ror $00,x		ror 	EXSValueL+0,x
.010ae7	3a		dec a			dec 	a
.010ae8	d0 f9		bne $010ae3		bne 	_Binary_SRLoop
.010aea					_Binary_SRExit:
.010aea	60		rts			rts
.010aeb					Binary_ShiftLeft:
.010aeb	20 09 06	jsr $010609		jsr 	CheckBothNumeric 					; check both values are numeric
.010aee	b5 06		lda $06,x		lda 	EXSValueL+EXSNext,x
.010af0	29 3f 00	and #$003f		and 	#63
.010af3	f0 07		beq $010afc		beq		_Binary_SLExit
.010af5					_Binary_SLLoop:
.010af5	16 00		asl $00,x		asl 	EXSValueL+0,x
.010af7	36 02		rol $02,x		rol 	EXSValueH+0,x
.010af9	3a		dec a			dec 	a
.010afa	d0 f9		bne $010af5		bne 	_Binary_SLLoop
.010afc					_Binary_SLExit:
.010afc	60		rts			rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/binary/bitwise.asm

.010afd					Binary_And:
.010afd	20 09 06	jsr $010609		jsr 	CheckBothNumeric 					; check both values are numeric
.010b00	b5 00		lda $00,x		lda		EXSValueL+0,x
.010b02	35 06		and $06,x		and 	EXSValueL+EXSNext,x
.010b04	95 00		sta $00,x		sta 	EXSValueL+0,x
.010b06	b5 02		lda $02,x		lda		EXSValueH+0,x
.010b08	35 08		and $08,x		and 	EXSValueH+EXSNext,x
.010b0a	95 02		sta $02,x		sta 	EXSValueH+0,x
.010b0c	60		rts			rts
.010b0d					Binary_Or:
.010b0d	20 09 06	jsr $010609		jsr 	CheckBothNumeric 					; check both values are numeric
.010b10	b5 00		lda $00,x		lda		EXSValueL+0,x
.010b12	15 06		ora $06,x		ora 	EXSValueL+EXSNext,x
.010b14	95 00		sta $00,x		sta 	EXSValueL+0,x
.010b16	b5 02		lda $02,x		lda		EXSValueH+0,x
.010b18	15 08		ora $08,x		ora 	EXSValueH+EXSNext,x
.010b1a	95 02		sta $02,x		sta 	EXSValueH+0,x
.010b1c	60		rts			rts
.010b1d					Binary_Xor:
.010b1d	20 09 06	jsr $010609		jsr 	CheckBothNumeric 					; check both values are numeric
.010b20	b5 00		lda $00,x		lda		EXSValueL+0,x
.010b22	55 06		eor $06,x		eor 	EXSValueL+EXSNext,x
.010b24	95 00		sta $00,x		sta 	EXSValueL+0,x
.010b26	b5 02		lda $02,x		lda		EXSValueH+0,x
.010b28	55 08		eor $08,x		eor 	EXSValueH+EXSNext,x
.010b2a	95 02		sta $02,x		sta 	EXSValueH+0,x
.010b2c	60		rts			rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/binary/comparison.asm

.010b2d					Binary_Equals:
.010b2d	20 e6 0b	jsr $010be6		jsr 	CompareTypeCheck 				; which types are we comparing ?
.010b30	b0 0e		bcs $010b40		bcs 	_BEString
.010b32	b5 00		lda $00,x		lda 	EXSValueL,x 					; numeric comparison
.010b34	d5 06		cmp $06,x		cmp 	EXSValueL+EXSNext,x
.010b36	d0 4f		bne $010b87		bne 	Compare_Fail
.010b38	b5 02		lda $02,x		lda 	EXSValueH,x
.010b3a	d5 08		cmp $08,x		cmp 	EXSValueH+EXSNext,x
.010b3c	d0 49		bne $010b87		bne 	Compare_Fail
.010b3e	80 3f		bra $010b7f		bra 	Compare_Succeed
.010b40					_BEString:
.010b40	09 00 00	ora #$0000		ora 	#$0000
.010b43	f0 3a		beq $010b7f		beq 	Compare_Succeed
.010b45	80 40		bra $010b87		bra 	Compare_Fail
.010b47					Binary_NotEquals:
.010b47	20 e6 0b	jsr $010be6		jsr 	CompareTypeCheck 				; which types are we comparing ?
.010b4a	b0 0e		bcs $010b5a		bcs 	_BNEString
.010b4c	b5 00		lda $00,x		lda 	EXSValueL,x 					; numeric comparison
.010b4e	d5 06		cmp $06,x		cmp 	EXSValueL+EXSNext,x
.010b50	d0 2d		bne $010b7f		bne 	Compare_Succeed
.010b52	b5 02		lda $02,x		lda 	EXSValueH,x
.010b54	d5 08		cmp $08,x		cmp 	EXSValueH+EXSNext,x
.010b56	d0 27		bne $010b7f		bne 	Compare_Succeed
.010b58	80 2d		bra $010b87		bra 	Compare_Fail
.010b5a					_BNEString:
.010b5a	09 00 00	ora #$0000		ora 	#$0000
.010b5d	d0 20		bne $010b7f		bne 	Compare_Succeed
.010b5f	80 26		bra $010b87		bra 	Compare_Fail
.010b61					Binary_Less:
.010b61	20 e6 0b	jsr $010be6		jsr 	CompareTypeCheck 				; which types are we comparing ?
.010b64	b0 12		bcs $010b78		bcs 	_BLString
.010b66	38		sec			sec
.010b67	b5 00		lda $00,x		lda 	EXSValueL,x 					; signed numeric <
.010b69	f5 06		sbc $06,x		sbc 	EXSValueL+EXSNext,x
.010b6b	b5 02		lda $02,x		lda 	EXSValueH,x
.010b6d	f5 08		sbc $08,x		sbc 	EXSValueH+EXSNext,x
.010b6f	50 03		bvc $010b74		bvc 	*+5
.010b71	49 00 80	eor #$8000		eor 	#$8000
.010b74	30 09		bmi $010b7f		bmi 	Compare_Succeed
.010b76	80 0f		bra $010b87		bra 	Compare_Fail
.010b78					_BLString:
.010b78	c9 ff ff	cmp #$ffff		cmp 	#$FFFF 							; string
.010b7b	f0 02		beq $010b7f		beq 	Compare_Succeed
.010b7d	80 08		bra $010b87		bra 	Compare_Fail
.010b7f					Compare_Succeed:
.010b7f	a9 ff ff	lda #$ffff		lda 	#$FFFF
.010b82	95 00		sta $00,x		sta 	EXSValueL,x
.010b84	95 02		sta $02,x		sta 	EXSValueH,x
.010b86	60		rts			rts
.010b87					Compare_Fail:
.010b87	74 00		stz $00,x		stz 	EXSValueL,x
.010b89	74 02		stz $02,x		stz 	EXSValueH,x
.010b8b	60		rts			rts
.010b8c					Binary_GreaterEqual:
.010b8c	20 e6 0b	jsr $010be6		jsr 	CompareTypeCheck 				; which types are we comparing ?
.010b8f	b0 12		bcs $010ba3		bcs 	_BGEString
.010b91	38		sec			sec
.010b92	b5 00		lda $00,x		lda 	EXSValueL,x 					; numeric >= signed
.010b94	f5 06		sbc $06,x		sbc 	EXSValueL+EXSNext,x
.010b96	b5 02		lda $02,x		lda 	EXSValueH,x
.010b98	f5 08		sbc $08,x		sbc 	EXSValueH+EXSNext,x
.010b9a	50 03		bvc $010b9f		bvc 	*+5
.010b9c	49 00 80	eor #$8000		eor 	#$8000
.010b9f	10 de		bpl $010b7f		bpl 	Compare_Succeed
.010ba1	80 e4		bra $010b87		bra 	Compare_Fail
.010ba3					_BGEString:
.010ba3	09 00 00	ora #$0000		ora 	#$0000
.010ba6	10 d7		bpl $010b7f		bpl 	Compare_Succeed
.010ba8	80 dd		bra $010b87		bra 	Compare_Fail
.010baa					Binary_LessEqual:
.010baa	20 e6 0b	jsr $010be6		jsr 	CompareTypeCheck 				; which types are we comparing ?
.010bad	b0 12		bcs $010bc1		bcs 	_BLEString
.010baf	18		clc			clc 									; numeric <= signed
.010bb0	b5 00		lda $00,x		lda 	EXSValueL,x
.010bb2	f5 06		sbc $06,x		sbc 	EXSValueL+EXSNext,x
.010bb4	b5 02		lda $02,x		lda 	EXSValueH,x
.010bb6	f5 08		sbc $08,x		sbc 	EXSValueH+EXSNext,x
.010bb8	50 03		bvc $010bbd		bvc 	*+5
.010bba	49 00 80	eor #$8000		eor 	#$8000
.010bbd	30 c0		bmi $010b7f		bmi 	Compare_Succeed
.010bbf	80 c6		bra $010b87		bra 	Compare_Fail
.010bc1					_BLEString:
.010bc1	c9 01 00	cmp #$0001		cmp 	#$0001 							; string
.010bc4	d0 b9		bne $010b7f		bne 	Compare_Succeed
.010bc6	80 bf		bra $010b87		bra 	Compare_Fail
.010bc8					Binary_Greater:
.010bc8	20 e6 0b	jsr $010be6		jsr 	CompareTypeCheck 				; which types are we comparing ?
.010bcb	b0 12		bcs $010bdf		bcs 	_BGString
.010bcd	18		clc			clc 									; numeric > signed
.010bce	b5 00		lda $00,x		lda 	EXSValueL,x
.010bd0	f5 06		sbc $06,x		sbc 	EXSValueL+EXSNext,x
.010bd2	b5 02		lda $02,x		lda 	EXSValueH,x
.010bd4	f5 08		sbc $08,x		sbc 	EXSValueH+EXSNext,x
.010bd6	50 03		bvc $010bdb		bvc 	*+5
.010bd8	49 00 80	eor #$8000		eor 	#$8000
.010bdb	10 a2		bpl $010b7f		bpl 	Compare_Succeed
.010bdd	80 a8		bra $010b87		bra 	Compare_Fail
.010bdf					_BGString:
.010bdf	c9 01 00	cmp #$0001		cmp 	#$0001
.010be2	f0 9b		beq $010b7f		beq 	Compare_Succeed
.010be4	80 a1		bra $010b87		bra 	Compare_Fail
.010be6					CompareTypeCheck:
.010be6	b5 04		lda $04,x		lda 	EXSPrecType+0,x 				; xor the type bits (bit 15)
.010be8	55 0a		eor $0a,x		eor 	EXSPrecType+EXSNext,x
.010bea	30 06		bmi $010bf2		bmi 	_CTCFail 						; if different types cannot be compared, must be the same !
.010bec	b5 04		lda $04,x		lda 	EXSPrecType+0,x 				; get the type they (both) are.
.010bee	30 1c		bmi $010c0c		bmi 	_CTCStringCompare 				; if strings, do a string comparison.
.010bf0	18		clc			clc 									; if numbers return with carry clear and calculate it.
.010bf1	60		rts			rts
.010bf2					_CTCFail:
.010bf2	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>010bf5	43 6f 6d 70 61 72 69 73				.text 	"Comparison mixed types",$00 								; with this message
>010bfd	6f 6e 20 6d 69 78 65 64 20 74 79 70 65 73 00
.010c0c					_CTCStringCompare:
.010c0c	20 29 06	jsr $010629		jsr 	ResetTypeInteger 				; two strings return integer not string.
.010c0f	b5 00		lda $00,x		lda 	EXSValueL+0,x 					; copy address of string 1 -> DTemp1
.010c11	85 08		sta $08			sta 	DTemp1
.010c13	b5 06		lda $06,x		lda 	EXSValueL+EXSNext,x 					; copy address of string 2 -> DTemp2
.010c15	85 0c		sta $0c			sta 	DTemp2
.010c17	a9 00 00	lda #$0000		lda 	#$0000 							; clear AY
.010c1a	a8		tay			tay
.010c1b	e2 20		sep #$20		sep 	#$20 							; 8 bit data mode.
.010c1d	b2 08		lda ($08)		lda 	(DTemp1) 						; get the length of the shorter string
.010c1f	d2 0c		cmp ($0c)		cmp 	(DTemp2)
.010c21	90 02		bcc $010c25		bcc 	_CTCSmallest
.010c23	b2 0c		lda ($0c)		lda 	(DTemp2)
.010c25					_CTCSmallest:
.010c25	85 14		sta $14			sta		DSignCount 						; use this as a comparison count. Check to see they match fires
.010c27					_CTCCompare:
.010c27	c8		iny			iny 									; look at next character (done first, first char is size)
.010c28	c6 14		dec $14			dec 	DSignCount 						; decrement counter
.010c2a	30 16		bmi $010c42		bmi 	_CTCEqualSoFar 					; if -ve the strings are the same as far as the shortest.
.010c2c	b1 08		lda ($08),y		lda 	(DTemp1),y						; compare s1[y] - s2[y]
.010c2e	d1 0c		cmp ($0c),y		cmp 	(DTemp2),y
.010c30	f0 f5		beq $010c27		beq 	_CTCCompare 					; if zero, try the next character.
.010c32	b0 07		bcs $010c3b		bcs 	_CTCGreater 					; Strings are different in their common length. Return -ve then s2 > s1
.010c34					_CTCLess:
.010c34	c2 20		rep #$20		rep 	#$20
.010c36	a9 ff ff	lda #$ffff		lda 	#$FFFF
.010c39	80 14		bra $010c4f		bra 	_CTCExit
.010c3b					_CTCGreater:
.010c3b	c2 20		rep #$20		rep 	#$20
.010c3d	a9 01 00	lda #$0001		lda 	#$0001 							; return +1 and CS
.010c40	80 0d		bra $010c4f		bra 	_CTCExit
.010c42					_CTCEqualSoFar:
.010c42	b2 08		lda ($08)		lda 	(DTemp1) 						; if len(s1) < len(s2) then s1 is the smaller
.010c44	d2 0c		cmp ($0c)		cmp 	(DTemp2)
.010c46	90 ec		bcc $010c34		bcc 	_CTCLess
.010c48	d0 f1		bne $010c3b		bne 	_CTCGreater 					; if len(s1) > len(s2) then s2 is the smaller
.010c4a	c2 20		rep #$20		rep 	#$20 	 						; if lengths are the same, then the strings are the same.
.010c4c	a9 00 00	lda #$0000		lda 	#$0000
.010c4f					_CTCExit:
.010c4f	38		sec			sec 									; return with CS indicating string comparison.
.010c50	60		rts			rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/binary/divide.asm

.010c51					Binary_Divide:
.010c51	20 09 06	jsr $010609		jsr 	CheckBothNumeric 					; check both values are numeric
.010c54	b5 06		lda $06,x		lda 	EXSValueL+EXSNext,x						; check for division by zero
.010c56	15 08		ora $08,x		ora	 	EXSValueH+EXSNext,x
.010c58	d0 14		bne $010c6e		bne 	_BinaryDivide_Ok
.010c5a	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>010c5d	44 69 76 69 73 69 6f 6e				.text 	"Division by zero",$00 								; with this message
>010c65	20 62 79 20 7a 65 72 6f 00
.010c6e					_BinaryDivide_Ok:
.010c6e	64 08		stz $08			stz 	DTemp1+0							; clear remainder (DTemp)
.010c70	64 0a		stz $0a			stz 	DTemp1+2
.010c72	64 14		stz $14			stz 	DSignCount  						; zero sign count.
.010c74	5a		phy			phy 										; save Y (bit counter)
.010c75	b5 08		lda $08,x		lda 	EXSValueH+EXSNext,x 				; check sign of H+2 (right)
.010c77	10 0b		bpl $010c84		bpl 	_BinaryDivide_RightDone
.010c79	da		phx			phx
.010c7a	e8		inx			inx
.010c7b	e8		inx			inx
.010c7c	e8		inx			inx
.010c7d	e8		inx			inx
.010c7e	e8		inx			inx
.010c7f	e8		inx			inx
.010c80	20 ba 0c	jsr $010cba		jsr 	Binary_DivNegate
.010c83	fa		plx			plx
.010c84					_BinaryDivide_RightDone:
.010c84	b5 02		lda $02,x		lda 	EXSValueH+0,x 				 		; check sign of H+0 (left)
.010c86	10 03		bpl $010c8b		bpl 	_BinaryDivide_LeftDone
.010c88	20 ba 0c	jsr $010cba		jsr 	Binary_DivNegate
.010c8b					_BinaryDivide_LeftDone:
.010c8b	a0 20 00	ldy #$0020		ldy 	#32 								; number to do.
.010c8e					_BinaryDivide_Loop:
.010c8e	16 00		asl $00,x		asl 	EXSValueL+0,x 						; shift Q into carry
.010c90	36 02		rol $02,x		rol 	EXSValueH+0,x
.010c92	26 08		rol $08			rol 	DTemp1+0 							; rotate A left, with carry in
.010c94	26 0a		rol $0a			rol 	DTemp1+2
.010c96	38		sec			sec											; calculate A-M
.010c97	a5 08		lda $08			lda 	DTemp1+0 							; but don't save it.
.010c99	f5 06		sbc $06,x		sbc 	EXSValueL+EXSNext,x
.010c9b	85 0c		sta $0c			sta 	DTemp2
.010c9d	a5 0a		lda $0a			lda 	DTemp1+2
.010c9f	f5 08		sbc $08,x		sbc 	EXSValueH+EXSNext,x
.010ca1	90 08		bcc $010cab		bcc 	_Binary_NoSubract 					; if A < M skip this
.010ca3	85 0a		sta $0a			sta 	DTemp1+2 							; save the calculated value.
.010ca5	a5 0c		lda $0c			lda 	DTemp2
.010ca7	85 08		sta $08			sta 	DTemp1+0
.010ca9	f6 00		inc $00,x		inc 	EXSValueL+0,x						; set bit 0 of Q
.010cab					_Binary_NoSubract:
.010cab	88		dey			dey 										; do it 32 times.
.010cac	d0 e0		bne $010c8e		bne 	_BinaryDivide_Loop
.010cae					_BinaryDivide_Exit:
.010cae	a5 14		lda $14			lda 	DSignCount 							; restore sign
.010cb0	29 01 00	and #$0001		and 	#1
.010cb3	f0 03		beq $010cb8		beq 	_BinaryDivide_Exit2
.010cb5	20 ba 0c	jsr $010cba		jsr 	Binary_DivNegate
.010cb8					_BinaryDivide_Exit2:
.010cb8	7a		ply			ply 										; restore Y
.010cb9	60		rts			rts
.010cba					Binary_DivNegate:
.010cba	e6 14		inc $14			inc 	DSignCount 							; increment the count of signs.
.010cbc	38		sec			sec 										; negate the value at stack X.
.010cbd	a9 00 00	lda #$0000		lda 	#$0000
.010cc0	f5 00		sbc $00,x		sbc 	EXSValueL+0,x
.010cc2	95 00		sta $00,x		sta 	EXSValueL+0,x
.010cc4	a9 00 00	lda #$0000		lda 	#$0000
.010cc7	f5 02		sbc $02,x		sbc 	EXSValueH+0,x
.010cc9	95 02		sta $02,x		sta 	EXSValueH+0,x
.010ccb	60		rts			rts
.010ccc					Binary_Modulus:
.010ccc	20 51 0c	jsr $010c51		jsr 	Binary_Divide 						; do the divide
.010ccf	a5 08		lda $08			lda 	DTemp1+0 							; copy modulus into data area.
.010cd1	95 00		sta $00,x		sta 	EXSValueL+0,x
.010cd3	a5 0a		lda $0a			lda 	DTemp1+2
.010cd5	95 02		sta $02,x		sta 	EXSValueH+0,x
.010cd7	60		rts			rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/binary/multiply.asm

.010cd8					Binary_Multiply:
.010cd8	20 09 06	jsr $010609		jsr 	CheckBothNumeric 					; check both values are numeric
.010cdb	b5 00		lda $00,x		lda 	EXSValueL+0,x 						; multiplier to DTemp1, multiplicand in Value+2
.010cdd	85 08		sta $08			sta 	DTemp1
.010cdf	b5 02		lda $02,x		lda 	EXSValueH+0,x
.010ce1	85 0a		sta $0a			sta		DTemp1+2
.010ce3	74 00		stz $00,x		stz 	EXSValueL+0,x						; zero result
.010ce5	74 02		stz $02,x		stz 	EXSValueH+0,x
.010ce7					_BinaryMultiply_Loop:
.010ce7	a5 08		lda $08			lda 	DTemp1 								; multiplier zero then exit
.010ce9	05 0a		ora $0a			ora 	DTemp1+2
.010ceb	f0 1e		beq $010d0b		beq 	_BinaryMultiply_Exit
.010ced	a5 08		lda $08			lda 	DTemp1 								; check bit 0 of multiplier
.010cef	29 01 00	and #$0001		and 	#1
.010cf2	f0 0d		beq $010d01		beq 	_BinaryMultiply_NoAdd
.010cf4	18		clc			clc 										; add multiplicand to result.
.010cf5	b5 00		lda $00,x		lda 	EXSValueL+0,x
.010cf7	75 06		adc $06,x		adc 	EXSValueL+EXSNext,x
.010cf9	95 00		sta $00,x		sta 	EXSValueL+0,x
.010cfb	b5 02		lda $02,x		lda 	EXSValueH+0,x
.010cfd	75 08		adc $08,x		adc 	EXSValueH+EXSNext,x
.010cff	95 02		sta $02,x		sta 	EXSValueH+0,x
.010d01					_BinaryMultiply_NoAdd:
.010d01	46 0a		lsr $0a			lsr 	DTemp1+2 							; halve multiplier
.010d03	66 08		ror $08			ror 	DTemp1
.010d05	16 06		asl $06,x		asl 	EXSValueL+EXSNext,x					; double multiplicand
.010d07	36 08		rol $08,x		rol 	EXSValueH+EXSNext,x
.010d09	80 dc		bra $010ce7		bra 	_BinaryMultiply_Loop 				; go round again.
.010d0b					_BinaryMultiply_Exit:
.010d0b	60		rts			rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/unary/simpleunary.asm

.010d0c					Function_Len:
.010d0c	20 29 06	jsr $010629			jsr 	ResetTypeInteger 			; returns an integer
.010d0f	20 45 03	jsr $010345			jsr 	EvaluateNextString 			; get the value you are absoluting
.010d12	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket 			; check )
.010d15	b4 06		ldy $06,x			ldy 	EXSValueL+EXSNext,x 		; address of string.
.010d17	b9 00 00	lda $0000,y			lda 	$0000,y 					; get the string length
.010d1a	29 ff 00	and #$00ff			and 	#$00FF 						; as a byte
.010d1d	95 00		sta $00,x			sta 	EXSValueL+0,x 				; and return it
.010d1f	74 02		stz $02,x			stz 	EXSValueH+0,x
.010d21	60		rts				rts
.010d22					Function_Abs:
.010d22	20 29 06	jsr $010629			jsr 	ResetTypeInteger 			; returns an integer
.010d25	20 26 03	jsr $010326			jsr 	EvaluateNextInteger 		; get the value you are absoluting
.010d28	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket 			; check )
.010d2b	b5 08		lda $08,x			lda 	EXSValueH+EXSNext,x 		; get sign of result from the upper word.
.010d2d	30 07		bmi $010d36			bmi 	_FAbsNegative 				; negate it if negative
.010d2f	95 02		sta $02,x			sta 	EXSValueH+0,x 				; otherwise just copy it.
.010d31	b5 06		lda $06,x			lda 	EXSValueL+EXSNext,x
.010d33	95 00		sta $00,x			sta 	EXSValueL+0,x
.010d35	60		rts				rts
.010d36					_FAbsNegative:
.010d36	38		sec				sec 								; copy 0 - 2nd stack => 1st stack.
.010d37	a9 00 00	lda #$0000			lda 	#0
.010d3a	f5 06		sbc $06,x			sbc 	EXSValueL+EXSNext,x
.010d3c	95 00		sta $00,x			sta 	EXSValueL+0,x
.010d3e	a9 00 00	lda #$0000			lda 	#0
.010d41	f5 08		sbc $08,x			sbc 	EXSValueH+EXSNext,x
.010d43	95 02		sta $02,x			sta 	EXSValueH+0,x
.010d45	60		rts				rts
.010d46					Function_Sgn:
.010d46	20 29 06	jsr $010629			jsr 	ResetTypeInteger 			; returns integer
.010d49	20 26 03	jsr $010326			jsr 	EvaluateNextInteger 		; get an integer
.010d4c	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket 			; check )
.010d4f	74 00		stz $00,x			stz 	EXSValueL+0,x 				; zero the result
.010d51	74 02		stz $02,x			stz 	EXSValueH+0,x
.010d53	b5 08		lda $08,x			lda 	EXSValueH+EXSNext,x 		; get sign of result from high bit of upper word.
.010d55	30 07		bmi $010d5e			bmi 	_FSgnNegative 				; set to -1 if signed
.010d57	15 06		ora $06,x			ora 	EXSValueL+EXSNext,x 		; exit if zero as we already reset it.
.010d59	f0 02		beq $010d5d			beq 	_FSgnExit
.010d5b	f6 00		inc $00,x			inc 	EXSValueL+0,x 				; > 0 so make result 1 if positive and non-zero
.010d5d					_FSgnExit:
.010d5d	60		rts				rts
.010d5e					_FSgnNegative:
.010d5e	a9 ff ff	lda #$ffff			lda 	#$FFFF 						; set the return value to -1 as negative.
.010d61	95 00		sta $00,x			sta 	EXSValueL+0,x
.010d63	95 02		sta $02,x			sta 	EXSValueH+0,x
.010d65	60		rts				rts
.010d66					Function_Random:
.010d66	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket 			; check )
.010d69	20 29 06	jsr $010629			jsr 	ResetTypeInteger
.010d6c	a5 10		lda $10				lda 	DRandom 					; check for non-zero
.010d6e	05 12		ora $12				ora 	DRandom+2 					; they don't like these :)
.010d70	d0 0a		bne $010d7c			bne 	_Rnd_NotZero
.010d72	a9 b5 00	lda #$00b5			lda 	#$B5 						; initialise it to the same value.
.010d75	85 10		sta $10				sta 	DRandom
.010d77	a9 ea 00	lda #$00ea			lda 	#$EA
.010d7a	85 12		sta $12				sta 	DRandom+2
.010d7c					_Rnd_NotZero:
.010d7c	20 87 0d	jsr $010d87			jsr 	_Rnd_Process 				; call randomiser twice
.010d7f	95 02		sta $02,x			sta 	EXSValueH+0,x
.010d81	20 87 0d	jsr $010d87			jsr 	_Rnd_Process
.010d84	95 00		sta $00,x			sta 	EXSValueL+0,x
.010d86	60		rts				rts
.010d87					_Rnd_Process:
.010d87	06 10		asl $10				asl 	DRandom 					; shift right, exit
.010d89	26 12		rol $12				rol 	DRandom+2
.010d8b	90 0e		bcc $010d9b			bcc 	_Rnd_Exit
.010d8d	a5 10		lda $10				lda 	DRandom 					; taps effectively
.010d8f	49 54 d4	eor #$d454			eor 	#$D454
.010d92	85 10		sta $10				sta 	DRandom
.010d94	a5 12		lda $12				lda 	DRandom+2
.010d96	49 d5 55	eor #$55d5			eor 	#$55D5
.010d99	85 12		sta $12				sta 	DRandom+2
.010d9b					_Rnd_Exit:
.010d9b	a5 10		lda $10				lda 	DRandom
.010d9d	45 12		eor $12				eor 	DRandom+2
.010d9f	60		rts				rts
.010da0					Function_Chr:
.010da0	20 31 06	jsr $010631			jsr 	ResetTypeString 			; returns a string
.010da3	20 26 03	jsr $010326			jsr 	EvaluateNextInteger 		; get integer
.010da6	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket 			; check )
.010da9	c0 00 00	cpy #$0000			cpy 	#0 							; must be 0-255
.010dac	d0 12		bne $010dc0			bne 	_FCHBad
.010dae	48		pha				pha  								; save char # on stack
.010daf	a9 01 00	lda #$0001			lda 	#1 							; allocate a single character string
.010db2	20 1e 07	jsr $01071e			jsr 	StringTempAllocate
.010db5	68		pla				pla 								; restore character number
.010db6	20 4e 07	jsr $01074e			jsr 	StringWriteCharacter 		; write it out.
.010db9	a5 18		lda $18				lda 	DStartTempString 			; return the string address
.010dbb	95 00		sta $00,x			sta 	EXSValueL+0,x 				; and return that.
.010dbd	74 02		stz $02,x			stz 	EXSValueH+0,x
.010dbf	60		rts				rts
.010dc0					_FCHBad:
.010dc0	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>010dc3	42 61 64 20 76 61 6c 75				.text 	"Bad value for chr$()",$00 								; with this message
>010dcb	65 20 66 6f 72 20 63 68 72 24 28 29 00
.010dd8					Function_Asc:
.010dd8	20 29 06	jsr $010629			jsr 	ResetTypeInteger 			; returns an integer
.010ddb	20 45 03	jsr $010345			jsr 	EvaluateNextString 			; get string
.010dde	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket 			; check )
.010de1	a8		tay				tay 								; string address in Y
.010de2	b9 00 00	lda $0000,y			lda 	$0000,y 					; check length non zero
.010de5	29 ff 00	and #$00ff			and 	#$00FF
.010de8	f0 0b		beq $010df5			beq 	_FASBad 					; what does ASC("") do ? return 0 - error here.
.010dea	b9 01 00	lda $0001,y			lda 	$0001,y 					; get first char
.010ded	29 ff 00	and #$00ff			and 	#$00FF 						; mask it
.010df0	95 00		sta $00,x			sta 	EXSValueL+0,x 				; and return that.
.010df2	74 02		stz $02,x			stz 	EXSValueH+0,x
.010df4	60		rts				rts
.010df5					_FASBad:
.010df5	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>010df8	42 61 64 20 76 61 6c 75				.text 	"Bad value for asc()",$00 								; with this message
>010e00	65 20 66 6f 72 20 61 73 63 28 29 00
.010e0c					Function_SPC:
.010e0c	20 31 06	jsr $010631			jsr 	ResetTypeString 			; returns a string
.010e0f	20 26 03	jsr $010326			jsr 	EvaluateNextInteger 		; get integer, which is the length.
.010e12	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket 			; check )
.010e15	c0 00 00	cpy #$0000			cpy 	#0 							; must be 0-255
.010e18	d0 17		bne $010e31			bne 	_FSPBad
.010e1a	48		pha				pha 								; save length
.010e1b	20 1e 07	jsr $01071e			jsr 	StringTempAllocate 			; allocate character space
.010e1e	7a		ply				ply 								; get count in Y
.010e1f	f0 09		beq $010e2a			beq 	_FSPExit 					; if zero, just empty string
.010e21					_FSPCopy:
.010e21	a9 20 00	lda #$0020			lda 	#" "						; space character
.010e24	20 4e 07	jsr $01074e			jsr 	StringWriteCharacter 		; write it out.
.010e27	88		dey				dey
.010e28	d0 f7		bne $010e21			bne 	_FSPCopy	 				; do it Y times
.010e2a					_FSPExit:
.010e2a	a5 18		lda $18				lda 	DStartTempString 			; return that address
.010e2c	95 00		sta $00,x			sta 	EXSValueL+0,x
.010e2e	74 02		stz $02,x			stz 	EXSValueH+0,x
.010e30	60		rts				rts
.010e31					_FSPBad:
.010e31	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>010e34	42 61 64 20 76 61 6c 75				.text 	"Bad value for spc()",$00 								; with this message
>010e3c	65 20 66 6f 72 20 73 70 63 28 29 00
.010e48					Function_Inkey:
.010e48	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket 			; check )
.010e4b	20 29 06	jsr $010629			jsr 	ResetTypeInteger
.010e4e	20 90 1e	jsr $011e90			jsr 	HWInkey 					; read current key
.010e51	95 00		sta $00,x			sta 	EXSValueL+0,x
.010e53	74 02		stz $02,x			stz 	EXSValueH+0,x
.010e55	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/unary/string.asm

.010e56					Function_LEFT:
.010e56	20 31 06	jsr $010631			jsr 	ResetTypeString 			; returns a string.
.010e59	20 45 03	jsr $010345			jsr 	EvaluateNextString 			; get the value you are absoluting
.010e5c	48		pha				pha 								; save string on stack.
.010e5d	20 00 06	jsr $010600			jsr 	ExpectComma 				; get count
.010e60	20 26 03	jsr $010326			jsr 	EvaluateNextInteger
.010e63	c0 00 00	cpy #$0000			cpy 	#0 							; can't be high
.010e66	d0 6d		bne $010ed5			bne 	FNStringParameter
.010e68	85 08		sta $08				sta 	DTemp1 						; save count.
.010e6a	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket
.010e6d	7a		ply				ply 								; Y points to string.
.010e6e	b9 00 00	lda $0000,y			lda 	$0000,y 					; get length of string
.010e71	29 ff 00	and #$00ff			and 	#$00FF
.010e74	f0 52		beq $010ec8			beq 	FNStringEmpty 				; return empty if zero length anyway.
.010e76	c5 08		cmp $08				cmp 	DTemp1 						; compare current vs required length
.010e78	f0 55		beq $010ecf			beq 	FNStringY 					; return string in Y if current len = required len.
.010e7a	90 53		bcc $010ecf			bcc 	FNStringY 					; if current < required return whole thing.
.010e7c	c8		iny				iny 								; take from here - start of string
.010e7d	80 33		bra $010eb2			bra 	FNDTemp1Characters
.010e7f					Function_RIGHT:
.010e7f	20 31 06	jsr $010631			jsr 	ResetTypeString 			; returns a string.
.010e82	20 45 03	jsr $010345			jsr 	EvaluateNextString 			; get the value you are absoluting
.010e85	48		pha				pha 								; save string on stack.
.010e86	20 00 06	jsr $010600			jsr 	ExpectComma 				; get count
.010e89	20 26 03	jsr $010326			jsr 	EvaluateNextInteger
.010e8c	c0 00 00	cpy #$0000			cpy 	#0 							; can't be high
.010e8f	d0 44		bne $010ed5			bne 	FNStringParameter
.010e91	85 08		sta $08				sta 	DTemp1 						; save count.
.010e93	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket
.010e96	7a		ply				ply 								; Y points to string.
.010e97	b9 00 00	lda $0000,y			lda 	$0000,y 					; get length of string
.010e9a	29 ff 00	and #$00ff			and 	#$00FF
.010e9d	f0 29		beq $010ec8			beq 	FNStringEmpty 				; return empty if zero length anyway.
.010e9f	c5 08		cmp $08				cmp 	DTemp1 						; compare current vs required length
.010ea1	f0 2c		beq $010ecf			beq 	FNStringY 					; return string in Y if current len = required len.
.010ea3	90 2a		bcc $010ecf			bcc 	FNStringY 					; if current < required return whole thing.
.010ea5	38		sec				sec 								; current-required is the number to skip
.010ea6	e5 08		sbc $08				sbc 	DTemp1
.010ea8	85 0a		sta $0a				sta 	DTemp1+2
.010eaa	98		tya				tya
.010eab	18		clc				clc
.010eac	65 0a		adc $0a				adc 	DTemp1+2
.010eae	a8		tay				tay
.010eaf	c8		iny				iny 								; +1 for the count.
.010eb0	80 00		bra $010eb2			bra 	FNDTemp1Characters
.010eb2					FNDTemp1Characters:
.010eb2	a5 08		lda $08				lda 	DTemp1 						; we need this big a string.
.010eb4	f0 12		beq $010ec8			beq 	FNStringEmpty 				; if zero, return empty string.
.010eb6	20 1e 07	jsr $01071e			jsr 	StringTempAllocate
.010eb9	48		pha				pha 								; save the address
.010eba					_FND1Loop:
.010eba	b9 00 00	lda $0000,y			lda 	$0000,y 					; character to copy
.010ebd	20 4e 07	jsr $01074e			jsr 	StringWriteCharacter
.010ec0	c8		iny				iny
.010ec1	c6 08		dec $08				dec 	DTemp1 						; DTemp1 times
.010ec3	d0 f5		bne $010eba			bne 	_FND1Loop
.010ec5	7a		ply				ply 								; string address in Y
.010ec6	80 07		bra $010ecf			bra 	FNStringY
.010ec8					FNStringEmpty:
.010ec8	a9 00 00	lda #$0000			lda 	#0 							; return an empty string.
.010ecb	20 1e 07	jsr $01071e			jsr 	StringTempAllocate 			; put address of it in Y
.010ece	a8		tay				tay
.010ecf					FNStringY:
.010ecf	98		tya				tya
.010ed0	95 00		sta $00,x			sta 	EXSValueL+0,x
.010ed2	74 08		stz $08,x			stz 	EXSValueH+EXSNext,x
.010ed4	60		rts				rts
.010ed5					FNStringParameter:
.010ed5	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>010ed8	42 61 64 20 53 74 72 69				.text 	"Bad String Operation",$00 								; with this message
>010ee0	6e 67 20 4f 70 65 72 61 74 69 6f 6e 00
.010eed					Function_MID:
.010eed	20 31 06	jsr $010631			jsr 	ResetTypeString 			; returns a string.
.010ef0	20 45 03	jsr $010345			jsr 	EvaluateNextString 			; get the value you are absoluting
.010ef3	48		pha				pha 								; save string on stack.
.010ef4	20 00 06	jsr $010600			jsr 	ExpectComma 				; get offset (n)
.010ef7	20 26 03	jsr $010326			jsr 	EvaluateNextInteger
.010efa	c0 00 00	cpy #$0000			cpy 	#0 							; can't be high
.010efd	d0 d6		bne $010ed5			bne 	FNStringParameter
.010eff	c9 00 00	cmp #$0000			cmp 	#0
.010f02	f0 d1		beq $010ed5			beq 	FNStringParameter 			; or zero
.010f04	48		pha				pha 								; save start position on stack.
.010f05	a9 ff 00	lda #$00ff			lda 	#255 						; default third parameter is 255 e.g. whole string
.010f08	85 08		sta $08				sta 	DTemp1
.010f0a	b2 06		lda ($06)			lda 	(DCodePtr) 					; is there a comma
.010f0c	c9 24 32	cmp #$3224			cmp 	#commaTokenID
.010f0f	d0 0e		bne $010f1f			bne 	_FMINoThird
.010f11	e6 06		inc $06				inc 	DCodePtr 					; skip the comma
.010f13	e6 06		inc $06				inc 	DCodePtr
.010f15	20 26 03	jsr $010326			jsr 	EvaluateNextInteger 		; how many to do (n1)
.010f18	c0 00 00	cpy #$0000			cpy 	#0 							; can't be high
.010f1b	d0 b8		bne $010ed5			bne 	FNStringParameter
.010f1d	85 08		sta $08				sta 	DTemp1 						; save in DTemp1 (characters to count)
.010f1f					_FMINoThird:
.010f1f	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket
.010f22	68		pla				pla 								; get offset position
.010f23	85 0c		sta $0c				sta 	DTemp2
.010f25	7a		ply				ply 								; get address of string in Y
.010f26	b9 00 00	lda $0000,y			lda		$0000,y 					; get length
.010f29	29 ff 00	and #$00ff			and 	#$00FF
.010f2c	c5 0c		cmp $0c				cmp 	DTemp2 						; check length of string vs offset position
.010f2e	90 98		bcc $010ec8			bcc 	FNStringEmpty 				; if length <= offset position then return ""
.010f30	38		sec				sec 								; calculate number of characters left after
.010f31	e5 0c		sbc $0c				sbc 	DTemp2 						; offset
.010f33	1a		inc a				inc 	a 							; there is one more because of index starts at 1.
.010f34	c5 08		cmp $08				cmp 	DTemp1 						; available -- chars required.
.010f36	b0 02		bcs $010f3a			bcs 	_FMISufficient
.010f38	85 08		sta $08				sta 	DTemp1 						; if available < chars required, only copy those
.010f3a					_FMISufficient:
.010f3a	98		tya				tya 								; get address
.010f3b	18		clc				clc
.010f3c	65 0c		adc $0c				adc 	DTemp2 						; add the offset, the extra 1 (index) skips length
.010f3e	a8		tay				tay 								; put in Y
.010f3f	82 70 ff	brl $010eb2			brl 	FNDTemp1Characters			; and copy them.

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/unary/memread.asm

.010f42					Function_Peek:
.010f42	20 29 06	jsr $010629			jsr 	ResetTypeInteger 			; returns an integer
.010f45	20 26 03	jsr $010326			jsr 	EvaluateNextInteger 		; get the value you are absoluting
.010f48	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket 			; check )
.010f4b	85 08		sta $08				sta 	DTemp1 						; save address in DTemp
.010f4d	84 0a		sty $0a				sty 	DTemp1+2
.010f4f	a0 00 00	ldy #$0000			ldy 	#0							; read data
.010f52	b7 08		lda [$08],y			lda 	[DTemp1],y
.010f54	29 ff 00	and #$00ff			and 	#$00FF 						; mask
.010f57	95 00		sta $00,x			sta 	EXSValueL+0,x 				; write out.
.010f59	74 02		stz $02,x			stz 	EXSValueH+0,x
.010f5b	60		rts				rts
.010f5c					Function_Deek:
.010f5c	20 29 06	jsr $010629			jsr 	ResetTypeInteger 			; returns an integer
.010f5f	20 26 03	jsr $010326			jsr 	EvaluateNextInteger 		; get the value you are absoluting
.010f62	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket 			; check )
.010f65	85 08		sta $08				sta 	DTemp1 						; save address in DTemp
.010f67	84 0a		sty $0a				sty 	DTemp1+2
.010f69	a0 00 00	ldy #$0000			ldy 	#0							; read data
.010f6c	b7 08		lda [$08],y			lda 	[DTemp1],y
.010f6e	95 00		sta $00,x			sta 	EXSValueL+0,x 				; write out.
.010f70	74 02		stz $02,x			stz 	EXSValueH+0,x
.010f72	60		rts				rts
.010f73					Function_Leek:
.010f73	20 29 06	jsr $010629			jsr 	ResetTypeInteger 			; returns an integer
.010f76	20 26 03	jsr $010326			jsr 	EvaluateNextInteger 		; get the value you are absoluting
.010f79	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket 			; check )
.010f7c	85 08		sta $08				sta 	DTemp1 						; save address in DTemp
.010f7e	84 0a		sty $0a				sty 	DTemp1+2
.010f80	a0 00 00	ldy #$0000			ldy 	#0							; read data
.010f83	b7 08		lda [$08],y			lda 	[DTemp1],y
.010f85	95 00		sta $00,x			sta 	EXSValueL+0,x 				; write out.
.010f87	c8		iny				iny
.010f88	c8		iny				iny
.010f89	b7 08		lda [$08],y			lda 	[DTemp1],y
.010f8b	95 02		sta $02,x			sta 	EXSValueH+0,x
.010f8d	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/unary/val.asm

.010f8e					Function_VAL:
.010f8e	20 29 06	jsr $010629			jsr 	ResetTypeInteger 			; returns an integer
.010f91	20 45 03	jsr $010345			jsr 	EvaluateNextString 			; get the value you are absoluting
.010f94	48		pha				pha 								; put string address on stack.
.010f95	20 a5 0f	jsr $010fa5			jsr 	VALGetBase 					; process , base (shared with STR$())
.010f98	7a		ply				ply 								; get string address back
.010f99	da		phx				phx 								; save X on stack
.010f9a	aa		tax				tax 								; base in X
.010f9b	98		tya				tya 								; address in A
.010f9c	20 df 0f	jsr $010fdf			jsr 	StringToInteger
.010f9f	fa		plx				plx 								; restore X
.010fa0	95 00		sta $00,x			sta 	EXSValueL+0,x
.010fa2	94 02		sty $02,x			sty 	EXSValueH+0,x
.010fa4	60		rts				rts
.010fa5					VALGetBase:
.010fa5	b2 06		lda ($06)			lda 	(DCodePtr)					; look at next
.010fa7	c9 24 32	cmp #$3224			cmp 	#commaTokenID 				; if comma, go to get base code.
.010faa	f0 07		beq $010fb3			beq 	_VGBAlternate
.010fac	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket			; expect ), and return 10.
.010faf	a9 0a 00	lda #$000a			lda 	#10
.010fb2	60		rts				rts
.010fb3					_VGBAlternate:
.010fb3	20 00 06	jsr $010600			jsr 	ExpectComma 				; skip comma.
.010fb6	20 26 03	jsr $010326			jsr 	EvaluateNextInteger 		; get base
.010fb9	c0 00 00	cpy #$0000			cpy 	#0							; check base legal
.010fbc	d0 0e		bne $010fcc			bne 	_VGBBadBase
.010fbe	c9 02 00	cmp #$0002			cmp 	#2
.010fc1	90 09		bcc $010fcc			bcc 	_VGBBadBase
.010fc3	c9 11 00	cmp #$0011			cmp 	#16+1						; 0-9A-F
.010fc6	b0 04		bcs $010fcc			bcs 	_VGBBadBase
.010fc8	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket 			; get right bracket and return.
.010fcb	60		rts				rts
.010fcc					_VGBBadBase:
.010fcc	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>010fcf	42 61 64 20 4e 75 6d 62				.text 	"Bad Number Base",$00 								; with this message
>010fd7	65 72 20 42 61 73 65 00
.010fdf					StringToInteger:
.010fdf	85 24		sta $24				sta 	DTemp3 						; DTemp3 is the character pointer
.010fe1	b2 24		lda ($24)			lda 	(DTemp3)					; DTemp3+2 is the character count to do.
.010fe3	29 ff 00	and #$00ff			and 	#$00FF
.010fe6	85 26		sta $26				sta 	DTemp3+2
.010fe8	f0 6e		beq $011058			beq 	_STIError 					; if length zero it's bad.
.010fea	e6 24		inc $24				inc 	DTemp3 						; skip length byte.
.010fec	86 14		stx $14				stx 	DSignCount 					; Signcount is the base, 2-16.
.010fee	64 08		stz $08				stz 	DTemp1 						; Zero DTemp1, this is the result register.
.010ff0	64 0a		stz $0a				stz 	DTemp1+2
.010ff2	b2 24		lda ($24)			lda 	(DTemp3)					; look at first character
.010ff4	29 ff 00	and #$00ff			and 	#$00FF 						; mask off
.010ff7	48		pha				pha 								; push on stack
.010ff8	c9 2d 00	cmp #$002d			cmp 	#"-"						; if not -, skip
.010ffb	d0 06		bne $011003			bne 	_STILoop
.010ffd	e6 24		inc $24				inc 	DTemp3 						; advance pointer over minus sign
.010fff	c6 26		dec $26				dec 	DTemp3+2					; dec count
.011001	f0 55		beq $011058			beq 	_STIError 					; if only - then error.
.011003					_STILoop:
.011003	a5 14		lda $14				lda 	DSignCount 					; multiply DTemp1 by DSignCount
.011005	20 77 10	jsr $011077			jsr 	MultiplyTemp1ByA
.011008	b2 24		lda ($24)			lda 	(DTemp3)					; get character, mask
.01100a	29 ff 00	and #$00ff			and 	#$00FF
.01100d	20 68 10	jsr $011068			jsr 	ConvertUpperCase	 		; make U/C
.011010	c9 30 00	cmp #$0030			cmp 	#'0' 						; validate it check if 0-9
.011013	90 43		bcc $011058			bcc 	_STIError
.011015	c9 3a 00	cmp #$003a			cmp 	#'9'+1
.011018	90 0e		bcc $011028			bcc 	_STIOkay1
.01101a	c9 41 00	cmp #$0041			cmp 	#'A' 						; check if A-Z
.01101d	90 39		bcc $011058			bcc 	_STIError
.01101f	c9 5b 00	cmp #$005b			cmp 	#'Z'+1
.011022	b0 34		bcs $011058			bcs 	_STIError
.011024	18		clc				clc 								; shift to correct range.
.011025	69 09 00	adc #$0009			adc 	#9
.011028					_STIOkay1:
.011028	29 0f 00	and #$000f			and 	#15 						; now in range 0-35
.01102b	c5 14		cmp $14				cmp 	DSignCount 					; error if >= base
.01102d	b0 29		bcs $011058			bcs 	_STIError
.01102f	18		clc				clc 								; add A to DTemp1
.011030	65 08		adc $08				adc 	DTemp1
.011032	85 08		sta $08				sta 	DTemp1
.011034	90 02		bcc $011038			bcc 	_STINoCarry
.011036	e6 0a		inc $0a				inc 	DTemp1+2
.011038					_STINoCarry:
.011038	e6 24		inc $24				inc 	DTemp3 						; get character, pre-increment because of count byte
.01103a	c6 26		dec $26				dec 	DTemp3+2 					; decrement counter
.01103c	d0 c5		bne $011003			bne 	_STILoop 					; loop back.
.01103e	68		pla				pla 								; get optional minus bac
.01103f	c9 2d 00	cmp #$002d			cmp 	#"-"
.011042	d0 0f		bne $011053			bne 	_STINotNegative 			; handle the negative character
.011044	38		sec				sec 								; negate DTemp1
.011045	a9 00 00	lda #$0000			lda 	#0
.011048	e5 08		sbc $08				sbc 	DTemp1
.01104a	85 08		sta $08				sta 	DTemp1
.01104c	a9 00 00	lda #$0000			lda 	#0
.01104f	e5 0a		sbc $0a				sbc 	DTemp1+2
.011051	85 0a		sta $0a				sta 	DTemp1+2
.011053					_STINotNegative:
.011053	a5 08		lda $08				lda 	DTemp1 						; get the result
.011055	a4 0a		ldy $0a				ldy 	DTemp1+2
.011057	60		rts				rts
.011058					_STIError:
.011058	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>01105b	42 61 64 20 63 6f 6e 73				.text 	"Bad constant",$00 								; with this message
>011063	74 61 6e 74 00
.011068					ConvertUpperCase:
.011068	c9 61 00	cmp #$0061			cmp 	#'a'
.01106b	90 09		bcc $011076			bcc 	_CUCExit
.01106d	c9 7b 00	cmp #$007b			cmp 	#'z'+1
.011070	b0 04		bcs $011076			bcs 	_CUCExit
.011072	38		sec				sec
.011073	e9 20 00	sbc #$0020			sbc 	#32
.011076					_CUCExit:
.011076	60		rts				rts
.011077					MultiplyTemp1ByA:
.011077					_MTGeneral:
.011077	da		phx				phx
.011078	aa		tax				tax 								; multiplier in X
.011079	a5 08		lda $08				lda 	DTemp1 						; copy DTemp1 to DTemp2
.01107b	85 0c		sta $0c				sta 	DTemp2
.01107d	a5 0a		lda $0a				lda 	DTemp1+2
.01107f	85 0e		sta $0e				sta 	DTemp2+2
.011081	64 08		stz $08				stz 	DTemp1 						; zero DTemp1
.011083	64 0a		stz $0a				stz 	DTemp1+2
.011085	a0 00 00	ldy #$0000			ldy 	#0 		 					; this is the 'high byte' of the result.
.011088					_MTLoop:
.011088	8a		txa				txa 								; shift X right into C
.011089	4a		lsr a				lsr 	a
.01108a	aa		tax				tax
.01108b	90 10		bcc $01109d			bcc 	_MTNoAdd
.01108d	18		clc				clc
.01108e	a5 08		lda $08				lda 	DTemp1 						; add if LSB set
.011090	65 0c		adc $0c				adc 	DTemp2
.011092	85 08		sta $08				sta 	DTemp1
.011094	a5 0a		lda $0a				lda 	DTemp1+2
.011096	65 0e		adc $0e				adc 	DTemp2+2
.011098	85 0a		sta $0a				sta 	DTemp1+2
.01109a	90 01		bcc $01109d			bcc 	_MTNoAdd
.01109c	c8		iny				iny
.01109d					_MTNoAdd:
.01109d	06 0c		asl $0c				asl 	DTemp2  					; shift multiplicand left
.01109f	26 0e		rol $0e				rol 	DTemp2+2
.0110a1	90 01		bcc $0110a4			bcc 	_MTNoOverflow
.0110a3	c8		iny				iny
.0110a4					_MTNoOverflow:
.0110a4	8a		txa				txa 								; until multiplier is zero.
.0110a5	d0 e1		bne $011088			bne 	_MTLoop
.0110a7	98		tya				tya
.0110a8	18		clc				clc
.0110a9	69 ff ff	adc #$ffff			adc 	#$FFFF
.0110ac	fa		plx				plx 								; restore X
.0110ad	60		rts				rts 								; and exit

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/unary/str.asm

.0110ae					Function_Str:
.0110ae	20 31 06	jsr $010631			jsr 	ResetTypeString 			; returns a string.
.0110b1	20 26 03	jsr $010326			jsr 	EvaluateNextInteger 		; get the value you are absoluting
.0110b4	48		pha				pha 								; save YA on the stack
.0110b5	5a		phy				phy
.0110b6	20 a5 0f	jsr $010fa5			jsr 	VALGetBase 					; process , base (shared with STR$())
.0110b9	85 14		sta $14				sta 	DSignCount
.0110bb	7a		ply				ply 								; YA is the number
.0110bc	68		pla				pla
.0110bd	da		phx				phx
.0110be	a6 14		ldx $14				ldx 	DSignCount 					; X is the base.
.0110c0	20 c9 10	jsr $0110c9			jsr 	ConvertToString 			; convert it to a string.
.0110c3	fa		plx				plx 								; restore X
.0110c4	95 00		sta $00,x			sta 	EXSValueL+0,x 				; save the result
.0110c6	74 02		stz $02,x			stz 	EXSValueH+0,x
.0110c8	60		rts				rts
.0110c9					ConvertToString:
.0110c9	48		pha				pha
.0110ca	a9 22 00	lda #$0022			lda 	#34 						; enough space for Base 2.
.0110cd	20 1e 07	jsr $01071e			jsr 	StringTempAllocate 			; allocate space for return string.
.0110d0	68		pla				pla
.0110d1					ConvertToStringAlreadyAllocated:
.0110d1	da		phx				phx 								; save X (base)
.0110d2	85 24		sta $24				sta 	DTemp3 						; save number in DTemp3
.0110d4	84 26		sty $26				sty 	DTemp3+2
.0110d6	86 14		stx $14				stx 	DSignCount 					; save base in DSignCount.
.0110d8	a5 26		lda $26				lda 	DTemp3+2 					; is number -ve.
.0110da	10 15		bpl $0110f1			bpl 	_CTSNotNegative
.0110dc	a9 2d 00	lda #$002d			lda 	#"-"						; output a minus character to the new string
.0110df	20 5b 11	jsr $01115b			jsr 	CTSOutputA
.0110e2	38		sec				sec 								; negate DTemp3 which is the number
.0110e3	a9 00 00	lda #$0000			lda 	#0
.0110e6	e5 24		sbc $24				sbc 	DTemp3
.0110e8	85 24		sta $24				sta 	DTemp3
.0110ea	a9 00 00	lda #$0000			lda 	#0
.0110ed	e5 26		sbc $26				sbc 	DTemp3+2
.0110ef	85 26		sta $26				sta 	DTemp3+2
.0110f1					_CTSNotNegative:
.0110f1	a9 01 00	lda #$0001			lda 	#1 							; push 32-bit 1 on stack, which is the first subtractor.
.0110f4	48		pha				pha
.0110f5	a9 00 00	lda #$0000			lda 	#0
.0110f8	48		pha				pha
.0110f9	a5 14		lda $14				lda 	DSignCount 					; reset DTemp1, the subtractor to the base value
.0110fb	85 08		sta $08				sta 	DTemp1
.0110fd	64 0a		stz $0a				stz 	DTemp1+2
.0110ff					_CTSMultiplySubtractor:
.0110ff	38		sec				sec 								; check number vs subtractor
.011100	a5 24		lda $24				lda 	DTemp3
.011102	e5 08		sbc $08				sbc 	DTemp1
.011104	a5 26		lda $26				lda 	DTemp3+2
.011106	e5 0a		sbc $0a				sbc 	DTemp1+2
.011108	90 0f		bcc $011119			bcc		_CTSScaledUp 				; if >= then scaled up.
.01110a	a5 08		lda $08				lda 	DTemp1 						; push subtractor on the stack
.01110c	48		pha				pha
.01110d	a5 0a		lda $0a				lda 	DTemp1+2
.01110f	48		pha				pha
.011110	a5 14		lda $14				lda 	DSignCount 					; multiply subtractor by base
.011112	20 77 10	jsr $011077			jsr 	MultiplyTemp1ByA
.011115	b0 02		bcs $011119			bcs 	_CTSScaledUp 				; if overflow, start subtracting.
.011117	80 e6		bra $0110ff			bra 	_CTSMultiplySubtractor 		; otherwise try the next x base.
.011119					_CTSScaledUp:
.011119	7a		ply				ply 								; YA contains the previous divider.
.01111a	68		pla				pla
.01111b	c0 00 00	cpy #$0000			cpy 	#0 							; has that divider reached one yet ?
.01111e	d0 05		bne $011125			bne 	_CTSHasDigit
.011120	c9 01 00	cmp #$0001			cmp 	#1 							; if so, then we've just got that digit left.
.011123	f0 20		beq $011145			beq 	_CTSExit
.011125					_CTSHasDigit:
.011125	85 0c		sta $0c				sta 	DTemp2 						; save in DTemp2
.011127	84 0e		sty $0e				sty 	DTemp2+2
.011129	a2 00 00	ldx #$0000			ldx 	#0 							; this is the count.
.01112c					_CTSSubLoop:
.01112c	38		sec				sec 								; subtract subtractor from number
.01112d	a5 24		lda $24				lda 	DTemp3
.01112f	e5 0c		sbc $0c				sbc 	DTemp2
.011131	a8		tay				tay 								; intermediate in Y
.011132	a5 26		lda $26				lda 	DTemp3+2
.011134	e5 0e		sbc $0e				sbc 	DTemp2+2
.011136	90 07		bcc $01113f			bcc 	_CTSFinishedSubtracting 	; if number < subtractor then completed this one.
.011138	85 26		sta $26				sta 	DTemp3+2 					; output the number to DTemp3.
.01113a	84 24		sty $24				sty 	DTemp3
.01113c	e8		inx				inx 								; one more subtraction
.01113d	80 ed		bra $01112c			bra 	_CTSSubLoop 				; try it again.
.01113f					_CTSFinishedSubtracting:
.01113f	8a		txa				txa 								; convert to ASCII.
.011140	20 4e 11	jsr $01114e			jsr 	CTSOutputHexDigit 			; write that out.
.011143	80 d4		bra $011119			bra 	_CTSScaledUp 				; go pop the next subtactor and do that.
.011145					_CTSExit:
.011145	a5 24		lda $24				lda 	DTemp3 						; output last digit
.011147	20 4e 11	jsr $01114e			jsr 	CTSOutputHexDigit
.01114a	a5 18		lda $18				lda 	DStartTempString 			; return string address.
.01114c	fa		plx				plx 								; restore X.
.01114d	60		rts				rts
.01114e					CTSOutputHexDigit:
.01114e	c9 0a 00	cmp #$000a			cmp 	#10 						; 0-9 are 48-56
.011151	90 04		bcc $011157			bcc 	_CTSNotLetter
.011153	18		clc				clc
.011154	69 27 00	adc #$0027			adc 	#65-58+32 					; shift for bases > 10
.011157					_CTSNotLetter:
.011157	18		clc				clc
.011158	69 30 00	adc #$0030			adc 	#48
.01115b					CTSOutputA:
.01115b	5a		phy				phy 								; save Y, set Y to current pointer
.01115c	a4 1a		ldy $1a				ldy 	DCurrentTempString
.01115e	99 00 00	sta $0000,y			sta 	$0000,y 					; write out, with a following zero.
.011161	e2 20		sep #$20			sep 	#$20 						; save in 8 bit mode.
.011163	b2 18		lda ($18)			lda 	(DStartTempString)			; increment character count.
.011165	1a		inc a				inc 	a
.011166	92 18		sta ($18)			sta 	(DStartTempString)
.011168	c2 20		rep #$20			rep 	#$20
.01116a	e6 1a		inc $1a				inc 	DCurrentTempString 			; advance the pointer.
.01116c	7a		ply				ply 								; restore Y and exit.
.01116d	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/unary/instr.asm

.01116e					Function_INSTR:
.01116e	20 29 06	jsr $010629			jsr 	ResetTypeInteger 			; returns a integer
.011171	20 45 03	jsr $010345			jsr 	EvaluateNextString 			; evaluate a string.
.011174	48		pha				pha 								; save string to search
.011175	20 00 06	jsr $010600			jsr 	ExpectComma
.011178	20 45 03	jsr $010345			jsr 	EvaluateNextString 			; string to search for
.01117b	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket
.01117e	85 08		sta $08				sta 	DTemp1 						; DTemp1 is the string to search for
.011180	68		pla				pla
.011181	85 0c		sta $0c				sta 	DTemp2 						; DTemp2 is the string to search.
.011183	74 02		stz $02,x			stz 	EXSValueH+0,x 				; set high word to zero.
.011185	74 00		stz $00,x			stz 	EXSValueL+0,x 				; zero low word.
.011187	e2 20		sep #$20			sep 	#$20 						; calculate len(search)-len(lookfor)
.011189	38		sec				sec
.01118a	b2 0c		lda ($0c)			lda 	(DTemp2)
.01118c	f2 08		sbc ($08)			sbc		(DTemp1)
.01118e	c2 20		rep #$20			rep 	#$20
.011190	90 2c		bcc $0111be			bcc 	_FINSFail 					; if the string being searched is shorter, fail.
.011192	29 ff 00	and #$00ff			and 	#$00FF
.011195	1a		inc a				inc 	a
.011196	85 24		sta $24				sta 	DTemp3 						; this is the number of matches we can try.
.011198	b2 08		lda ($08)			lda 	(DTemp1) 					; fail if first string is ""
.01119a	29 ff 00	and #$00ff			and 	#$00FF
.01119d	f0 22		beq $0111c1			beq 	_FINSError
.01119f					_FINSLoop:
.01119f	b5 00		lda $00,x			lda 	EXSValueL+0,x 				; pre-increment as we start indices at 1.
.0111a1	1a		inc a				inc 	a
.0111a2	95 00		sta $00,x			sta 	EXSValueL+0,x
.0111a4	b2 08		lda ($08)			lda 	(DTemp1) 					; characters to match
.0111a6	29 ff 00	and #$00ff			and 	#$00FF
.0111a9	a8		tay				tay									; start comparing at index 1.
.0111aa					_FINSCompare:
.0111aa	b1 08		lda ($08),y			lda 	(DTemp1),y 					; char match ?
.0111ac	51 0c		eor ($0c),y			eor 	(DTemp2),y
.0111ae	29 ff 00	and #$00ff			and 	#$00FF
.0111b1	d0 05		bne $0111b8			bne 	_FINSNext
.0111b3	88		dey				dey
.0111b4	d0 f4		bne $0111aa			bne 	_FINSCompare
.0111b6	80 08		bra $0111c0			bra 	_FINSExit
.0111b8					_FINSNext:
.0111b8	e6 0c		inc $0c				inc 	DTemp2 						; bump pointer in string being searched
.0111ba	c6 24		dec $24				dec 	DTemp3 						; keep trying this many times
.0111bc	d0 e1		bne $01119f			bne 	_FINSLoop
.0111be					_FINSFail:
.0111be	74 00		stz $00,x			stz 	EXSValueL+0,x 				; return 0
.0111c0					_FINSExit:
.0111c0	60		rts				rts
.0111c1					_FINSError:
.0111c1	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>0111c4	4e 6f 20 53 65 61 72 63				.text 	"No Search String",$00 								; with this message
>0111cc	68 20 53 74 72 69 6e 67 00

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/unary/caseconv.asm

.0111d5					Function_UPPER:
.0111d5	20 31 06	jsr $010631			jsr 	ResetTypeString 			; returns a string.
.0111d8	20 45 03	jsr $010345			jsr 	EvaluateNextString 			; evaluate a string.
.0111db	48		pha				pha
.0111dc	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket 			; close call.
.0111df	20 1e 07	jsr $01071e			jsr		StringTempAllocate 			; allocate memory for it
.0111e2	68		pla				pla
.0111e3	20 5c 07	jsr $01075c			jsr 	StringCreateCopy 			; create a copy of it.
.0111e6	a5 18		lda $18				lda 	DStartTempString 			; A = start of temporary string.
.0111e8	95 00		sta $00,x			sta 	EXSValueL+0,x
.0111ea	a8		tay				tay 								; address in Y
.0111eb	74 02		stz $02,x			stz 	EXSValueH+0,x
.0111ed	da		phx				phx 								; save X
.0111ee	b2 18		lda ($18)			lda 	(DStartTempString)			; get string length
.0111f0	29 ff 00	and #$00ff			and 	#$00FF
.0111f3	f0 20		beq $011215			beq 	_FUPExit
.0111f5	aa		tax				tax 								; put in X
.0111f6					_FUPLoop:
.0111f6	c8		iny				iny 								; increment and load character
.0111f7	b9 00 00	lda $0000,y			lda 	$0000,y
.0111fa	29 ff 00	and #$00ff			and 	#$00FF
.0111fd	c9 61 00	cmp #$0061			cmp 	#"a" 						; check range
.011200	90 10		bcc $011212			bcc 	_FUPNoChange
.011202	c9 7b 00	cmp #$007b			cmp 	#"z"+1
.011205	b0 0b		bcs $011212			bcs 	_FUPNoChange
.011207	38		sec				sec 								; shift case
.011208	e9 20 00	sbc #$0020			sbc 	#32
.01120b	e2 20		sep #$20			sep 	#$20 						; write back
.01120d	99 00 00	sta $0000,y			sta 	$0000,y
.011210	c2 20		rep #$20			rep 	#$20
.011212					_FUPNoChange:
.011212	ca		dex				dex 								; do X times
.011213	d0 e1		bne $0111f6			bne 	_FUPLoop
.011215					_FUPExit:
.011215	fa		plx				plx 								; restore X
.011216	60		rts				rts
.011217					Function_LOWER:
.011217	20 31 06	jsr $010631			jsr 	ResetTypeString 			; returns a string.
.01121a	20 45 03	jsr $010345			jsr 	EvaluateNextString 			; evaluate a string.
.01121d	48		pha				pha
.01121e	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket 			; close call.
.011221	20 1e 07	jsr $01071e			jsr		StringTempAllocate 			; allocate memory for it
.011224	68		pla				pla
.011225	20 5c 07	jsr $01075c			jsr 	StringCreateCopy 			; create a copy of it.
.011228	a5 18		lda $18				lda 	DStartTempString 			; A = start of temporary string.
.01122a	95 00		sta $00,x			sta 	EXSValueL+0,x
.01122c	a8		tay				tay 								; address in Y
.01122d	74 02		stz $02,x			stz 	EXSValueH+0,x
.01122f	da		phx				phx 								; save X
.011230	b2 18		lda ($18)			lda 	(DStartTempString)			; get string length
.011232	29 ff 00	and #$00ff			and 	#$00FF
.011235	f0 20		beq $011257			beq 	_FLOExit
.011237	aa		tax				tax 								; put in X
.011238					_FLOLoop:
.011238	c8		iny				iny 								; increment and load character
.011239	b9 00 00	lda $0000,y			lda 	$0000,y
.01123c	29 ff 00	and #$00ff			and 	#$00FF
.01123f	c9 41 00	cmp #$0041			cmp 	#"A" 						; check range
.011242	90 10		bcc $011254			bcc 	_FLONoChange
.011244	c9 5b 00	cmp #$005b			cmp 	#"Z"+1
.011247	b0 0b		bcs $011254			bcs 	_FLONoChange
.011249	18		clc				clc 								; shift case
.01124a	69 20 00	adc #$0020			adc 	#32
.01124d	e2 20		sep #$20			sep 	#$20 						; write back
.01124f	99 00 00	sta $0000,y			sta 	$0000,y
.011252	c2 20		rep #$20			rep 	#$20
.011254					_FLONoChange:
.011254	ca		dex				dex 								; do X times
.011255	d0 e1		bne $011238			bne 	_FLOLoop
.011257					_FLOExit:
.011257	fa		plx				plx 								; restore X
.011258	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/let.asm

.011259					Command_Let:
.011259	b2 06		lda ($06)			lda 	(DCodePtr)					; get the first token, for typing.
.01125b	48		pha				pha  								; save on stack for later.
.01125c	20 9a 03	jsr $01039a			jsr 	VariableFind 				; find the variable
.01125f	85 1e		sta $1e				sta 	DVariablePtr 				; save where it is.
.011261	b0 0c		bcs $01126f			bcs 	_FLetFound 					; skip if found.
.011263	68		pla				pla 								; get and push the first token again.
.011264	48		pha				pha
.011265	29 00 10	and #$1000			and 	#IDArrayMask 				; if it is an array, you can't autoinstantiate it, you have to DIM it.
.011268	d0 52		bne $0112bc			bne 	_FLError					; arrays, so this causes an error.
.01126a	20 4d 04	jsr $01044d			jsr 	VariableCreate 				; create it as a single variable.
.01126d	85 1e		sta $1e				sta 	DVariablePtr 				; save the data address.
.01126f					_FLetFound:
.01126f	68		pla				pla 								; get and save the first token.
.011270	48		pha				pha
.011271	29 00 10	and #$1000			and 	#IDArrayMask				; is it an array ?
.011274	f0 0a		beq $011280			beq 	_FLetNotArray
.011276	a2 00 02	ldx #$0200			ldx		#EXSBase 					; in LET, so do it from the base stack.
.011279	a5 1e		lda $1e				lda 	DVariablePtr 				; variable pointer into A, first token in A
.01127b	20 11 04	jsr $010411			jsr 	VariableSubscript			; index calculation
.01127e	85 1e		sta $1e				sta 	DVariablePtr 				; and write it back.
.011280					_FLetNotArray:
.011280	7a		ply				ply 								; get the first token into Y
.011281	a5 1e		lda $1e				lda 	DVariablePtr 				; save the target address on the stack.
.011283	48		pha				pha
.011284	5a		phy				phy 								; save the first token on the stack.
.011285	a9 06 22	lda #$2206			lda 	#equalTokenID 				; check the = and skip it.
.011288	d2 06		cmp ($06)			cmp 	(DCodePtr)
.01128a	d0 23		bne $0112af			bne 	_FLetMissingEquals
.01128c	e6 06		inc $06				inc 	DCodePtr
.01128e	e6 06		inc $06				inc 	DCodePtr
.011290	68		pla				pla 								; restore the first token.
.011291	29 00 20	and #$2000			and 	#IDTypeMask 				; check the type bit
.011294	d0 0f		bne $0112a5			bne 	_FLetString 				; skip if string.
.011296	20 0d 03	jsr $01030d			jsr 	EvaluateInteger 			; get an integer
.011299	7a		ply				ply 								; get address in Y
.01129a	b5 00		lda $00,x			lda 	EXSValueL+0,x				; get the low word.
.01129c	99 00 00	sta $0000,y			sta 	$0000,y 					; save in variable low.
.01129f	b5 02		lda $02,x			lda 	EXSValueH+0,x 				; get the high word.
.0112a1	99 02 00	sta $0002,y			sta 	$0002,y 					; save that
.0112a4	60		rts				rts
.0112a5					_FLetString:
.0112a5	20 2c 03	jsr $01032c			jsr 	EvaluateString 				; get a string.
.0112a8	b5 00		lda $00,x			lda 	EXSValueL+0,x				; get the low word, the address
.0112aa	7a		ply				ply 								; get address we are overwriting in Y - this is the
.0112ab	20 7a 06	jsr $01067a			jsr 	StringAssign 				; assign the string in memory.
.0112ae	60		rts				rts
.0112af					_FLetMissingEquals:
.0112af	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>0112b2	4d 69 73 73 69 6e 67 20				.text 	"Missing =",$00 								; with this message
>0112ba	3d 00
.0112bc					_FLError:
.0112bc	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>0112bf	55 6e 64 65 66 69 6e 65				.text 	"Undefined array",$00 								; with this message
>0112c7	64 20 61 72 72 61 79 00

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/procedure.asm

.0112cf					Command_PROC:
.0112cf	a9 00 02	lda #$0200			lda 	#Block_ProgramStart 		; go to start of program
.0112d2	18		clc				clc
.0112d3	65 02		adc $02				adc 	DBaseAddress
.0112d5	aa		tax				tax 								; X is used to track it
.0112d6					_FPROLoop:
.0112d6	bd 00 00	lda $0000,x			lda 	@w$0000,x 					; is the link zero
.0112d9	f0 62		beq $01133d			beq 	_FPROUnknown
.0112db	bd 04 00	lda $0004,x			lda 	@w$0004,x 					; does it begin with DEFPROC
.0112de	c9 48 3c	cmp #$3c48			cmp 	#defprocTokenID
.0112e1	f0 08		beq $0112eb			beq 	_FPROFoundDefProc
.0112e3					_FPRONext:
.0112e3	8a		txa				txa 								; follow the link.
.0112e4	18		clc				clc
.0112e5	7d 00 00	adc $0000,x			adc 	@w$0000,x
.0112e8	aa		tax				tax
.0112e9	80 eb		bra $0112d6			bra 	_FPROLoop
.0112eb					_FPROFoundDefProc:
.0112eb	bd 06 00	lda $0006,x			lda 	@w$0006,x 					; compare the first tokens.
.0112ee	d2 06		cmp ($06)			cmp 	(DCodePtr)
.0112f0	d0 f1		bne $0112e3			bne 	_FPRONext
.0112f2	8a		txa				txa 								; DTemp1 points to the token.
.0112f3	18		clc				clc
.0112f4	69 06 00	adc #$0006			adc 	#6
.0112f7	85 08		sta $08				sta 	DTemp1
.0112f9	a0 00 00	ldy #$0000			ldy 	#0
.0112fc					_FPROCompare:
.0112fc	b1 08		lda ($08),y			lda 	(DTemp1),y
.0112fe	d1 06		cmp ($06),y			cmp 	(DCodePtr),y
.011300	d0 e1		bne $0112e3			bne 	_FPRONext 					; fails, different
.011302	c8		iny				iny
.011303	c8		iny				iny
.011304	29 00 08	and #$0800			and 	#IDContMask 				; while there's more to test
.011307	d0 f3		bne $0112fc			bne 	_FPROCompare
.011309	98		tya				tya 								; this is the offset to the next element
.01130a	18		clc				clc
.01130b	65 08		adc $08				adc 	DTemp1
.01130d	48		pha				pha 								; push the next command on the stack
.01130e	da		phx				phx 								; push the record address on the stack.
.01130f	a6 2a		ldx $2a				ldx 	DStack 						; point Y to the stack.
.011311	98		tya				tya 								; work out the return address
.011312	18		clc				clc
.011313	65 06		adc $06				adc 	DCodePtr
.011315	95 02		sta $02,x			sta 	$02,x 						; save pos at +2
.011317	a5 22		lda $22				lda 	DLineNumber 				; save line number at +4
.011319	95 04		sta $04,x			sta 	$04,x
.01131b	a9 41 3e	lda #$3e41			lda 	#procTokenID 				; save proc token at +6
.01131e	95 06		sta $06,x			sta 	$06,x
.011320	8a		txa				txa 								; advance stack by 6.
.011321	18		clc				clc
.011322	69 06 00	adc #$0006			adc 	#6
.011325	85 2a		sta $2a				sta 	DStack
.011327	7a		ply				ply 								; line record address
.011328	b9 02 00	lda $0002,y			lda 	$0002,y 					; get line number
.01132b	85 22		sta $22				sta 	DLineNumber
.01132d	68		pla				pla 								; next command
.01132e	85 06		sta $06				sta 	DCodePtr
.011330	a4 06		ldy $06				ldy 	DCodePtr 					; get the new code address, the address after  DEFPROC x
.011332	88		dey				dey 								; get the previous token
.011333	88		dey				dey
.011334	b9 00 00	lda $0000,y			lda 	$0000,y 					; read the token
.011337	29 00 10	and #$1000			and 	#IDArrayMask 				; is it a function call - e.g. an array type ?
.01133a	d0 16		bne $011352			bne 	_FPROParameter				; if not, set up the parameters.
.01133c	60		rts				rts
.01133d					_FPROUnknown:
.01133d	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>011340	55 6e 6b 6e 6f 77 6e 20				.text 	"Unknown procedure",$00 								; with this message
>011348	70 72 6f 63 65 64 75 72 65 00
.011352					_FPROParameter:
.011352	a5 06		lda $06				lda	 	DCodePtr 					; save code pointer
.011354	48		pha				pha
.011355	a5 2a		lda $2a				lda 	DStack 						; get the stack.
.011357	38		sec				sec
.011358	e9 04 00	sbc #$0004			sbc 	#4 							; this is the address of that return value
.01135b	48		pha				pha 								; save that on the stack.
.01135c	aa		tax				tax
.01135d	b5 00		lda $00,x			lda 	$00,x 						; get that return address
.01135f	85 06		sta $06				sta 	DCodePtr 					; and set up the code pointer.
.011361	a2 60 02	ldx #$0260			ldx 	#PRMBuffer 					; X points to the parameter buffer.
.011364					_FPROGetValues:
.011364	da		phx				phx 								; save X
.011365	20 01 02	jsr $010201			jsr 	Evaluate 					; Evaluate into YA, type into CS.
.011368	fa		plx				plx 								; restore X
.011369	95 00		sta $00,x			sta 	$00,x 						; save value
.01136b	98		tya				tya
.01136c	95 10		sta $10,x			sta 	$10,x
.01136e	a9 00 00	lda #$0000			lda 	#0 							; get the carry into A, so 0=int,1=string
.011371	2a		rol a				rol 	a
.011372	95 20		sta $20,x			sta 	$20,x 						; write into type slot.
.011374	e8		inx				inx 								; next entry into parameter table.
.011375	e8		inx				inx
.011376	b2 06		lda ($06)			lda 	(DCodePtr) 					; get next token and skip it
.011378	e6 06		inc $06				inc 	DCodePtr
.01137a	e6 06		inc $06				inc 	DCodePtr
.01137c	c9 24 32	cmp #$3224			cmp 	#commaTokenID 				; if comma, another parameter.
.01137f	f0 e3		beq $011364			beq 	_FPROGetValues
.011381	c9 28 32	cmp #$3228			cmp 	#rParenTokenID 				; if not right bracket, then error.
.011384	d0 5c		bne $0113e2			bne 	_FPROSyntax
.011386	a9 ff ff	lda #$ffff			lda 	#$FFFF 						; store -1 in the next type slot.
.011389	95 20		sta $20,x			sta 	$20,x 						; marks the end of the parameters.
.01138b	fa		plx				plx 								; address of return address
.01138c	a5 06		lda $06				lda 	DCodePtr 					; write return address back.
.01138e	95 00		sta $00,x			sta 	$00,x
.011390	68		pla				pla 								; restore old code pointer (the parameter addresses)
.011391	85 06		sta $06				sta 	DCodePtr
.011393					_FPROSetupParameters:
.011393	a2 60 02	ldx #$0260			ldx 	#PRMBuffer 					; start of buffer.
.011396					_FPROSetupLoop:
.011396	b5 20		lda $20,x			lda 	$20,x 						; get the type
.011398	d0 14		bne $0113ae			bne 	_FPROSetupString
.01139a	da		phx				phx 								; localise variable, preserving X.
.01139b	20 2b 14	jsr $01142b			jsr 	LocalProcessVariable
.01139e	fa		plx				plx
.01139f	b0 2b		bcs $0113cc			bcs 	_FPROTypeError 				; must be integer variable.
.0113a1	a8		tay				tay  								; target address in Y.
.0113a2	b5 00		lda $00,x			lda 	$00,x 						; copy data
.0113a4	99 00 00	sta $0000,y			sta 	$0000,y
.0113a7	b5 10		lda $10,x			lda 	$10,x
.0113a9	99 02 00	sta $0002,y			sta 	$0002,y
.0113ac	80 0f		bra $0113bd			bra 	_FPRONextParameterValue
.0113ae					_FPROSetupString:
.0113ae	da		phx				phx 								; localise variable, preserving X.
.0113af	20 2b 14	jsr $01142b			jsr 	LocalProcessVariable
.0113b2	fa		plx				plx
.0113b3	90 17		bcc $0113cc			bcc 	_FPROTypeError 				; must be integer variable.
.0113b5	a8		tay				tay  								; target address in Y.
.0113b6	b5 00		lda $00,x			lda 	$00,x 						; address of new string in A
.0113b8	da		phx				phx 								; preserve X.
.0113b9	20 7a 06	jsr $01067a			jsr 	StringAssign 				; assign the string using the function used by LET.
.0113bc	fa		plx				plx
.0113bd					_FPRONextParameterValue:
.0113bd	e8		inx				inx 								; next parameter in parameter table.
.0113be	e8		inx				inx
.0113bf	b5 20		lda $20,x			lda 	$20,x 						; type of next
.0113c1	30 05		bmi $0113c8			bmi 	_FPROComplete 				; if -ve then we have assigned everything.
.0113c3	20 00 06	jsr $010600			jsr 	ExpectComma 				; expect a comma
.0113c6	80 ce		bra $011396			bra 	_FPROSetupLoop 				; and do the next one.
.0113c8					_FPROComplete:
.0113c8	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket 			; the right bracket closing the parameter list
.0113cb	60		rts				rts
.0113cc					_FPROTypeError:
.0113cc	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>0113cf	42 61 64 20 70 61 72 61				.text 	"Bad parameter type",$00 								; with this message
>0113d7	6d 65 74 65 72 20 74 79 70 65 00
.0113e2					_FPROSyntax:
.0113e2	82 d7 f1	brl $0105bc			brl 	SyntaxError
.0113e5					Command_ENDPROC:
.0113e5	20 a9 14	jsr $0114a9			jsr 	LocalRestore 				; restore any local variables.
.0113e8	a6 2a		ldx $2a				ldx 	DStack						; what's on the top of the stack.
.0113ea	b5 00		lda $00,x			lda 	$00,x
.0113ec	c9 41 3e	cmp #$3e41			cmp 	#procTokenID 				; check top token.
.0113ef	d0 11		bne $011402			bne 	_FENPFail
.0113f1	8a		txa				txa 								; unpick stack.
.0113f2	38		sec				sec
.0113f3	e9 06 00	sbc #$0006			sbc 	#6
.0113f6	85 2a		sta $2a				sta 	DStack
.0113f8	aa		tax				tax
.0113f9	b5 02		lda $02,x			lda 	$02,x 						; copy code pointer out.
.0113fb	85 06		sta $06				sta 	DCodePtr
.0113fd	b5 04		lda $04,x			lda 	$04,x 						; copy line number out
.0113ff	85 22		sta $22				sta 	DLineNumber
.011401	60		rts				rts
.011402					_FENPFail:
.011402	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>011405	45 6e 64 50 72 6f 63 20				.text 	"EndProc without Proc",$00 								; with this message
>01140d	77 69 74 68 6f 75 74 20 50 72 6f 63 00

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/local.asm

.01141a					Command_LOCAL:
.01141a	20 2b 14	jsr $01142b			jsr 	LocalProcessVariable 		; make one variable 'local'
.01141d	b2 06		lda ($06)			lda 	(DCodePtr) 					; look at next character
.01141f	c9 24 32	cmp #$3224			cmp 	#commaTokenID 				; exit if not comma
.011422	d0 06		bne $01142a			bne 	_CLOExit
.011424	e6 06		inc $06				inc 	DCodePtr 					; skip comma and get next variable
.011426	e6 06		inc $06				inc 	DCodePtr
.011428	80 f0		bra $01141a			bra 	Command_Local
.01142a					_CLOExit:
.01142a	60		rts				rts
.01142b					LocalProcessVariable:
.01142b	b2 06		lda ($06)			lda 	(DCodePtr)					; check it is an identifier and not an array
.01142d	c9 00 c0	cmp #$c000			cmp 	#$C000
.011430	90 5f		bcc $011491			bcc 	_LPVFail
.011432	29 00 10	and #$1000			and 	#IDArrayMask
.011435	d0 5a		bne $011491			bne 	_LPVFail
.011437	b2 06		lda ($06)			lda 	(DCodePtr) 					; get type
.011439	48		pha				pha 								; save on stack.
.01143a	20 9a 03	jsr $01039a			jsr 	VariableFind 				; find a variable
.01143d	b0 03		bcs $011442			bcs 	_LPVFound
.01143f	20 4d 04	jsr $01044d			jsr 	VariableCreate 				; create it if it doesn't exist.
.011442					_LPVFound:
.011442	a8		tay				tay 								; variable address in Y
.011443	68		pla				pla 								; get the type back
.011444	29 00 20	and #$2000			and 	#IDTypeMask 				; identify it
.011447	d0 1e		bne $011467			bne 	_LPVStringPush 				; if string, push that on the stack.
.011449	a6 2a		ldx $2a				ldx 	DStack
.01144b	b9 00 00	lda $0000,y			lda 	$0000,y 					; get LSW and write
.01144e	95 02		sta $02,x			sta 	$02,x
.011450	b9 02 00	lda $0002,y			lda 	$0002,y 					; get MSW and write
.011453	95 04		sta $04,x			sta 	$04,x
.011455	98		tya				tya 								; write address.
.011456	95 06		sta $06,x			sta 	$06,x
.011458	a9 00 c0	lda #$c000			lda 	#$C000 						; write $C000 marker.
.01145b	95 08		sta $08,x			sta 	$08,x
.01145d	8a		txa				txa 								; shift to top of stack.
.01145e	18		clc				clc
.01145f	69 08 00	adc #$0008			adc 	#8
.011462	85 2a		sta $2a				sta 	DStack
.011464	98		tya				tya 								; return address of variable data.
.011465	18		clc				clc
.011466	60		rts				rts
.011467					_LPVStringPush:
.011467	b9 00 00	lda $0000,y			lda 	$0000,y 					; if uninitialised then leave it like that.
.01146a	f0 22		beq $01148e			beq		_LPVExit
.01146c	5a		phy				phy 								; save storage address on stack.
.01146d	85 08		sta $08				sta 	DTemp1 						; address of physical string.
.01146f	a6 2a		ldx $2a				ldx 	DStack 						; get stack.
.011471	e8		inx				inx 								; point to free stack byte.
.011472	e8		inx				inx
.011473	b2 08		lda ($08)			lda 	(DTemp1) 					; get length of string.
.011475	29 ff 00	and #$00ff			and 	#$00FF
.011478	a8		tay				tay 								; copy backwards
.011479					_LPVPushOut:
.011479	b1 08		lda ($08),y			lda 	(DTemp1),y 					; copy byte at a time. just do words :)
.01147b	95 00		sta $00,x			sta 	$00,x
.01147d	e8		inx				inx
.01147e	88		dey				dey
.01147f	10 f8		bpl $011479			bpl 	_LPVPushOut 				; push one extra because of length byte.
.011481	68		pla				pla 								; write out the address of the storage.
.011482	a8		tay				tay 								; save it in Y
.011483	95 00		sta $00,x			sta 	$00,x 						; (e.g. this address has the physical string address)
.011485	a9 00 e0	lda #$e000			lda 	#$E000 						; write $E000 out.
.011488	95 02		sta $02,x			sta 	$02,x
.01148a	e8		inx				inx
.01148b	e8		inx				inx
.01148c	86 2a		stx $2a				stx 	DStack 						; save $E000 marker
.01148e					_LPVExit:
.01148e	98		tya				tya  								; return address of marker.
.01148f	38		sec				sec
.011490	60		rts				rts
.011491					_LPVFail:
.011491	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>011494	42 61 64 20 4c 6f 63 61				.text 	"Bad Local Identifier",$00 								; with this message
>01149c	6c 20 49 64 65 6e 74 69 66 69 65 72 00
.0114a9					LocalRestore:
.0114a9	a6 2a		ldx $2a				ldx 	DStack 						; access basic stack.
.0114ab	b5 00		lda $00,x			lda 	$00,x 						; read top word.
.0114ad	c9 00 c0	cmp #$c000			cmp 	#$C000 						; $C000-$FFFF indicates stacked local/parameter
.0114b0	f0 03		beq $0114b5			beq 	_LRIntegerPull 				; $C000 unstack integer
.0114b2	b0 18		bcs $0114cc			bcs 	_LRString 					; $C001-$FFFF unstack string
.0114b4	60		rts				rts
.0114b5					_LRIntegerPull:
.0114b5	8a		txa				txa 								; pull 8 bytes off stack.
.0114b6	38		sec				sec
.0114b7	e9 08 00	sbc #$0008			sbc 	#8
.0114ba	85 2a		sta $2a				sta 	DStack
.0114bc	aa		tax				tax 								; put in X
.0114bd	b5 06		lda $06,x			lda 	$06,x 						; get address to restore
.0114bf	a8		tay				tay
.0114c0	b5 02		lda $02,x			lda 	$02,x 						; restore MSW
.0114c2	99 00 00	sta $0000,y			sta 	@w$0000,y
.0114c5	b5 04		lda $04,x			lda 	$04,x 						; and LSW
.0114c7	99 02 00	sta $0002,y			sta 	@w$0002,y
.0114ca	80 dd		bra $0114a9			bra 	LocalRestore 				; and try again.
.0114cc					_LRString:
.0114cc	ca		dex				dex									; access the address
.0114cd	ca		dex				dex
.0114ce	b5 00		lda $00,x			lda 	$00,x 						; the address of the storage address
.0114d0	a8		tay				tay
.0114d1	b9 00 00	lda $0000,y			lda 	$0000,y 					; the actual storage address
.0114d4	85 08		sta $08				sta 	DTemp1 						; save so we can write to it.
.0114d6	ca		dex				dex 								; length is the next byte.
.0114d7	b5 00		lda $00,x			lda 	$00,x 						; so get the length
.0114d9	29 ff 00	and #$00ff			and 	#$00FF 						; mask it off
.0114dc	a8		tay				tay 								; count in Y
.0114dd					_LRRecover:
.0114dd	b5 00		lda $00,x			lda 	$00,x 						; extract and write bytes
.0114df	e2 20		sep #$20			sep 	#$20
.0114e1	92 08		sta ($08)			sta 	(DTemp1)
.0114e3	c2 20		rep #$20			rep 	#$20
.0114e5	ca		dex				dex 								; stack backwards
.0114e6	e6 08		inc $08				inc 	DTemp1 						; pointer forwards
.0114e8	88		dey				dey 								; do Y+1 times.
.0114e9	10 f2		bpl $0114dd			bpl 	_LRRecover
.0114eb	ca		dex				dex 								; stack should now point to next token
.0114ec	86 2a		stx $2a				stx 	DStack
.0114ee	80 b9		bra $0114a9			bra 	LocalRestore 				; and try again.

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/list.asm

.0114f0					Command_List:
.0114f0	a9 ff 00	lda #$00ff		lda 	#255 							; create a buffer to use.
.0114f3	20 1e 07	jsr $01071e		jsr 	StringTempAllocate
.0114f6	85 30		sta $30			sta 	DListBuffer						; save buffer.
.0114f8	64 2c		stz $2c			stz 	DIndent 						; reset the indents
.0114fa	64 2e		stz $2e			stz 	DIndent2
.0114fc	64 32		stz $32			stz 	DTemp4+0 						; low number
.0114fe	a9 ff 7f	lda #$7fff		lda 	#$7FFF
.011501	85 34		sta $34			sta 	DTemp4+2 						; high number.
.011503	b2 06		lda ($06)		lda 	(DCodePtr)						; anything else ?
.011505	f0 3b		beq $011542		beq 	_CLIList
.011507	c9 26 32	cmp #$3226		cmp 	#colonTokenID
.01150a	f0 36		beq $011542		beq 	_CLIList
.01150c	c9 24 32	cmp #$3224		cmp 	#commaTokenID 					; is it , something.
.01150f	f0 13		beq $011524		beq 	_CLIComma
.011511	20 26 03	jsr $010326		jsr 	EvaluateNextInteger 			; yes, first number
.011514	c0 00 00	cpy #$0000		cpy 	#0
.011517	d0 21		bne $01153a		bne 	_CLIError
.011519	85 32		sta $32			sta 	DTemp4+0 						; which becomes the first and the last :)
.01151b	85 34		sta $34			sta 	DTemp4+2
.01151d	b2 06		lda ($06)		lda 	(DCodePtr) 						; , follows ?
.01151f	c9 24 32	cmp #$3224		cmp 	#commaTokenID
.011522	d0 1e		bne $011542		bne 	_CLIList
.011524					_CLIComma:
.011524	20 00 06	jsr $010600		jsr 	ExpectComma 					; skip comma
.011527	b2 06		lda ($06)		lda 	(DCodePtr)
.011529	f0 12		beq $01153d		beq 	_CLIToEnd 						; if $0000 or :, then list to end.
.01152b	c9 26 32	cmp #$3226		cmp 	#colonTokenID
.01152e	f0 0d		beq $01153d		beq 	_CLIToEnd
.011530	20 26 03	jsr $010326		jsr 	EvaluateNextInteger 			; get end line.
.011533	85 34		sta $34			sta 	DTemp4+2
.011535	c0 00 00	cpy #$0000		cpy 	#0 								; if legal continue.
.011538	f0 08		beq $011542		beq 	_CLIList
.01153a					_CLIError:
.01153a	82 7f f0	brl $0105bc		brl 	SyntaxError
.01153d					_CLIToEnd:
.01153d	a9 ff 7f	lda #$7fff		lda 	#$7FFF
.011540	85 34		sta $34			sta 	DTemp4+2
.011542					_CLIList:
.011542	a9 00 02	lda #$0200		lda 	#Block_ProgramStart 			; work out program start.
.011545	18		clc			clc
.011546	65 02		adc $02			adc 	DBaseAddress
.011548	a8		tay			tay 									; put in Y
.011549					_CLINextLine:
.011549	b9 00 00	lda $0000,y		lda 	$0000,y 						; check end of program
.01154c	f0 29		beq $011577		beq 	_CLIExit
.01154e	20 df 16	jsr $0116df		jsr 	ScanIndent  					; scan for formatting.
.011551	b9 02 00	lda $0002,y		lda 	$0002,y 						; get line number.
.011554	c5 32		cmp $32			cmp 	DTemp4+0 						; check if it is in range.
.011556	90 14		bcc $01156c		bcc 	_CLIFollowLink
.011558	c5 34		cmp $34			cmp 	DTemp4+2
.01155a	f0 02		beq $01155e		beq 	_CLIShowLine
.01155c	b0 0e		bcs $01156c		bcs 	_CLIFollowLink
.01155e					_CLIShowLine:
.01155e	a5 30		lda $30			lda 	DListBuffer
.011560	20 7a 15	jsr $01157a		jsr 	Detokenise 						; detokenise it
.011563	5a		phy			phy
.011564	a8		tay			tay 									; print buffer out
.011565	20 57 06	jsr $010657		jsr 	PrintBasicString
.011568	20 6f 1e	jsr $011e6f		jsr 	HWNewLine
.01156b	7a		ply			ply 									; get address
.01156c					_CLIFollowLink:
.01156c	98		tya			tya 									; follow link
.01156d	18		clc			clc
.01156e	79 00 00	adc $0000,y		adc 	$0000,y
.011571	a8		tay			tay
.011572	20 8b 1e	jsr $011e8b		jsr 	HWCheckBreak 					; break key pressed.
.011575	f0 d2		beq $011549		beq 	_CLINextLine
.011577					_CLIExit:
.011577	64 2c		stz $2c			stz 	DIndent 						; reset the indent
.011579	60		rts			rts
.01157a					Detokenise:
.01157a	48		pha			pha
.01157b	da		phx			phx
.01157c	5a		phy			phy
.01157d	85 18		sta $18			sta 	DStartTempString 				; set the temp Command pointers to this buffer
.01157f	1a		inc a			inc 	a
.011580	85 1a		sta $1a			sta 	DCurrentTempString
.011582	64 1c		stz $1c			stz		DConstantShift
.011584	a9 00 00	lda #$0000		lda 	#$0000 							; write zero, clearing the string size.
.011587	92 18		sta ($18)		sta 	(DStartTempString)
.011589	5a		phy			phy 									; save Y
.01158a	b9 02 00	lda $0002,y		lda 	$0002,y 						; read the line number.
.01158d	a0 00 00	ldy #$0000		ldy 	#$0000 							; the high byte is 0
.011590	a2 0a 00	ldx #$000a		ldx 	#10 							; in BASE 10.
.011593	20 d1 10	jsr $0110d1		jsr 	ConvertToStringAlreadyAllocated	; convert to string in situ.
.011596	a5 2c		lda $2c			lda 	DIndent 						; work out indent, which is the smaller of this/last
.011598	c5 2e		cmp $2e			cmp 	DIndent2
.01159a	90 02		bcc $01159e		bcc 	_DTKSmaller
.01159c	a5 2e		lda $2e			lda 	DIndent2
.01159e					_DTKSmaller:
.01159e	0a		asl a			asl 	a
.01159f	69 06 00	adc #$0006		adc 	#6
.0115a2	85 08		sta $08			sta 	DTemp1
.0115a4					_DTKPadLineNo:
.0115a4	a9 20 00	lda #$0020		lda 	#32 							; pad out to 6+indent*2 characters.
.0115a7	20 4e 07	jsr $01074e		jsr 	StringWriteCharacter
.0115aa	b2 18		lda ($18)		lda 	(DStartTempString)
.0115ac	29 ff 00	and #$00ff		and 	#$00FF
.0115af	c5 08		cmp $08			cmp 	DTemp1
.0115b1	d0 f1		bne $0115a4		bne 	_DTKPadLineNo
.0115b3	68		pla			pla 									; get pointer
.0115b4	18		clc			clc 									; point to start of line
.0115b5	69 04 00	adc #$0004		adc 	#4
.0115b8	a8		tay			tay 									; put back in Y.
.0115b9					_DTKMainLoop:
.0115b9	b9 00 00	lda $0000,y		lda 	$0000,y 						; look at first token.
.0115bc	d0 04		bne $0115c2		bne 	_DTKNotZero 					; if zero, return.
.0115be	7a		ply			ply
.0115bf	fa		plx			plx
.0115c0	68		pla			pla
.0115c1	60		rts			rts
.0115c2					_DTKNotZero:
.0115c2	c9 00 01	cmp #$0100		cmp 	#$0100 							; is it a quoted string $0000-$00FF
.0115c5	b0 1c		bcs $0115e3		bcs 	_DTKNotString
.0115c7	5a		phy			phy										; save token address on stack.
.0115c8	c8		iny			iny 									; skip first token
.0115c9	c8		iny			iny
.0115ca	a9 22 00	lda #$0022		lda 	#34 							; write out opening quote
.0115cd	20 4e 07	jsr $01074e		jsr 	StringWriteCharacter
.0115d0	98		tya			tya 									; copy the string out.
.0115d1	20 5c 07	jsr $01075c		jsr 	StringCreateCopy
.0115d4	a9 22 00	lda #$0022		lda 	#34 							; write out closing quote
.0115d7	20 4e 07	jsr $01074e		jsr 	StringWriteCharacter
.0115da	68		pla			pla 									; get token, which is its own offset
.0115db	a8		tay			tay
.0115dc	18		clc			clc
.0115dd	79 00 00	adc $0000,y		adc 	$0000,y
.0115e0	a8		tay			tay
.0115e1	80 d6		bra $0115b9		bra 	_DTKMainLoop
.0115e3					_DTKNotString:
.0115e3	c9 00 20	cmp #$2000		cmp 	#$2000							; if $1000-$1FFF then constant shift
.0115e6	b0 09		bcs $0115f1		bcs 	_DTKNotShift
.0115e8	29 ff 0f	and #$0fff		and 	#$0FFF 							; store in shift
.0115eb	85 1c		sta $1c			sta 	DConstantShift
.0115ed	c8		iny			iny 									; skip token.
.0115ee	c8		iny			iny
.0115ef	80 c8		bra $0115b9		bra 	_DTKMainLoop
.0115f1					_DTKNotShift:
.0115f1	c9 00 40	cmp #$4000		cmp 	#$4000 							; if $2000-$3FFF it's a token.
.0115f4	b0 07		bcs $0115fd		bcs 	_DTKNotKeyword
.0115f6	c8		iny			iny 									; skip over token
.0115f7	c8		iny			iny
.0115f8	20 77 16	jsr $011677		jsr 	_DTKDecodeKeyword 				; decode it.
.0115fb	80 bc		bra $0115b9		bra 	_DTKMainLoop
.0115fd					_DTKNotKeyword:
.0115fd	c9 00 c0	cmp #$c000		cmp 	#$C000							; if $4000-$BFFF it's a (possibly shifted) constant.
.011600	b0 18		bcs $01161a		bcs 	_DTKIdentifier 					; if $C000-$CFFF it's an identifier.
.011602	5a		phy			phy 									; save pointer
.011603	38		sec			sec  									; shift it in the range 0-32767
.011604	e9 00 40	sbc #$4000		sbc 	#$4000
.011607	0a		asl a			asl 	a 								; shift it left, losing bit 15
.011608	46 1c		lsr $1c			lsr 	DConstantShift 					; shift constant right into carry.
.01160a	6a		ror a			ror 	a 								; rotate that into the constant value
.01160b	a4 1c		ldy $1c			ldy 	DConstantShift 					; YA number
.01160d	a2 0a 00	ldx #$000a		ldx 	#10 							; output base.
.011610	20 d1 10	jsr $0110d1		jsr 	ConvertToStringAlreadyAllocated	; convert to string in situ.
.011613	64 1c		stz $1c			stz 	DConstantShift
.011615	7a		ply			ply 									; restore pointer
.011616	c8		iny			iny 									; skip token.
.011617	c8		iny			iny
.011618	80 9f		bra $0115b9		bra 	_DTKMainLoop
.01161a					_DTKIdentifier:
.01161a	48		pha			pha 									; save token for typing at end
.01161b					_DTKILoop:
.01161b	b9 00 00	lda $0000,y		lda 	$0000,y 						; get token
.01161e	20 47 16	jsr $011647		jsr 	_DTKIDecodeToken 				; decode it.
.011621	b9 00 00	lda $0000,y		lda 	$0000,y 						; get the token again
.011624	c8		iny			iny 									; skip it
.011625	c8		iny			iny
.011626	29 00 08	and #$0800		and 	#IDContMask 					; continuation ?
.011629	d0 f0		bne $01161b		bne 	_DTKILoop
.01162b	68		pla			pla 									; add $( as required.
.01162c	48		pha			pha 									; comes from the first token.
.01162d	29 00 20	and #$2000		and 	#IDTypeMask
.011630	f0 06		beq $011638		beq 	_DTKINotString
.011632	a9 24 00	lda #$0024		lda 	#"$"
.011635	20 4e 07	jsr $01074e		jsr 	StringWriteCharacter
.011638					_DTKINotString:
.011638	68		pla			pla
.011639	29 00 10	and #$1000		and 	#IDArrayMask
.01163c	f0 06		beq $011644		beq 	_DTKINotArray
.01163e	a9 28 00	lda #$0028		lda 	#"("
.011641	20 4e 07	jsr $01074e		jsr 	StringWriteCharacter
.011644					_DTKINotArray:
.011644	82 72 ff	brl $0115b9		brl 	_DTKMainLoop
.011647					_DTKIDecodeToken:
.011647	5a		phy			phy
.011648	29 ff 07	and #$07ff		and		#$07FF 							; mask off the identifier bit.
.01164b	a0 ff ff	ldy #$ffff		ldy 	#-1 							; first, divide by 45 getting remainder.
.01164e					_DTKIDivide:
.01164e	38		sec			sec
.01164f	e9 2d 00	sbc #$002d		sbc 	#45
.011652	c8		iny			iny
.011653	b0 f9		bcs $01164e		bcs 	_DTKIDivide
.011655	69 2d 00	adc #$002d		adc 	#45
.011658	20 61 16	jsr $011661		jsr 	_DTKIOutA 						; output low.
.01165b	98		tya			tya
.01165c	20 61 16	jsr $011661		jsr 	_DTKIOutA 						; output high
.01165f	7a		ply			ply
.011660	60		rts			rts
.011661					_DTKIOutA:
.011661	09 00 00	ora #$0000		ora 	#$0000 							; exit if 0
.011664	f0 10		beq $011676		beq 	_DTKIOutExit
.011666	c9 1b 00	cmp #$001b		cmp 	#27 							; skip if A-Z
.011669	90 04		bcc $01166f		bcc 	_DTKIOutAlpha
.01166b	38		sec			sec  									; adjust for 0-9
.01166c	e9 4b 00	sbc #$004b		sbc 	#$4B
.01166f					_DTKIOutAlpha:
.01166f	18		clc			clc										; adjust for A-Z
.011670	69 60 00	adc #$0060		adc 	#96
.011673	20 4e 07	jsr $01074e		jsr 	StringWriteCharacter
.011676					_DTKIOutExit:
.011676	60		rts			rts
.011677					_DTKDecodeKeyword:
.011677	48		pha			pha
.011678	da		phx			phx
.011679	5a		phy			phy
.01167a	a8		tay			tay 									; save token ID in Y
.01167b	29 00 18	and #$1800		and 	#$1800 							; is it a keyword
.01167e	49 00 18	eor #$1800		eor 	#$1800 							; now zero if it is.
.011681	48		pha			pha 									; save this flag on a stack
.011682	5a		phy			phy 									; save the token ID
.011683	c9 00 00	cmp #$0000		cmp 	#0 								; check if spacing perhaps required.
.011686	d0 19		bne $0116a1		bne 	_DTKNotSpecial1
.011688	a4 1a		ldy $1a			ldy 	DCurrentTempString 				; what was the last character out ?
.01168a	88		dey			dey
.01168b	b9 00 00	lda $0000,y		lda 	$0000,y
.01168e	29 ff 00	and #$00ff		and 	#$00FF
.011691	c9 20 00	cmp #$0020		cmp 	#" " 							; if space or colon, not needed/
.011694	f0 0b		beq $0116a1		beq 	_DTKNotSpecial1
.011696	c9 3a 00	cmp #$003a		cmp 	#":"
.011699	f0 06		beq $0116a1		beq 	_DTKNotSpecial1
.01169b	a9 20 00	lda #$0020		lda 	#" "							; output space otherwise.
.01169e	20 4e 07	jsr $01074e		jsr 	StringWriteCharacter
.0116a1					_DTKNotSpecial1:
.0116a1	68		pla			pla
.0116a2	29 ff 01	and #$01ff		and 	#$01FF 							; this is the keyword number.
.0116a5	a8		tay			tay 									; into Y.
.0116a6	a2 00 00	ldx #$0000		ldx 	#0 								; offset into the ROM table, token text
.0116a9					_DTKDWorkThrough:
.0116a9	88		dey			dey 									; reached the token (tokens start at 1 in text table)
.0116aa	f0 0f		beq $0116bb		beq 	_DTKDFound
.0116ac	86 08		stx $08			stx 	DTemp1
.0116ae	bf 9e 00 01	lda $01009e,x		lda 	TokenText,x 					; read the type/skip byte.
.0116b2	29 0f 00	and #$000f		and 	#$000F 							; bytes to skip
.0116b5	18		clc			clc
.0116b6	65 08		adc $08			adc 	DTemp1
.0116b8	aa		tax			tax
.0116b9	80 ee		bra $0116a9		bra 	_DTKDWorkThrough
.0116bb					_DTKDFound:
.0116bb	bf 9e 00 01	lda $01009e,x		lda 	TokenText,x 					; get skip
.0116bf	29 0f 00	and #$000f		and 	#$000F 					 		; length is skip -1
.0116c2	3a		dec a			dec 	a
.0116c3	a8		tay			tay 									; put in Y
.0116c4					_DTKOut:
.0116c4	bf 9f 00 01	lda $01009f,x		lda 	TokenText+1,x 					; output it.
.0116c8	29 ff 00	and #$00ff		and 	#$00FF
.0116cb					_DTKNotLC:
.0116cb	20 4e 07	jsr $01074e		jsr 	StringWriteCharacter
.0116ce	e8		inx			inx
.0116cf	88		dey			dey
.0116d0	d0 f2		bne $0116c4		bne 	_DTKOut
.0116d2	68		pla			pla 									; trailing space.
.0116d3	d0 06		bne $0116db		bne 	_DTKNotSpecial2
.0116d5	a9 20 00	lda #$0020		lda 	#" "
.0116d8	20 4e 07	jsr $01074e		jsr 	StringWriteCharacter
.0116db					_DTKNotSpecial2:
.0116db	7a		ply			ply
.0116dc	fa		plx			plx
.0116dd	68		pla			pla
.0116de	60		rts			rts
.0116df					ScanIndent:
.0116df	48		pha			pha
.0116e0	5a		phy			phy
.0116e1	a5 2c		lda $2c			lda 	DIndent  						; save the old indentation
.0116e3	85 2e		sta $2e			sta 	DIndent2
.0116e5	98		tya			tya
.0116e6	18		clc			clc 									; point to code.
.0116e7	69 04 00	adc #$0004		adc 	#4
.0116ea	a8		tay			tay
.0116eb					_SILoop:
.0116eb	b9 00 00	lda $0000,y		lda 	$0000,y 						; get token
.0116ee	f0 35		beq $011725		beq 	_SIExit
.0116f0	c9 00 01	cmp #$0100		cmp 	#$0100							; is it a string ?
.0116f3	b0 08		bcs $0116fd		bcs 	_SICheckKeyword
.0116f5	98		tya			tya 									; skip string.
.0116f6	18		clc			clc
.0116f7	79 00 00	adc $0000,y		adc 	$0000,y
.0116fa	a8		tay			tay
.0116fb	80 ee		bra $0116eb		bra 	_SILoop
.0116fd					_SICheckKeyword:
.0116fd	29 00 e0	and #$e000		and 	#$E000
.011700	c9 00 20	cmp #$2000		cmp 	#$2000
.011703	f0 04		beq $011709		beq 	_SIFoundKeyword
.011705					_SIAdvance:
.011705	c8		iny			iny 									; if not, loop round.
.011706	c8		iny			iny
.011707	80 e2		bra $0116eb		bra 	_SILoop
.011709					_SIFoundKeyword:
.011709	b9 00 00	lda $0000,y		lda 	$0000,y 						; get keyword
.01170c	29 00 1e	and #$1e00		and 	#15<<9							; extract type
.01170f	c9 00 1c	cmp #$1c00		cmp 	#14<<9
.011712	f0 0d		beq $011721		beq 	_SIKeyPlus
.011714	c9 00 1a	cmp #$1a00		cmp 	#13<<9 							; and adjust DIndent appropriately.
.011717	d0 ec		bne $011705		bne 	_SIAdvance
.011719	c6 2c		dec $2c			dec 	DIndent
.01171b	10 e8		bpl $011705		bpl 	_SIAdvance
.01171d	64 2c		stz $2c			stz 	DIndent
.01171f	80 e4		bra $011705		bra 	_SIAdvance
.011721					_SIKeyPlus:
.011721	e6 2c		inc $2c			inc 	DIndent
.011723	80 e0		bra $011705		bra 	_SIAdvance
.011725					_SIExit:
.011725	7a		ply			ply
.011726	68		pla			pla
.011727	60		rts			rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/print.asm

.011728					Command_PRINT:
.011728	b2 06		lda ($06)			lda 	(DCodePtr) 					; look at first characteer
.01172a	f0 33		beq $01175f			beq 	_FPRExitCR 					; if zero, then exit with CR, maybe.
.01172c	c9 26 32	cmp #$3226			cmp 	#colonTokenID 				; likewise if a colon.
.01172f	f0 2e		beq $01175f			beq 	_FPRExitCR
.011731	c9 25 32	cmp #$3225			cmp 	#semicolonTokenID 			; semicolon, skip it
.011734	f0 23		beq $011759			beq 	_FPRSkipLoop
.011736	c9 29 32	cmp #$3229			cmp 	#squoteTokenID 				; single quote is CR
.011739	f0 1b		beq $011756			beq 	_FPRNewLine
.01173b	c9 24 32	cmp #$3224			cmp 	#commaTokenID 				; , is tab.
.01173e	f0 11		beq $011751			beq 	_FPRTab
.011740					_FPRExpression:
.011740	20 01 02	jsr $010201			jsr 	Evaluate 					; evaluate a string or integer.
.011743	b0 06		bcs $01174b			bcs 	_FPRHaveString
.011745	a2 0a 00	ldx #$000a			ldx 	#10 						; convert to string
.011748	20 c9 10	jsr $0110c9			jsr 	ConvertToString
.01174b					_FPRHaveString:
.01174b	a8		tay				tay 								; print the basic String.
.01174c	20 57 06	jsr $010657			jsr 	PrintBASICString
.01174f	80 d7		bra $011728			bra 	Command_Print 				; and go round again.
.011751					_FPRTab:
.011751	20 84 1e	jsr $011e84			jsr 	HWTab
.011754	80 03		bra $011759			bra 	_FPRSkipLoop
.011756					_FPRNewLine:
.011756	20 6f 1e	jsr $011e6f			jsr 	HWNewLine
.011759					_FPRSkipLoop:
.011759	e6 06		inc $06				inc 	DCodePtr
.01175b	e6 06		inc $06				inc 	DCodePtr
.01175d	80 c9		bra $011728			bra 	Command_Print
.01175f					_FPRExitCR:
.01175f	a4 06		ldy $06				ldy 	DCodePtr 					; was the previous token a ; or ,
.011761	88		dey				dey
.011762	88		dey				dey
.011763	b9 00 00	lda $0000,y			lda 	$0000,y
.011766	c9 24 32	cmp #$3224			cmp 	#commaTokenID 	 			; if so, don't do a new line at the end of the instruction.
.011769	f0 08		beq $011773			beq 	_FPRExit
.01176b	c9 25 32	cmp #$3225			cmp 	#semicolonTokenID
.01176e	f0 03		beq $011773			beq 	_FPRExit
.011770	20 6f 1e	jsr $011e6f			jsr 	HWNewLine 					; print a new line.
.011773					_FPRExit:
.011773	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/if.asm

.011774					Command_IF:
.011774	20 0d 03	jsr $01030d			jsr 	EvaluateInteger 			; check success.
.011777	84 08		sty $08				sty 	DTemp1 						; work out if non-zero
.011779	05 08		ora $08				ora 	DTemp1
.01177b	a8		tay				tay 								; success flag in Y.
.01177c	b2 06		lda ($06)			lda 	(DCodePtr) 					; does THEN follow
.01177e	c9 4b 3a	cmp #$3a4b			cmp 	#thenTokenID
.011781	d0 32		bne $0117b5			bne 	_FIFExtended 				; if so, go to the extended IF.
.011783	e6 06		inc $06				inc 	DCodePtr 					; skip over THEN token.
.011785	e6 06		inc $06				inc 	DCodePtr
.011787	c0 00 00	cpy #$0000			cpy 	#0 							; was it successful.
.01178a	f0 0f		beq $01179b			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.01178c	b2 06		lda ($06)			lda 	(DCodePtr) 					; look to see if there is a number there.
.01178e	c9 00 40	cmp #$4000			cmp 	#$4000 						; is it a numeric constant.
.011791	90 21		bcc $0117b4			bcc 	_FIFContinue 				; if not, just carry on exiting.
.011793	c9 00 c0	cmp #$c000			cmp 	#$C000
.011796	b0 1c		bcs $0117b4			bcs 	_FIFContinue
.011798	4c 18 1a	jmp $011a18			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.01179b					_FIFEndOfLine:
.01179b	b2 06		lda ($06)			lda 	(DCodePtr) 					; reached the end of the line.
.01179d	f0 15		beq $0117b4			beq 	_FIFContinue 				; if done so, continue.
.01179f	c9 00 01	cmp #$0100			cmp 	#$0100	 					; string constant ?
.0117a2	90 06		bcc $0117aa			bcc 	_FIFStringConstant
.0117a4	e6 06		inc $06				inc 	DCodePtr 					; if not, just skip the token
.0117a6	e6 06		inc $06				inc 	DCodePtr
.0117a8	80 f1		bra $01179b			bra 	_FIFEndOfLine
.0117aa					_FIFStringConstant:
.0117aa	29 ff 00	and #$00ff			and 	#$00FF 						; add to CodePtr to skip string.
.0117ad	18		clc				clc
.0117ae	65 06		adc $06				adc 	DCodePtr
.0117b0	85 06		sta $06				sta 	DCodePtr
.0117b2	80 e7		bra $01179b			bra 	_FIFEndOfLine
.0117b4					_FIFContinue:
.0117b4	60		rts				rts
.0117b5					_FIFExtended:
.0117b5	e6 2a		inc $2a				inc 	DStack 						; put IF on the top of the stack
.0117b7	e6 2a		inc $2a				inc 	DStack
.0117b9	a9 46 3c	lda #$3c46			lda 	#ifTokenID
.0117bc	a6 2a		ldx $2a				ldx 	DStack
.0117be	95 00		sta $00,x			sta 	$00,x
.0117c0	98		tya				tya 								; see if the test was passed.
.0117c1	f0 01		beq $0117c4			beq 	_FIXSkip 					; if zero then it has failed.
.0117c3	60		rts				rts 								; test passed, so continue executing
.0117c4					_FIXSkip:
.0117c4	a9 3a 3e	lda #$3e3a			lda 	#elseTokenID 				; scan forward till found either ELSE or ENDIF
.0117c7	a2 4c 3a	ldx #$3a4c			ldx 	#endifTokenID 				; at the same level.
.0117ca	20 2a 18	jsr $01182a			jsr 	ScanForwardLevel 			; scan forward, returns what found in A.
.0117cd	e6 06		inc $06				inc 	DCodePtr 					; skip over the ELSE or ENDIF
.0117cf	e6 06		inc $06				inc 	DCodePtr
.0117d1	c9 4c 3a	cmp #$3a4c			cmp 	#endifTokenID 				; if ENDIF token ID, then throw the TOS as ended
.0117d4	d0 04		bne $0117da			bne 	_FIXNoThrow
.0117d6	c6 2a		dec $2a				dec 	DStack 						; throw the token IF on the stack top.
.0117d8	c6 2a		dec $2a				dec 	DStack
.0117da					_FIXNoThrow:
.0117da	60		rts				rts
.0117db					Handler_ELSE:
.0117db	a6 2a		ldx $2a				ldx 	DStack	 					; check the top of stack is IF.
.0117dd	b5 00		lda $00,x			lda 	$00,x
.0117df	c9 46 3c	cmp #$3c46			cmp 	#ifTokenID
.0117e2	d0 12		bne $0117f6			bne 	_HEBadStructure
.0117e4	a9 4c 3a	lda #$3a4c			lda 	#endifTokenID 				; only searching one token.
.0117e7	a2 00 00	ldx #$0000			ldx 	#$0000
.0117ea	20 2a 18	jsr $01182a			jsr 	ScanForwardLevel 			; so this will find the ENDIF
.0117ed	e6 06		inc $06				inc 	DCodePtr 					; skip over the ENDIF
.0117ef	e6 06		inc $06				inc 	DCodePtr
.0117f1	c6 2a		dec $2a				dec 	DStack 						; throw the token IF on the stack top.
.0117f3	c6 2a		dec $2a				dec 	DStack
.0117f5	60		rts				rts
.0117f6					_HEBadStructure:
.0117f6	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>0117f9	45 6c 73 65 20 77 69 74				.text 	"Else without If",$00 								; with this message
>011801	68 6f 75 74 20 49 66 00
.011809					Handler_ENDIF:
.011809	a6 2a		ldx $2a				ldx 	DStack	 					; check the top of stack is IF.
.01180b	b5 00		lda $00,x			lda 	$00,x
.01180d	c9 46 3c	cmp #$3c46			cmp 	#ifTokenID
.011810	d0 05		bne $011817			bne 	_HEIBadStructure
.011812	c6 2a		dec $2a				dec 	DStack 						; throw the token IF on the stack top.
.011814	c6 2a		dec $2a				dec 	DStack
.011816	60		rts				rts
.011817					_HEIBadStructure:
.011817	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>01181a	45 6c 73 65 20 77 69 74				.text 	"Else without If",$00 								; with this message
>011822	68 6f 75 74 20 49 66 00
.01182a					ScanForwardLevel:
.01182a	85 08		sta $08				sta 	DTemp1 						; save test in DTemp1 and DTemp1+2
.01182c	86 0a		stx $0a				stx 	DTemp1+2
.01182e	a5 22		lda $22				lda 	DLineNumber 				; save original line number for error
.011830	85 0c		sta $0c				sta 	DTemp2
.011832	a2 00 00	ldx #$0000			ldx 	#0 							; X is the level counter.
.011835					_SFLLoop:
.011835	e0 00 00	cpx #$0000			cpx 	#0 							; if X != 0 then don't test tokens for exit.
.011838	d0 0d		bne $011847			bne 	_SFLNoCheck 				; we're in a substructure.
.01183a	b2 06		lda ($06)			lda 	(DCodePtr)					; what's there
.01183c	f0 09		beq $011847			beq 	_SFLNoCheck 				; don't check zero
.01183e	c5 08		cmp $08				cmp 	DTemp1 						; does it match either token ?
.011840	f0 04		beq $011846			beq 	_SFLFound
.011842	c5 0a		cmp $0a				cmp 	DTemp1+2
.011844	d0 01		bne $011847			bne 	_SFLNoCheck
.011846					_SFLFound:
.011846	60		rts				rts
.011847					_SFLNoCheck:
.011847	b2 06		lda ($06)			lda 	(DCodePtr) 					; what is the token.
.011849	f0 4f		beq $01189a			beq 	_SFLNextLine 				; if $0000 go to the next line (end of line marker)
.01184b	c9 00 01	cmp #$0100			cmp 	#$0100 						; is it a string.
.01184e	90 40		bcc $011890			bcc 	_SFLSkipString 				; then handle that.
.011850	e6 06		inc $06				inc 	DCodePtr 					; skip over the token
.011852	e6 06		inc $06				inc 	DCodePtr
.011854	a8		tay				tay 								; put token in Y temporarily.
.011855	29 00 e0	and #$e000			and 	#$E000 						; if not a keyword 010x xxxx xxxx xxxx
.011858	c9 00 20	cmp #$2000			cmp 	#$2000
.01185b	d0 d8		bne $011835			bne 	_SFLLoop
.01185d	98		tya				tya 								; get the token back.
.01185e	29 00 1e	and #$1e00			and 	#15 << 9 					; get out token type xxxA AAAx xxxx xxxx
.011861	c9 00 1e	cmp #$1e00			cmp 	#15 << 9 					; 15 is a standard keyword
.011864	f0 cf		beq $011835			beq 	_SFLLoop
.011866	c9 00 1a	cmp #$1a00			cmp 	#13 << 9 					; < 13 is also standard
.011869	90 ca		bcc $011835			bcc 	_SFLLoop
.01186b	e8		inx				inx 								; increment the level.
.01186c	c9 00 1c	cmp #$1c00			cmp 	#14 << 9 					; if keyword +, loop back.
.01186f	f0 c4		beq $011835			beq 	_SFLLoop
.011871	ca		dex				dex 								; decrement the level
.011872	ca		dex				dex 								; one overdoes the previous inx.
.011873	10 c0		bpl $011835			bpl 	_SFLLoop 					; if gone -ve then error.
.011875					_SFLError:
.011875	a5 0c		lda $0c				lda 	DTemp2 						; get original line number
.011877	85 22		sta $22				sta 	DLineNumber
.011879	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>01187c	53 74 72 75 63 74 75 72				.text 	"Structure imbalance",$00 								; with this message
>011884	65 20 69 6d 62 61 6c 61 6e 63 65 00
.011890					_SFLSkipString:
.011890	29 ff 00	and #$00ff			and 	#$00FF 						; token length of string
.011893	18		clc				clc
.011894	65 06		adc $06				adc 	DCodePtr 					; add to code pointer and save out
.011896	85 06		sta $06				sta 	DCodePtr
.011898	80 9b		bra $011835			bra 	_SFLLoop 					; go round again.
.01189a					_SFLNextLine:
.01189a	a4 06		ldy $06				ldy 	DCodePtr 					; put code pointer into Y
.01189c	b9 02 00	lda $0002,y			lda 	$0002,y 					; look at the link for the next line.
.01189f	f0 d4		beq $011875			beq 	_SFLError 					; if zero, then there's no more code to search.
.0118a1	b9 04 00	lda $0004,y			lda 	$0004,y 					; update the line number so it's still correct.
.0118a4	85 22		sta $22				sta 	DLineNumber
.0118a6	18		clc				clc
.0118a7	a5 06		lda $06				lda 	DCodePtr
.0118a9	69 06 00	adc #$0006			adc 	#6 							; skip $00 marker, link, new line
.0118ac	85 06		sta $06				sta 	DCodePtr
.0118ae	80 85		bra $011835			bra 	_SFLLoop 					; and start this one.

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/for.asm

.0118b0					Command_FOR:
.0118b0	b2 06		lda ($06)			lda 	(DCodePtr)					; look at first word
.0118b2	29 00 30	and #$3000			and 	#(IDTypeMask+IDArrayMask)	; check to see if it is type $00 e.g. integer variable
.0118b5	d0 4e		bne $011905			bne		_CFOBad
.0118b7	20 9a 03	jsr $01039a			jsr 	VariableFind 				; try to find variable
.0118ba	b0 03		bcs $0118bf			bcs 	_CFOExists
.0118bc	20 4d 04	jsr $01044d			jsr 	VariableCreate				; create it and skip token.
.0118bf					_CFOExists:
.0118bf	48		pha				pha 								; push variable address on stack
.0118c0	a9 06 22	lda #$2206			lda 	#equalTokenID 				; check for =
.0118c3	20 dd 05	jsr $0105dd			jsr 	ExpectToken
.0118c6	20 0d 03	jsr $01030d			jsr 	EvaluateInteger 			; this is the start value
.0118c9	bb		tyx				tyx 								; put high value in X
.0118ca	7a		ply				ply 								; address of for variable in Y
.0118cb	99 00 00	sta $0000,y			sta 	$0000,y 					; copy into variable
.0118ce	8a		txa				txa
.0118cf	99 02 00	sta $0002,y			sta 	$0002,y
.0118d2	a9 2a 38	lda #$382a			lda 	#toTokenID 					; expect the TO
.0118d5	20 dd 05	jsr $0105dd			jsr 	ExpectToken
.0118d8	a6 2a		ldx $2a				ldx 	DStack 						; get the stack.
.0118da	a5 06		lda $06				lda 	DCodePtr 					; save code ptr at +2 (after "TO")
.0118dc	95 02		sta $02,x			sta 	$02,x
.0118de	a5 22		lda $22				lda 	DLineNumber 				; save line number at +4
.0118e0	95 04		sta $04,x			sta 	$04,x
.0118e2	98		tya				tya 								; save variable address at +6
.0118e3	95 06		sta $06,x			sta 	$06,x
.0118e5	a9 47 3c	lda #$3c47			lda 	#forTokenID 				; save for token at +8
.0118e8	95 08		sta $08,x			sta 	$08,x
.0118ea	8a		txa				txa 								; add 8 to stack position
.0118eb	18		clc				clc
.0118ec	69 08 00	adc #$0008			adc 	#8
.0118ef	85 2a		sta $2a				sta 	DStack
.0118f1	20 0d 03	jsr $01030d			jsr 	EvaluateInteger 			; the end value, which we don't want this time.
.0118f4	b2 06		lda ($06)			lda 	(DCodePtr)
.0118f6	c9 2b 38	cmp #$382b			cmp 	#stepTokenID 				; if STEP x is present.
.0118f9	d0 09		bne $011904			bne 	_CFONoStep
.0118fb	a9 2b 38	lda #$382b			lda 	#stepTokenID 				; skip STEP
.0118fe	20 dd 05	jsr $0105dd			jsr 	ExpectToken
.011901	20 0d 03	jsr $01030d			jsr 	EvaluateInteger 			; and whatever the step is, throw away this time.
.011904					_CFONoStep:
.011904	60		rts				rts
.011905					_CFOBad:
.011905	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>011908	42 61 64 20 46 4f 52 20				.text 	"Bad FOR variable",$00 								; with this message
>011910	76 61 72 69 61 62 6c 65 00
.011919					Command_NEXT:
.011919	a6 2a		ldx $2a				ldx 	DStack 						; look at TOS
.01191b	b5 00		lda $00,x			lda 	$00,x
.01191d	c9 47 3c	cmp #$3c47			cmp 	#forTokenID 				; if not FOR then error
.011920	f0 14		beq $011936			beq 	_CNXOk
.011922	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>011925	4e 65 78 74 20 77 69 74				.text 	"Next without For",$00 								; with this message
>01192d	68 6f 75 74 20 46 6f 72 00
.011936					_CNXOk:
.011936	b2 06		lda ($06)			lda 	(DCodePtr)					; if there's an identifier here.
.011938	c9 00 c0	cmp #$c000			cmp 	#$C000 						; e.g. NEXT <var>
.01193b	90 22		bcc $01195f			bcc 	_CNXNoVariable
.01193d	20 9a 03	jsr $01039a			jsr 	VariableFind 				; get address of variable.
.011940	90 08		bcc $01194a			bcc 	_CNXNextVar 				; not found variable, it's an error.
.011942	a6 2a		ldx $2a				ldx 	DStack 						; point X to variable address
.011944	ca		dex				dex
.011945	ca		dex				dex
.011946	d5 00		cmp $00,x			cmp 	$00,x 						; same variable as the found one.
.011948	f0 15		beq $01195f			beq 	_CNXNoVariable 				; then continue
.01194a					_CNXNextVar:
.01194a	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>01194d	42 61 64 20 4e 45 58 54				.text 	"Bad NEXT variable",$00 								; with this message
>011955	20 76 61 72 69 61 62 6c 65 00
.01195f					_CNXNoVariable:
.01195f	a5 06		lda $06				lda 	DCodePtr 					; save the following position on the stack in case we are done.
.011961	48		pha				pha
.011962	a5 2a		lda $2a				lda 	DStack 						; subtract 8 from stack
.011964	38		sec				sec
.011965	e9 08 00	sbc #$0008			sbc 	#8
.011968	85 2a		sta $2a				sta 	DStack
.01196a	aa		tax				tax 								; X points to the stack.
.01196b	b5 02		lda $02,x			lda 	$02,x 						; put the old pointer in the pointer (e.g. after TO)
.01196d	85 06		sta $06				sta 	DCodePtr
.01196f	20 0d 03	jsr $01030d			jsr 	EvaluateInteger 			; this is the target constant
.011972	5a		phy				phy 								; save the target on the stack
.011973	48		pha				pha
.011974	a9 01 00	lda #$0001			lda 	#1 							; set DTemp1 (the count) to 1
.011977	85 08		sta $08				sta 	DTemp1
.011979	64 0a		stz $0a				stz 	DTemp1+2
.01197b	b2 06		lda ($06)			lda 	(DCodePtr)					; does a STEP follow.
.01197d	c9 2b 38	cmp #$382b			cmp 	#stepTokenID
.011980	d0 0b		bne $01198d			bne 	_CNXNoStep
.011982	e6 06		inc $06				inc 	DCodePtr 					; skip over the step token.
.011984	e6 06		inc $06				inc 	DCodePtr
.011986	20 0d 03	jsr $01030d			jsr 	EvaluateInteger 			; work out the step.
.011989	85 08		sta $08				sta 	DTemp1 						; and save in DTemp1
.01198b	84 0a		sty $0a				sty 	DTemp1+2
.01198d					_CNXNoStep:
.01198d	68		pla				pla 								; save the Target in DTemp2
.01198e	85 0c		sta $0c				sta 	DTemp2
.011990	68		pla				pla
.011991	85 0e		sta $0e				sta 	DTemp2+2
.011993	a6 2a		ldx $2a				ldx 	DStack 						; get the stack
.011995	b5 06		lda $06,x			lda 	$06,x 						; address of the FOR variable into Y
.011997	a8		tay				tay
.011998	18		clc				clc
.011999	b9 00 00	lda $0000,y			lda 	$0000,y
.01199c	65 08		adc $08				adc 	DTemp1
.01199e	99 00 00	sta $0000,y			sta 	$0000,y
.0119a1	b9 02 00	lda $0002,y			lda 	$0002,y
.0119a4	65 0a		adc $0a				adc 	DTemp1+2
.0119a6	99 02 00	sta $0002,y			sta 	$0002,y
.0119a9	38		sec				sec
.0119aa	a5 0c		lda $0c				lda 	DTemp2
.0119ac	f9 00 00	sbc $0000,y			sbc 	$0000,y
.0119af	85 0c		sta $0c				sta 	DTemp2
.0119b1	a5 0e		lda $0e				lda 	DTemp2+2
.0119b3	f9 02 00	sbc $0002,y			sbc 	$0002,y
.0119b6	85 0e		sta $0e				sta 	DTemp2+2
.0119b8	05 0c		ora $0c				ora 	DTemp2 						; if zero (Target = Result)
.0119ba	f0 0a		beq $0119c6			beq 	_CNXLoopAgain 				; then loop again, as we have to be past the target.
.0119bc	a5 0e		lda $0e				lda 	DTemp2+2 					; if sign(target-counter) == sign(step)
.0119be	45 0a		eor $0a				eor 	DTemp1+2
.0119c0	10 04		bpl $0119c6			bpl		_CNXLoopAgain 				; we aren't there yet, so loop again.
.0119c2	68		pla				pla 								; restore the original DCodePtr as we are exiting the structure
.0119c3	85 06		sta $06				sta 	DCodePtr
.0119c5	60		rts				rts
.0119c6					_CNXLoopAgain:
.0119c6	68		pla				pla 								; throw the original DCodePtr as we're going back.
.0119c7	18		clc				clc
.0119c8	a5 2a		lda $2a				lda 	DStack 						; fix the stack back so we can loop round again.
.0119ca	aa		tax				tax
.0119cb	69 08 00	adc #$0008			adc 	#8
.0119ce	85 2a		sta $2a				sta 	DStack
.0119d0	b5 04		lda $04,x			lda		$04,x 						; because we've jumped to the top, get the line number
.0119d2	85 22		sta $22				sta 	DLineNumber 				; and make that right again.
.0119d4	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/transfer.asm

.0119d5					Command_ONGOTO:
.0119d5	20 0d 03	jsr $01030d			jsr 	EvaluateInteger 			; on what GOTO :)
.0119d8	c0 00 00	cpy #$0000			cpy 	#0 							; check range. ON x GOTO x1,x2,x3,x4. 0 is illegal.
.0119db	d0 25		bne $011a02			bne 	_FOGoFail
.0119dd	c9 00 00	cmp #$0000			cmp 	#0
.0119e0	f0 20		beq $011a02			beq 	_FOGoFail 					; we start with index = 1
.0119e2	48		pha				pha 								; save count on stack
.0119e3	a9 36 3e	lda #$3e36			lda 	#gotoTokenID 				; expect GOTO
.0119e6	20 dd 05	jsr $0105dd			jsr 	ExpectToken
.0119e9	fa		plx				plx 								; put count in X.
.0119ea					_FOGoLoop:
.0119ea	b2 06		lda ($06)			lda 	(DCodePtr) 					; check the next value is a constant.
.0119ec	c9 00 40	cmp #$4000			cmp 	#$4000						; range 4000-BFFF
.0119ef	90 73		bcc $011a64			bcc 	FGOFail 					; if not, then we have an error.
.0119f1	c9 00 c0	cmp #$c000			cmp 	#$C000
.0119f4	b0 6e		bcs $011a64			bcs 	FGOFail
.0119f6	ca		dex				dex 								; subtract one, if done, call GOTO code
.0119f7	f0 1f		beq $011a18			beq 	Command_GOTO
.0119f9	e6 06		inc $06				inc 	DCodePtr 					; step over the constant
.0119fb	e6 06		inc $06				inc 	DCodePtr
.0119fd	20 00 06	jsr $010600			jsr 	ExpectComma 				; expect a comma
.011a00	80 e8		bra $0119ea			bra 	_FOGoLoop 					; and loop round.
.011a02					_FOGoFail:
.011a02	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>011a05	42 61 64 20 4f 6e 2e 2e				.text 	"Bad On..Goto value",$00 								; with this message
>011a0d	47 6f 74 6f 20 76 61 6c 75 65 00
.011a18					Command_GOTO:
.011a18	b2 06		lda ($06)			lda 	(DCodePtr) 					; look at the number
.011a1a	c9 00 40	cmp #$4000			cmp 	#$4000						; range 4000-BFFF
.011a1d	90 45		bcc $011a64			bcc 	FGOFail 					; we don't do calculate line numbers.
.011a1f	c9 00 c0	cmp #$c000			cmp 	#$C000
.011a22	b0 40		bcs $011a64			bcs 	FGOFail
.011a24	38		sec				sec 								; convert to 0-32767
.011a25	e9 00 40	sbc #$4000			sbc 	#$4000 						; and put in X.
.011a28	aa		tax				tax
.011a29	a9 00 02	lda #$0200			lda 	#Block_ProgramStart 		; start of program offset
.011a2c	18		clc				clc
.011a2d	65 02		adc $02				adc 	DBaseAddress 				; now an address into Y
.011a2f	a8		tay				tay
.011a30					_FGOSearch:
.011a30	b9 00 00	lda $0000,y			lda 	$0000,y 					; look at link , exit if zero, reached end of program.
.011a33	f0 18		beq $011a4d			beq 	_FGOUnknown
.011a35	8a		txa				txa 								; does it match line number ?
.011a36	d9 02 00	cmp $0002,y			cmp 	$0002,y
.011a39	f0 08		beq $011a43			beq 	_FGOFound 					; yes, then found.
.011a3b	98		tya				tya 								; no follow the link
.011a3c	18		clc				clc
.011a3d	79 00 00	adc $0000,y			adc 	$0000,y 					; add offset to address
.011a40	a8		tay				tay
.011a41	80 ed		bra $011a30			bra 	_FGOSearch 					; and keep looking
.011a43					_FGOFound:
.011a43	85 22		sta $22				sta 	DLineNumber 				; store as new line number
.011a45	98		tya				tya 								; Y + 4 is the code pointer.
.011a46	18		clc				clc 								; (skipping link and line #)
.011a47	69 04 00	adc #$0004			adc 	#4
.011a4a	85 06		sta $06				sta 	DCodePtr
.011a4c	60		rts				rts									; and continue
.011a4d					_FGOUnknown:
.011a4d	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>011a50	55 6e 6b 6e 6f 77 6e 20				.text 	"Unknown Line Number",$00 								; with this message
>011a58	4c 69 6e 65 20 4e 75 6d 62 65 72 00
.011a64					FGOFail:
.011a64	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>011a67	42 61 64 20 4c 69 6e 65				.text 	"Bad Line Number",$00 								; with this message
>011a6f	20 4e 75 6d 62 65 72 00
.011a77					Command_GOSUB:
.011a77	a6 2a		ldx $2a				ldx 	DStack 						; point Y to the stack.
.011a79	a5 06		lda $06				lda 	DCodePtr 					; save code ptr at +0 , 2 added to skip line number
.011a7b	18		clc				clc
.011a7c	69 02 00	adc #$0002			adc 	#2
.011a7f	95 02		sta $02,x			sta 	$02,x 						; save pos at +2
.011a81	a5 22		lda $22				lda 	DLineNumber 				; save line number at +4
.011a83	95 04		sta $04,x			sta 	$04,x
.011a85	a9 37 3e	lda #$3e37			lda 	#gosubTokenID 				; save gosub token at +6
.011a88	95 06		sta $06,x			sta 	$06,x
.011a8a	8a		txa				txa 								; advance stack by 6.
.011a8b	18		clc				clc
.011a8c	69 06 00	adc #$0006			adc 	#6
.011a8f	85 2a		sta $2a				sta 	DStack
.011a91	80 85		bra $011a18			bra 	Command_GOTO 				; and do a GOTO.
.011a93					Command_RETURN:
.011a93	a6 2a		ldx $2a				ldx 	DStack
.011a95	b5 00		lda $00,x			lda 	$00,x
.011a97	c9 37 3e	cmp #$3e37			cmp 	#gosubTokenID 				; check top token.
.011a9a	d0 11		bne $011aad			bne 	_FRetFail
.011a9c	8a		txa				txa 								; unpick stack.
.011a9d	38		sec				sec
.011a9e	e9 06 00	sbc #$0006			sbc 	#6
.011aa1	85 2a		sta $2a				sta 	DStack
.011aa3	aa		tax				tax
.011aa4	b5 02		lda $02,x			lda 	$02,x 						; copy code pointer out.
.011aa6	85 06		sta $06				sta 	DCodePtr
.011aa8	b5 04		lda $04,x			lda 	$04,x 						; copy line number out
.011aaa	85 22		sta $22				sta 	DLineNumber
.011aac	60		rts				rts
.011aad					_FRetFail:
.011aad	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>011ab0	52 65 74 75 72 6e 20 77				.text 	"Return without Gosub",$00 								; with this message
>011ab8	69 74 68 6f 75 74 20 47 6f 73 75 62 00

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/repeat.asm

.011ac5					Command_REPEAT:
.011ac5	a6 2a		ldx $2a				ldx 	DStack 						; point Y to the stack.
.011ac7	a5 06		lda $06				lda 	DCodePtr 					; save code ptr
.011ac9	95 02		sta $02,x			sta 	$02,x 						; save pos at +2
.011acb	a5 22		lda $22				lda 	DLineNumber 				; save line number at +4
.011acd	95 04		sta $04,x			sta 	$04,x
.011acf	a9 44 3c	lda #$3c44			lda 	#repeatTokenID 				; save repeat token at +6
.011ad2	95 06		sta $06,x			sta 	$06,x
.011ad4	8a		txa				txa 								; advance stack by 6.
.011ad5	18		clc				clc
.011ad6	69 06 00	adc #$0006			adc 	#6
.011ad9	85 2a		sta $2a				sta 	DStack
.011adb	60		rts				rts
.011adc					Command_UNTIL:
.011adc	a6 2a		ldx $2a				ldx 	DStack 						; check top token is REPEAT
.011ade	b5 00		lda $00,x			lda 	$00,x
.011ae0	c9 44 3c	cmp #$3c44			cmp 	#repeatTokenID
.011ae3	d0 26		bne $011b0b			bne 	_FUNFail
.011ae5	20 0d 03	jsr $01030d			jsr 	EvaluateInteger 			; .... until what.
.011ae8	c0 00 00	cpy #$0000			cpy 	#0 							; exit if non-zero
.011aeb	d0 15		bne $011b02			bne 	_FUNExit
.011aed	c9 00 00	cmp #$0000			cmp 	#0
.011af0	d0 10		bne $011b02			bne 	_FUNExit
.011af2	a5 2a		lda $2a				lda 	DStack 						; unpick stack but don't remove it.
.011af4	38		sec				sec
.011af5	e9 06 00	sbc #$0006			sbc 	#6
.011af8	aa		tax				tax
.011af9	b5 02		lda $02,x			lda 	$02,x 						; copy code pointer out.
.011afb	85 06		sta $06				sta 	DCodePtr
.011afd	b5 04		lda $04,x			lda 	$04,x 						; copy line number out
.011aff	85 22		sta $22				sta 	DLineNumber
.011b01	60		rts				rts
.011b02					_FUNExit:
.011b02	a5 2a		lda $2a				lda 	DStack 						; unpick stack.
.011b04	38		sec				sec
.011b05	e9 06 00	sbc #$0006			sbc 	#6
.011b08	85 2a		sta $2a				sta 	DStack
.011b0a	60		rts				rts
.011b0b					_FUNFail:
.011b0b	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>011b0e	55 6e 74 69 6c 20 77 69				.text 	"Until without Repeat",$00 								; with this message
>011b16	74 68 6f 75 74 20 52 65 70 65 61 74 00

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/while.asm

.011b23					Command_WHILE:
.011b23	a5 06		lda $06				lda 	DCodePtr 					; get the current instruction
.011b25	48		pha				pha 								; save on stack
.011b26	20 0d 03	jsr $01030d			jsr 	EvaluateInteger 			; while what.
.011b29	c0 00 00	cpy #$0000			cpy 	#0 							; do the body if non-zero.
.011b2c	d0 14		bne $011b42			bne 	_FWHExecute
.011b2e	c9 00 00	cmp #$0000			cmp 	#0
.011b31	d0 0f		bne $011b42			bne 	_FWHExecute
.011b33	68		pla				pla 								; throw away current instruction
.011b34	a9 49 3a	lda #$3a49			lda 	#wendTokenID 				; skip to WEND
.011b37	a2 00 00	ldx #$0000			ldx 	#0
.011b3a	20 2a 18	jsr $01182a			jsr 	ScanForwardLevel 			; scan forward checking structures
.011b3d	e6 06		inc $06				inc 	DCodePtr 					; and skip over the WEND.
.011b3f	e6 06		inc $06				inc 	DCodePtr
.011b41	60		rts				rts
.011b42					_FWHExecute:
.011b42	a6 2a		ldx $2a				ldx 	DStack 						; point Y to the stack.
.011b44	68		pla				pla 								; save code ptr-2 so we re-execute the WHILE.
.011b45	3a		dec a				dec 	a
.011b46	3a		dec a				dec 	a
.011b47	95 02		sta $02,x			sta 	$02,x 						; save pos at +2
.011b49	a5 22		lda $22				lda 	DLineNumber 				; save line number at +4
.011b4b	95 04		sta $04,x			sta 	$04,x
.011b4d	a9 45 3c	lda #$3c45			lda 	#whileTokenID 				; save while token at +6
.011b50	95 06		sta $06,x			sta 	$06,x
.011b52	8a		txa				txa 								; advance stack by 6.
.011b53	18		clc				clc
.011b54	69 06 00	adc #$0006			adc 	#6
.011b57	85 2a		sta $2a				sta 	DStack
.011b59	60		rts				rts
.011b5a					Command_WEND:
.011b5a	a6 2a		ldx $2a				ldx 	DStack 						; check top token is WHILE
.011b5c	b5 00		lda $00,x			lda 	$00,x
.011b5e	c9 45 3c	cmp #$3c45			cmp 	#whileTokenID
.011b61	d0 11		bne $011b74			bne 	_FWEFail
.011b63	8a		txa				txa 								; unpick stack and always loop back.
.011b64	38		sec				sec 								; we do the check at the top.
.011b65	e9 06 00	sbc #$0006			sbc 	#6
.011b68	85 2a		sta $2a				sta 	DStack
.011b6a	aa		tax				tax
.011b6b	b5 02		lda $02,x			lda 	$02,x 						; copy code pointer out.
.011b6d	85 06		sta $06				sta 	DCodePtr 					; goes back to the WHILE token.
.011b6f	b5 04		lda $04,x			lda 	$04,x 						; copy line number out
.011b71	85 22		sta $22				sta 	DLineNumber
.011b73	60		rts				rts
.011b74					_FWEFail:
.011b74	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>011b77	57 65 6e 64 20 77 69 74				.text 	"Wend without While",$00 								; with this message
>011b7f	68 6f 75 74 20 57 68 69 6c 65 00

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/run.asm

.011b8a					Command_END:
.011b8a	4c 6d 1f	jmp $011f6d			jmp 	WarmStart
.011b8d					Command_RUN:
.011b8d	20 18 1c	jsr $011c18			jsr 	Command_CLEAR 				; clear all variables.
.011b90	a5 02		lda $02				lda 	DBaseAddress 				; work out the first instruction.
.011b92	18		clc				clc
.011b93	69 00 02	adc #$0200			adc 	#Block_ProgramStart 		; so run from here.
.011b96	80 0c		bra $011ba4			bra 	FRun_NextLineNumber
.011b98					RUNExecuteTokenBuffer:
.011b98	64 22		stz $22				stz 	DLineNumber					; zero line number
.011b9a	a9 00 01	lda #$0100			lda 	#Block_TokenBuffer 			; work out code address/
.011b9d	18		clc				clc
.011b9e	65 02		adc $02				adc 	DBaseAddress
.011ba0	85 06		sta $06				sta 	DCodePtr 					; set the code pointer.
.011ba2	80 12		bra $011bb6			bra 	FRun_NextInstruction
.011ba4					FRun_NextLineNumber:
.011ba4	a8		tay				tay 								; put in Y
.011ba5	b9 00 00	lda $0000,y			lda 	$0000,y 					; read the link token.
.011ba8	f0 e0		beq $011b8a			beq 	Command_END 				; if zero, off the end of the program, so END the program
.011baa	b9 02 00	lda $0002,y			lda 	$0002,y 					; read the line number
.011bad	85 22		sta $22				sta 	DLineNumber 				; and save it.
.011baf	98		tya				tya 								; get address back
.011bb0	18		clc				clc 								; skip over the link/line number
.011bb1	69 04 00	adc #$0004			adc 	#4
.011bb4	85 06		sta $06				sta 	DCodePtr
.011bb6					FRun_NextInstruction:
.011bb6	64 16		stz $16				stz 	DTempStringPointer 			; force reset on next string allocation.
.011bb8	20 8b 1e	jsr $011e8b			jsr 	HWCheckBreak 				; break key pressed.
.011bbb	d0 40		bne $011bfd			bne 	_FRun_Break
.011bbd	b2 06		lda ($06)			lda 	(DCodePtr)					; what's next
.011bbf	f0 32		beq $011bf3			beq 	_FRun_EndInstruction		; if end of this line, then go to next line.
.011bc1	c9 26 32	cmp #$3226			cmp 	#colonTokenID 				; colon then skip
.011bc4	f0 18		beq $011bde			beq 	_FRun_Colon
.011bc6	a8		tay				tay 								; save in Y
.011bc7	29 00 e8	and #$e800			and 	#$E800 						; see if it is a keyword. 1111 1xxk kkkk kkkk e.g. types 11xx
.011bca	c9 00 28	cmp #$2800			cmp 	#$2800 						; so it only runs 1100-1111 keywords.
.011bcd	d0 15		bne $011be4			bne 	_FRun_TryLET 				; if not, try LET as a default.
.011bcf	98		tya				tya 								; get token back
.011bd0	29 ff 01	and #$01ff			and 	#$01FF 						; mask out keyword
.011bd3	0a		asl a				asl 	a 							; double it into X
.011bd4	aa		tax				tax
.011bd5	e6 06		inc $06				inc 	DCodePtr 					; skip over token
.011bd7	e6 06		inc $06				inc 	DCodePtr
.011bd9	fc 00 00	jsr ($010000,x)			jsr 	(CommandJumpTable,x)		; and call that routine
.011bdc	80 d8		bra $011bb6			bra 	FRun_NextInstruction 		; do the following instruction.
.011bde					_FRun_Colon:
.011bde	e6 06		inc $06				inc 	DCodePtr 					; skip over token
.011be0	e6 06		inc $06				inc 	DCodePtr
.011be2	80 d2		bra $011bb6			bra 	FRun_NextInstruction 		; do the following instruction.
.011be4					_FRun_TryLET:
.011be4	b2 06		lda ($06)			lda 	(DCodePtr) 					; look to see if it's an identifier.
.011be6	c9 00 c0	cmp #$c000			cmp 	#$C000
.011be9	90 05		bcc $011bf0			bcc		_FRunSyntax 				; no, must be syntax.
.011beb	20 59 12	jsr $011259			jsr 	Command_LET 				; try as a LET.
.011bee	80 c6		bra $011bb6			bra 	FRun_NextInstruction 		; if we get away with it, go to next instruction.
.011bf0					_FRunSyntax:
.011bf0	82 c9 e9	brl $0105bc			brl 	SyntaxError
.011bf3					_FRun_EndInstruction:
.011bf3	a5 22		lda $22				lda 	DLineNumber 				; if line number 0, warm start.
.011bf5	f0 0f		beq $011c06			beq 	_FRun_WarmStart
.011bf7	a5 06		lda $06				lda 	DCodePtr 					; address of terminating NULL.
.011bf9	1a		inc a				inc 	a 							; go to link for next line
.011bfa	1a		inc a				inc 	a
.011bfb	80 a7		bra $011ba4			bra 	FRun_NextLineNumber
.011bfd					_FRun_Break:
.011bfd	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>011c00	42 72 65 61 6b 00				.text 	"Break",$00 								; with this message
.011c06					_FRun_WarmStart:
.011c06	82 64 03	brl $011f6d			brl 	WarmStart
.011c09					Command_NEW:
.011c09	a9 00 02	lda #$0200			lda	 	#Block_ProgramStart
.011c0c	18		clc				clc
.011c0d	65 02		adc $02				adc 	DBaseAddress
.011c0f	a8		tay				tay
.011c10	a9 00 00	lda #$0000			lda 	#$0000
.011c13	99 00 00	sta $0000,y			sta 	$0000,y
.011c16	80 00		bra $011c18			bra 	Command_Clear
.011c18					Command_CLEAR:
.011c18	20 24 1c	jsr $011c24			jsr 	ClearVariablesPointersAndStacks
.011c1b	60		rts				rts
.011c1c					Command_STOP:
.011c1c	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>011c1f	53 74 6f 70 00					.text 	"Stop",$00 								; with this message
.011c24					ClearVariablesPointersAndStacks:
.011c24	a9 80 00	lda #$0080			lda 	#BASStack
.011c27	85 2a		sta $2a				sta 	DStack
.011c29	64 80		stz $80				stz 	BASStack 					; any structure popping this => error
.011c2b	a0 0c 00	ldy #$000c			ldy 	#Block_NullString
.011c2e	a9 00 00	lda #$0000			lda 	#$0000
.011c31	91 02		sta ($02),y			sta 	(DBaseAddress),y
.011c33	20 5f 1c	jsr $011c5f			jsr 	FindCodeEnd 				; find where the program ends.
.011c36	a8		tay				tay 								; Y points to it.
.011c37	a9 ee ee	lda #$eeee			lda 	#$EEEE 						; put the marker in.
.011c3a	99 02 00	sta $0002,y			sta 	$0002,y
.011c3d	99 04 00	sta $0004,y			sta 	$0004,y
.011c40	98		tya				tya 								; start of working memory up
.011c41	18		clc				clc
.011c42	69 06 00	adc #$0006			adc 	#6
.011c45	a0 08 00	ldy #$0008			ldy 	#Block_LowMemoryPtr
.011c48	91 02		sta ($02),y			sta 	(DBaseAddress),y
.011c4a	a0 80 00	ldy #$0080			ldy 	#Block_HashTable
.011c4d					_FCLoop:
.011c4d	a9 00 00	lda #$0000			lda 	#$0000
.011c50	91 02		sta ($02),y			sta 	(DBaseAddress),y
.011c52	c8		iny				iny
.011c53	c8		iny				iny
.011c54	c0 00 01	cpy #$0100			cpy 	#Block_HashTable+Block_HashTableEntrySize*4*2
.011c57	d0 f4		bne $011c4d			bne 	_FCLoop
.011c59	64 16		stz $16				stz 	DTempStringPointer
.011c5b	20 71 06	jsr $010671			jsr 	StringResetPermanent
.011c5e	60		rts				rts
.011c5f					FindCodeEnd:
.011c5f	a9 00 02	lda #$0200			lda 	#Block_ProgramStart 		; offset to program
.011c62	18		clc				clc
.011c63	65 02		adc $02				adc 	DBaseAddress 				; now an actual address
.011c65	a8		tay				tay
.011c66					_FCELoop:
.011c66	b9 00 00	lda $0000,y			lda 	$0000,y 					; get link.
.011c69	f0 08		beq $011c73			beq 	_FCEExit
.011c6b	98		tya				tya 								; add offset
.011c6c	18		clc				clc
.011c6d	79 00 00	adc $0000,y			adc 	$0000,y
.011c70	a8		tay				tay
.011c71	80 f3		bra $011c66			bra 	_FCELoop
.011c73					_FCEExit:
.011c73	98		tya				tya 								; return in A
.011c74	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/dim.asm

.011c75					Function_Dim:
.011c75	b2 06		lda ($06)			lda 	(DCodePtr)					; get the first token, for typing.
.011c77	29 00 10	and #$1000			and 	#IDArrayMask 				; is it an array ?
.011c7a	f0 2e		beq $011caa			beq		_FDIMNotArray 				; no, error.
.011c7c	20 9a 03	jsr $01039a			jsr 	VariableFind 				; try to find it.
.011c7f	b0 34		bcs $011cb5			bcs 	_FDIMExists 				; if it does, that's an error.
.011c81	20 4d 04	jsr $01044d			jsr 	VariableCreate 				; create the empty variable.
.011c84	48		pha				pha 								; save array address on the stack.
.011c85	20 0d 03	jsr $01030d			jsr 	EvaluateInteger 			; evaluate the size
.011c88	20 f7 05	jsr $0105f7			jsr 	ExpectRightBracket 			; check the ) following.
.011c8b	c0 00 00	cpy #$0000			cpy 	#0 							; if MSWord is non zero, obviously it's a non starter.
.011c8e	d0 3b		bne $011ccb			bne 	_FDIMSize
.011c90	c9 00 00	cmp #$0000			cmp 	#0 							; need at least one element.
.011c93	f0 36		beq $011ccb			beq 	_FDIMSize
.011c95	20 dc 1c	jsr $011cdc			jsr 	DIMCreateArrayBlock 		; create and return empty array, size A+1.
.011c98	7a		ply				ply 								; this is where it goes.
.011c99	99 00 00	sta $0000,y			sta 	$0000,y 					; pointer to first array level block.
.011c9c	b2 06		lda ($06)			lda 	(DCodePtr)					; look at next character
.011c9e	c9 24 32	cmp #$3224			cmp 	#commaTokenID 				; if not a comma, exit
.011ca1	d0 06		bne $011ca9			bne 	_FDIMExit
.011ca3	e6 06		inc $06				inc 	DCodePtr 					; skip comma
.011ca5	e6 06		inc $06				inc 	DCodePtr
.011ca7	80 cc		bra $011c75			bra 	Function_DIM 				; and do another
.011ca9					_FDIMExit:
.011ca9	60		rts				rts
.011caa					_FDIMNotArray:
.011caa	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>011cad	42 61 64 20 44 49 4d 00				.text 	"Bad DIM",$00 								; with this message
.011cb5					_FDIMExists:
.011cb5	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>011cb8	43 61 6e 6e 6f 74 20 52				.text 	"Cannot Redimension",$00 								; with this message
>011cc0	65 64 69 6d 65 6e 73 69 6f 6e 00
.011ccb					_FDIMSize:
.011ccb	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>011cce	44 49 4d 20 74 6f 6f 20				.text 	"DIM too large",$00 								; with this message
>011cd6	6c 61 72 67 65 00
.011cdc					DIMCreateArrayBlock:
.011cdc	48		pha				pha 								; save max index for later.
.011cdd	1a		inc a				inc 	a 							; work out size + 1 x 4
.011cde	0a		asl a				asl 	a 							; array(7) has 8 elements indexed from zero.
.011cdf	b0 34		bcs $011d15			bcs 	_DCABFail
.011ce1	0a		asl a				asl 	a
.011ce2	b0 31		bcs $011d15			bcs 	_DCABFail
.011ce4	18		clc				clc 								; 2 for size word, the first word is the max index.
.011ce5	69 02 00	adc #$0002			adc 	#2
.011ce8	b0 2b		bcs $011d15			bcs 	_DCABFail
.011cea	85 08		sta $08				sta 	DTemp1 						; save this total size.
.011cec	a0 08 00	ldy #$0008			ldy 	#Block_LowMemoryPtr 		; add to pointer.
.011cef	b1 02		lda ($02),y			lda 	(DBaseAddress),y
.011cf1	48		pha				pha 								; save return address
.011cf2	18		clc				clc
.011cf3	65 08		adc $08				adc 	DTemp1
.011cf5	91 02		sta ($02),y			sta 	(DBaseAddress),y
.011cf7	a0 0a 00	ldy #$000a			ldy 	#Block_HighMemoryPtr
.011cfa	d1 02		cmp ($02),y			cmp 	(DBaseAddress),y
.011cfc	b0 17		bcs $011d15			bcs 	_DCABFail
.011cfe	a6 08		ldx $08				ldx 	DTemp1
.011d00	7a		ply				ply
.011d01	5a		phy				phy
.011d02					_DCABClear:
.011d02	a9 00 00	lda #$0000			lda 	#0
.011d05	99 00 00	sta $0000,y			sta 	$0000,y
.011d08	c8		iny				iny
.011d09	c8		iny				iny
.011d0a	ca		dex				dex
.011d0b	ca		dex				dex
.011d0c	d0 f4		bne $011d02			bne 	_DCABClear
.011d0e	7a		ply				ply 								; restore start address
.011d0f	68		pla				pla 								; restore high index
.011d10	99 00 00	sta $0000,y			sta 	$0000,y 					; save high index
.011d13	98		tya				tya 								; return in A.
.011d14	60		rts				rts
.011d15					_DCABFail:
.011d15	82 b4 e8	brl $0105cc			brl 	OutOfMemoryError

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/memwrite.asm

.011d18					Command_POKE:
.011d18	20 0d 03	jsr $01030d			jsr 	EvaluateInteger 			; address
.011d1b	48		pha				pha	 								; save on stack
.011d1c	5a		phy				phy
.011d1d	20 00 06	jsr $010600			jsr 	ExpectComma 				; comma seperator.
.011d20	20 0d 03	jsr $01030d			jsr 	EvaluateInteger 			; data
.011d23	fa		plx				plx 								; pull address and store in DTemp1
.011d24	86 0a		stx $0a				stx 	DTemp1+2
.011d26	fa		plx				plx
.011d27	86 08		stx $08				stx 	DTemp1+0
.011d29	e2 20		sep #$20			sep 	#$20 						; byte mode
.011d2b	87 08		sta [$08]			sta 	[DTemp1]					; write it
.011d2d	c2 20		rep #$20			rep 	#$20 						; word mode
.011d2f	60		rts				rts
.011d30					Command_DOKE:
.011d30	20 0d 03	jsr $01030d			jsr 	EvaluateInteger 			; address
.011d33	48		pha				pha	 								; save on stack
.011d34	5a		phy				phy
.011d35	20 00 06	jsr $010600			jsr 	ExpectComma 				; comma seperator.
.011d38	20 0d 03	jsr $01030d			jsr 	EvaluateInteger 			; data
.011d3b	fa		plx				plx 								; pull address and store in DTemp1
.011d3c	86 0a		stx $0a				stx 	DTemp1+2
.011d3e	fa		plx				plx
.011d3f	86 08		stx $08				stx 	DTemp1+0
.011d41	87 08		sta [$08]			sta 	[DTemp1]					; write it
.011d43	60		rts				rts
.011d44					Command_LOKE:
.011d44	20 0d 03	jsr $01030d			jsr 	EvaluateInteger 			; address
.011d47	48		pha				pha	 								; save on stack
.011d48	5a		phy				phy
.011d49	20 00 06	jsr $010600			jsr 	ExpectComma 				; comma seperator.
.011d4c	20 0d 03	jsr $01030d			jsr 	EvaluateInteger 			; data
.011d4f	fa		plx				plx 								; pull address and store in DTemp1
.011d50	86 0a		stx $0a				stx 	DTemp1+2
.011d52	fa		plx				plx
.011d53	86 08		stx $08				stx 	DTemp1+0
.011d55	87 08		sta [$08]			sta 	[DTemp1]					; write it (low)
.011d57	98		tya				tya
.011d58	a0 02 00	ldy #$0002			ldy 	#2
.011d5b	97 08		sta [$08],y			sta 	[DTemp1],y 					; write it (high)
.011d5d	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/miscellany.asm

.011d5e					Command_ASSERT:
.011d5e	20 0d 03	jsr $01030d			jsr 	EvaluateInteger 			; something that returns an integer.
.011d61	84 08		sty $08				sty 	DTemp1 						; check if result is zero.
.011d63	05 08		ora $08				ora 	Dtemp1
.011d65	f0 01		beq $011d68			beq 	_FAssFail
.011d67	60		rts				rts
.011d68					_FAssFail:
.011d68	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>011d6b	61 73 73 65 72 74 20 66				.text 	"assert failed",$00 								; with this message
>011d73	61 69 6c 65 64 00
.011d79					Command_CLS:
.011d79	20 05 1e	jsr $011e05			jsr 	HWClearScreen
.011d7c	60		rts				rts
.011d7d					Command_REM:
.011d7d	b2 06		lda ($06)			lda 	(DCodePtr) 					; get code ptr.
.011d7f	f0 0f		beq $011d90			beq 	_FRemExit 					; no comment present
.011d81	c9 26 32	cmp #$3226			cmp 	#colonTokenID
.011d84	f0 0a		beq $011d90			beq 	_FRemExit 					; no comment present
.011d86	c9 00 01	cmp #$0100			cmp 	#$0100 						; if not $00xx syntax error
.011d89	b0 06		bcs $011d91			bcs 	_FRemSyntax
.011d8b	18		clc				clc 								; add to DCodePtr
.011d8c	65 06		adc $06				adc 	DCodePtr
.011d8e	85 06		sta $06				sta 	DCodePtr
.011d90					_FRemExit:
.011d90	60		rts				rts
.011d91					_FRemSyntax:
.011d91	82 28 e8	brl $0105bc			brl 	SyntaxError
.011d94					Command_LINK:
.011d94	20 0d 03	jsr $01030d			jsr 	EvaluateInteger 			; call address same page.
.011d97	85 08		sta $08				sta 	DTemp1 						; target address
.011d99	84 0a		sty $0a				sty 	DTemp1+2
.011d9b	7b		tdc				tda 								; work out what the actual address is
.011d9c	18		clc				clc
.011d9d	69 08 00	adc #$0008			adc 	#DTemp1
.011da0	8f d5 1d 01	sta $011dd5			sta 	_FLIExecuteIt+1 			; and overwrite it. Surely to fuck there has
.011da4	a4 02		ldy $02				ldy 	DBaseAddress 				; point Y to DBaseAddress + Load
.011da6	b9 10 00	lda $0010,y			lda 	("A"-"A")*4+Block_FastVariables,y
.011da9	48		pha				pha
.011daa	b9 6c 00	lda $006c,y			lda 	("X"-"A")*4+Block_FastVariables,y
.011dad	aa		tax				tax
.011dae	b9 70 00	lda $0070,y			lda 	("Y"-"A")*4+Block_FastVariables,y
.011db1	a8		tay				tay
.011db2	68		pla				pla
.011db3	22 d4 1d 01	jsl $011dd4			jsl 	_FLIExecuteIt
.011db7	5a		phy				phy 								; save Y
.011db8	a4 02		ldy $02				ldy 	DBaseAddress 				; point Y to DBaseAddress + Save
.011dba	99 10 00	sta $0010,y			sta 	("A"-"A")*4+Block_FastVariables,y
.011dbd	8a		txa				txa
.011dbe	99 6c 00	sta $006c,y			sta 	("X"-"A")*4+Block_FastVariables,y
.011dc1	68		pla				pla
.011dc2	99 70 00	sta $0070,y			sta 	("Y"-"A")*4+Block_FastVariables,y
.011dc5	c8		iny				iny 								; point to their high bytes and clear them
.011dc6	c8		iny				iny
.011dc7	a9 00 00	lda #$0000			lda 	#0
.011dca	99 10 00	sta $0010,y			sta 	("A"-"A")*4+Block_FastVariables,y
.011dcd	99 6c 00	sta $006c,y			sta 	("X"-"A")*4+Block_FastVariables,y
.011dd0	99 70 00	sta $0070,y			sta 	("Y"-"A")*4+Block_FastVariables,y
.011dd3	60		rts				rts
.011dd4					_FLIExecuteIt:
.011dd4	dc 08 00	jmp [$0008]			jmp 	[DTemp1]					; go wherever.
.011dd7					Command_VDU:
.011dd7	20 0d 03	jsr $01030d			jsr 	EvaluateInteger 			; get integer to YA.
.011dda	a8		tay				tay 								; put into Y
.011ddb	29 ff 00	and #$00ff			and 	#$00FF 						; mask out LSB
.011dde	20 1e 1e	jsr $011e1e			jsr 	HWPrintChar 				; print the LSB.
.011de1	b2 06		lda ($06)			lda 	(DCodePtr)
.011de3	c9 24 32	cmp #$3224			cmp 	#commaTokenID 				; if , goto next
.011de6	f0 0e		beq $011df6			beq 	_CVDUNext
.011de8	c9 25 32	cmp #$3225			cmp 	#semicolonTokenID 			; if ; print MSB and goto next
.011deb	f0 01		beq $011dee			beq 	_CVDUHighByte
.011ded					_CVDUExit:
.011ded	60		rts				rts
.011dee					_CVDUHighByte:
.011dee	98		tya				tya 								; get back.
.011def	eb		xba				xba 								; byte swap
.011df0	29 ff 00	and #$00ff			and 	#$00FF 						; mask and print
.011df3	20 1e 1e	jsr $011e1e			jsr 	HWPrintChar
.011df6					_CVDUNext:
.011df6	e6 06		inc $06				inc 	DCodePtr 					; skip , ;
.011df8	e6 06		inc $06				inc 	DCodePtr
.011dfa	b2 06		lda ($06)			lda 	(DCodePtr)					; continue ?
.011dfc	f0 ef		beq $011ded			beq		_CVDUExit
.011dfe	c9 26 32	cmp #$3226			cmp 	#colonTokenID
.011e01	f0 ea		beq $011ded			beq 	_CVDUExit
.011e03	80 d2		bra $011dd7			bra 	Command_VDU

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/utility/hwinterface.asm

=$f8020					HWCursor = $F8020 							; cursor position r/w
=$f8010					HWKeyPressed = $F8010 						; current key pressed (inkey) r
=$f8000					HWBreakKey = $F8000 						; non-zero if break pressed
=$f0000					HWScreen = $F0000							; screen RAM base
=$f8100					InputBuffer = $F8100 						; area of memory for input buffer.
=$f8200					LastKey = $F8200 							; last key pressed.
=64					sWidth = 64									; this is a quick hack so these must be powers of 2
=32					sHeight = 32 								; in this implementation.
.011e05					HWClearScreen:
.011e05	48		pha				pha
.011e06	da		phx				phx
.011e07	a2 fe 07	ldx #$07fe			ldx 	#sWidth*sHeight-2 			; fill screen memory with space
.011e0a	a9 20 20	lda #$2020	_CS0:	lda 	#$2020
.011e0d	9f 00 00 0f	sta $0f0000,x			sta 	$F0000,x
.011e11	ca		dex				dex
.011e12	10 f6		bpl $011e0a			bpl 	_CS0
.011e14	a9 00 00	lda #$0000			lda 	#0 							; reposition cursor
.011e17	8f 20 80 0f	sta $0f8020			sta 	HWCursor
.011e1b	fa		plx				plx
.011e1c	68		pla				pla
.011e1d	60		rts				rts
.011e1e					HWPrintChar:
.011e1e	48		pha				pha
.011e1f	da		phx				phx
.011e20	5a		phy				phy
.011e21	48		pha				pha 								; cursor position -> X
.011e22	af 20 80 0f	lda $0f8020			lda 	HWCursor
.011e26	aa		tax				tax
.011e27	68		pla				pla
.011e28	c9 ff ff	cmp #$ffff			cmp 	#-1
.011e2b	f0 08		beq $011e35			beq 	_HWPCNoWrite
.011e2d	e2 20		sep #$20			sep 	#$20 						; write character to screen.
.011e2f	9f 00 00 0f	sta $0f0000,x			sta 	$F0000,x
.011e33	c2 20		rep #$20			rep 	#$20
.011e35					_HWPCNoWrite:
.011e35	e8		inx				inx 								; bump cursor position.
.011e36	8a		txa				txa
.011e37	8f 20 80 0f	sta $0f8020			sta 	HWCursor
.011e3b	c9 00 08	cmp #$0800			cmp 	#(sWidth*sHeight) 			; reached end of screen
.011e3e	d0 2b		bne $011e6b			bne 	_HWNotEnd
.011e40	38		sec				sec 	 							; back up one line
.011e41	e9 40 00	sbc #$0040			sbc 	#sWidth
.011e44	8f 20 80 0f	sta $0f8020			sta 	HWCursor
.011e48	a2 00 00	ldx #$0000			ldx 	#0 							; scroll screen up.
.011e4b					_HWScrollUp:
.011e4b	bf 40 00 0f	lda $0f0040,x			lda 	$F0000+sWidth,x
.011e4f	9f 00 00 0f	sta $0f0000,x			sta 	$F0000,x
.011e53	e8		inx				inx
.011e54	e8		inx				inx
.011e55	e0 00 08	cpx #$0800			cpx 	#sWidth*sHeight
.011e58	d0 f1		bne $011e4b			bne 	_HWScrollUp
.011e5a	a2 c0 07	ldx #$07c0			ldx 	#(sWidth*(sHeight-1))		; clear bottom line.
.011e5d					_HWBlank:
.011e5d	a9 20 20	lda #$2020			lda 	#$2020
.011e60	9f 00 00 0f	sta $0f0000,x			sta 	$F0000,x
.011e64	e8		inx				inx
.011e65	e8		inx				inx
.011e66	e0 00 08	cpx #$0800			cpx 	#sWidth*sHeight
.011e69	d0 f2		bne $011e5d			bne 	_HWBlank
.011e6b					_HWNotEnd:
.011e6b	7a		ply				ply
.011e6c	fa		plx				plx
.011e6d	68		pla				pla
.011e6e	60		rts				rts
.011e6f					HWNewLine:
.011e6f	48		pha				pha
.011e70	da		phx				phx
.011e71	a2 3f 00	ldx #$003f			ldx 	#sWidth-1 					; print spaces until X & position = 0
.011e74					HWMoveCursor:
.011e74	a9 ff ff	lda #$ffff			lda 	#-1
.011e77	20 1e 1e	jsr $011e1e			jsr 	HWPrintChar
.011e7a	8a		txa				txa
.011e7b	2f 20 80 0f	and $0f8020			and 	HWCursor
.011e7f	d0 f3		bne $011e74			bne 	HWMoveCursor
.011e81	fa		plx				plx
.011e82	68		pla				pla
.011e83	60		rts				rts
.011e84	48		pha		HWTab:	pha
.011e85	da		phx				phx
.011e86	a2 07 00	ldx #$0007			ldx 	#7
.011e89	80 e9		bra $011e74			bra 	HWMoveCursor
.011e8b					HWCheckBreak:
.011e8b	af 00 80 0f	lda $0f8000			lda 	HWBreakKey
.011e8f	60		rts				rts
.011e90					HWInkey:
.011e90	af 10 80 0f	lda $0f8010			lda 	HWKeyPressed
.011e94	60		rts				rts
.011e95					HWInputLine:
.011e95	20 90 1e	jsr $011e90			jsr 	HWInkey 					; get a keystroke.
.011e98	cf 00 82 0f	cmp $0f8200			cmp 	LastKey
.011e9c	f0 f7		beq $011e95			beq 	HWInputLine
.011e9e					_HWILWait:
.011e9e	20 90 1e	jsr $011e90			jsr 	HWInkey
.011ea1	c9 00 00	cmp #$0000			cmp		#0
.011ea4	f0 f8		beq $011e9e			beq 	_HWILWait
.011ea6	8f 00 82 0f	sta $0f8200			sta 	LastKey
.011eaa	c9 20 00	cmp #$0020			cmp 	#32 						; control check
.011ead	90 2f		bcc $011ede			bcc 	_HWILControl
.011eaf	20 1e 1e	jsr $011e1e			jsr 	HWPrintChar 				; print out.
.011eb2	80 e1		bra $011e95			bra 	HWInputLine 				; loop back.
.011eb4					_HWILBackSpace:
.011eb4	af 20 80 0f	lda $0f8020			lda 	HWCursor
.011eb8	f0 db		beq $011e95			beq 	HWInputLine
.011eba	aa		tax				tax
.011ebb	ca		dex				dex
.011ebc	a9 20 00	lda #$0020			lda 	#" "
.011ebf	e2 20		sep #$20			sep 	#$20
.011ec1	9f 00 00 0f	sta $0f0000,x			sta 	$F0000,x
.011ec5	c2 20		rep #$20			rep 	#$20
.011ec7	a2 ff ff	ldx #$ffff			ldx 	#-1
.011eca					_HWILMove:
.011eca	8a		txa				txa
.011ecb	18		clc				clc
.011ecc	6f 20 80 0f	adc $0f8020			adc 	HWCursor
.011ed0	29 ff 07	and #$07ff			and 	#(sWidth*sHeight-1)
.011ed3	8f 20 80 0f	sta $0f8020			sta 	HWCursor
.011ed7	80 bc		bra $011e95			bra 	HWInputLine
.011ed9					_HWILClear:
.011ed9	20 05 1e	jsr $011e05			jsr 	HWClearScreen
.011edc	80 b7		bra $011e95			bra 	HWInputLine
.011ede					_HWILControl:
.011ede	c9 09 00	cmp #$0009			cmp 	#9 							; tab
.011ee1	f0 60		beq $011f43			beq 	_HWILTab
.011ee3	c9 08 00	cmp #$0008			cmp 	#8 							; backspace.
.011ee6	f0 cc		beq $011eb4			beq 	_HWILBackSpace
.011ee8	a2 c0 ff	ldx #$ffc0			ldx 	#-sWidth 					; Ctrl WASD move cursor
.011eeb	c9 17 00	cmp #$0017			cmp 	#23
.011eee	f0 da		beq $011eca			beq 	_HWILMove
.011ef0	a2 40 00	ldx #$0040			ldx 	#sWidth
.011ef3	c9 13 00	cmp #$0013			cmp 	#19
.011ef6	f0 d2		beq $011eca			beq 	_HWILMove
.011ef8	a2 ff ff	ldx #$ffff			ldx 	#-1
.011efb	c9 01 00	cmp #$0001			cmp 	#1
.011efe	f0 ca		beq $011eca			beq 	_HWILMove
.011f00	a2 01 00	ldx #$0001			ldx 	#1
.011f03	c9 04 00	cmp #$0004			cmp 	#4
.011f06	f0 c2		beq $011eca			beq 	_HWILMove
.011f08	c9 0c 00	cmp #$000c			cmp 	#12 						; Ctrl L Clear Screen/Home
.011f0b	f0 cc		beq $011ed9			beq 	_HWILClear
.011f0d	c9 0d 00	cmp #$000d			cmp 	#13
.011f10	d0 83		bne $011e95			bne 	HWInputLine
.011f12	af 20 80 0f	lda $0f8020			lda 	HWCursor 					; cursor position
.011f16	29 c0 ff	and #$ffc0			and 	#$FFC0 						; start of line.
.011f19	85 08		sta $08				sta 	DTemp1 						; pointer in DTemp1
.011f1b	a9 0f 00	lda #$000f			lda 	#$000F
.011f1e	85 0a		sta $0a				sta 	DTemp1+2
.011f20	a0 00 00	ldy #$0000			ldy 	#0 							; set up for copy
.011f23					_HWILCopy:
.011f23	bb		tyx				tyx
.011f24	b7 08		lda [$08],y			lda 	[DTemp1],y
.011f26	9f 00 81 0f	sta $0f8100,x			sta 	InputBuffer,x
.011f2a	c8		iny				iny
.011f2b	c8		iny				iny
.011f2c	c0 40 00	cpy #$0040			cpy 	#64 						; done the whole line ?
.011f2f	d0 f2		bne $011f23			bne 	_HWILCopy
.011f31	a9 00 00	lda #$0000			lda 	#0
.011f34	bb		tyx				tyx
.011f35	9f 00 81 0f	sta $0f8100,x			sta 	InputBuffer,x 				; add trailing zero.
.011f39	20 6f 1e	jsr $011e6f			jsr 	HWNewLine 					; next line.
.011f3c	a9 00 81	lda #$8100			lda 	#InputBuffer & $FFFF
.011f3f	a0 0f 00	ldy #$000f			ldy 	#InputBuffer >> 16
.011f42	60		rts				rts
.011f43					_HWILTab:
.011f43	20 84 1e	jsr $011e84			jsr 	HWTab
.011f46	82 4c ff	brl $011e95			brl 	HWInputLine

;******  Return to file: ../source/basic.asm

=$2000					IDTypeMask = $2000 									; bit masks in identifier.
=$1000					IDArrayMask = $1000
=$0800					IDContMask = $0800
=8					UnaryFunction = 8 									; Unary function Token Type ID.
=9					TokenShift = 9										; Token shift to reach precedence.
.011f49					SwitchBasicInstance:
.011f49	c2 30		rep #$30			rep 	#$30 								; 16 bit A:X mode.
.011f4b	20 05 1e	jsr $011e05			jsr 	HWClearScreen 						; clear screen
.011f4e	29 ff 00	and #$00ff			and 	#$00FF 								; make page number 24 bit
.011f51	85 00		sta $00				sta 	DPageNumber 						; save page, base, high in RAM.
.011f53	86 02		stx $02				stx		DBaseAddress
.011f55	84 04		sty $04				sty 	DHighAddress
.011f57	ba		tsx				tsx 										; save the current SP.
.011f58	86 3a		stx $3a				stx 	DStack65816
.011f5a	eb		xba				xba 										; put the page number (goes in the DBR) in B
.011f5b	48		pha				pha 										; then copy it into B.
.011f5c	ab		plb				plb
.011f5d	ab		plb				plb
.011f5e	20 24 1c	jsr $011c24			jsr 	ClearVariablesPointersAndStacks		; clear all variables etc.
.011f61	a0 0e 00	ldy #$000e			ldy 	#Block_BootFlag 					; if boot flag zero, warm start
.011f64	b1 02		lda ($02),y			lda 	(DBaseAddress),y
.011f66	f0 05		beq $011f6d			beq 	WarmStart
.011f68	3a		dec a				dec 	a 									; decrement zero.
.011f69	91 02		sta ($02),y			sta 	(DBaseAddress),y
.011f6b	80 18		bra $011f85			bra 	ExecuteTokenBuffer 					; execute contents of token buffer.
.011f6d					WarmStart:
.011f6d	a2 d3 1f	ldx #$1fd3			ldx 	#BasicPrompt & $FFFF
.011f70	20 39 06	jsr $010639			jsr 	PrintROMMessage
.011f73					NextCommand:
.011f73	a6 3a		ldx $3a				ldx 	DStack65816 						; reset the CPU stack
.011f75	9a		txs				txs
.011f76	64 16		stz $16				stz 	DTempStringPointer 					; reset the
.011f78	a0 0e 00	ldy #$000e			ldy 	#Block_BootFlag 					; if the boot flag is non-zero
.011f7b	b1 02		lda ($02),y			lda 	(DBaseAddress),y 					; then exit the emulator.
.011f7d	d0 52		bne $011fd1			bne 	ExitEmulator
.011f7f	20 95 1e	jsr $011e95			jsr 	HWInputLine 						; read line to YA.
.011f82	20 7d 07	jsr $01077d			jsr 	Tokenise 							; tokenise it.
.011f85					ExecuteTokenBuffer:
.011f85	a0 00 01	ldy #$0100			ldy 	#Block_TokenBuffer 					; get the first token
.011f88	b1 02		lda ($02),y			lda 	(DBaseAddress),y
.011f8a	f0 e7		beq $011f73			beq 	NextCommand 						; nothing.
.011f8c	c9 00 40	cmp #$4000			cmp 	#$4000 								; if not a number token, execute it
.011f8f	90 27		bcc $011fb8			bcc 	_ETBCommand
.011f91	c9 00 c0	cmp #$c000			cmp 	#$C000
.011f94	b0 22		bcs $011fb8			bcs 	_ETBCommand
.011f96	38		sec				sec
.011f97	e9 00 40	sbc #$4000			sbc 	#$4000 								; put in range 0-32767
.011f9a	f0 1f		beq $011fbb			beq 	_ETBError
.011f9c	48		pha				pha
.011f9d	20 c0 04	jsr $0104c0			jsr 	LineDelete 							; delete the line, if it exists.
.011fa0	20 24 1c	jsr $011c24			jsr 	ClearVariablesPointersAndStacks		; clear all variables etc.
.011fa3	a9 02 01	lda #$0102			lda 	#Block_TokenBuffer+2				; get the code for the line, e.g. next token
.011fa6	18		clc				clc
.011fa7	65 02		adc $02				adc 	DBaseAddress
.011fa9	a8		tay				tay 										; Y contains the code.
.011faa	b9 00 00	lda $0000,y			lda 	$0000,y 							; is there any code ?
.011fad	f0 c4		beq $011f73			beq 	NextCommand 						; no, next command.
.011faf	68		pla				pla 										; line number in A, code in Y.
.011fb0	20 fb 04	jsr $0104fb			jsr 	LineInsert 							; insert the line
.011fb3	20 24 1c	jsr $011c24			jsr 	ClearVariablesPointersAndStacks		; clear all variables etc.
.011fb6	80 bb		bra $011f73			bra 	NextCommand
.011fb8					_ETBCommand:
.011fb8	4c 98 1b	jmp $011b98			jmp 	RUNExecuteTokenBuffer 				; execute the token buffer
.011fbb					_ETBError:
.011fbb	20 7f 05	jsr $01057f			jsr 	ErrorHandler 						; call error routine
>011fbe	43 61 6e 6e 6f 74 20 68				.text 	"Cannot have line 0",$00 								; with this message
>011fc6	61 76 65 20 6c 69 6e 65 20 30 00
.011fd1					ExitEmulator:
.011fd1	02 00		cop #$00			cop 	#0
.011fd3					BasicPrompt:
>011fd3	52 65 61 64 79 2e 0d 00				.text 	"Ready.",13,0

;******  Return to file: ../source/start.asm


;******  Processing file: ../source/utility/testing.asm

.01f000	82 00 00	brl $01f003			brl 	TokenCheckCode
.01f003					TokenCheckCode:
.01f003	a9 00 b0	lda #$b000			lda 	#$B000 								; the text is at $2B000
.01f006	a0 02 00	ldy #$0002			ldy 	#2
.01f009	20 7d 07	jsr $01077d			jsr 	Tokenise
.01f00c	a6 02		ldx $02				ldx 	DBaseAddress
.01f00e	a0 00 00	ldy #$0000			ldy 	#0
.01f011					_TokeniserTestLoop:
.01f011	bd 00 01	lda $0100,x			lda 	Block_TokenBuffer,x					; compare workspace vs answer
.01f014	d9 00 b2	cmp $b200,y			cmp 	$B200,y
.01f017					_TokeniserError:
.01f017	d0 fe		bne $01f017			bne 	_TokeniserError
.01f019	e8		inx				inx
.01f01a	e8		inx				inx
.01f01b	c8		iny				iny
.01f01c	c8		iny				iny
.01f01d	c9 00 00	cmp #$0000			cmp 	#0
.01f020	d0 ef		bne $01f011			bne 	_TokeniserTestLoop
.01f022	02 00		cop #$00			cop 	#0 									; exit successfully.
.01f024	6b		rtl				rtl

;******  Return to file: ../source/start.asm

.024000					CodeSpace:
>024000	42 41 53 43 00 00 00 00				.binary "temp/basic.bin"
>024008	94 44 00 c0 00 00 01 00 00 00 00 00 00 00 00 00
>024018	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
;	...repeated 13 times (208 bytes)...
>0240f8	00 00 00 00 00 00 00 00 30 3e 00 00 00 00 00 00
>024108	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
;	...repeated 14 times (224 bytes)...
>0241f8	00 00 00 00 00 00 00 00 0e 00 64 00 ed c4 06 22
>024208	03 10 66 46 00 00 12 00 6f 00 ff e4 06 22 08 00
>024218	05 53 74 72 23 31 00 00 1a 00 74 00 2c e5 06 22
>024228	08 00 05 53 74 72 23 32 26 32 ee c4 06 22 26 40
>024238	00 00 16 00 75 00 35 3e ed c4 24 32 ee c4 24 32
>024248	ff e4 24 32 2c e5 00 00 20 00 76 00 41 3e e4 da
>024258	2b db 4a d2 8f 43 24 32 0c 00 08 50 6f 6c 69 63
>024268	65 20 21 00 28 32 00 00 26 00 77 00 41 3e e4 da
>024278	2b db 4a d2 ed c4 0a 24 10 67 24 32 04 00 01 3c
>024288	0a 24 ff e4 0a 24 04 00 01 3e 28 32 00 00 16 00
>024298	7a 00 35 3e ed c4 24 32 ee c4 24 32 ff e4 24 32
>0242a8	2c e5 00 00 0c 00 7b 00 41 3e f5 c8 97 c3 00 00
>0242b8	16 00 82 00 35 3e ed c4 24 32 ee c4 24 32 ff e4
>0242c8	24 32 2c e5 00 00 0c 00 8c 00 41 3e f5 c8 97 c3
>0242d8	00 00 16 00 96 00 35 3e ed c4 24 32 ee c4 24 32
>0242e8	ff e4 24 32 2c e5 00 00 08 00 a0 00 2f 3e 00 00
>0242f8	0c 00 e8 03 48 3c f5 c8 97 c3 00 00 16 00 ed 03
>024308	42 3e ed c4 24 32 ee c4 24 32 ff e4 24 32 2c e5
>024318	00 00 26 00 f1 03 35 3e 0e 00 0a 49 6e 20 74 65
>024328	73 74 23 31 20 00 24 32 ed c4 24 32 ee c4 24 32
>024338	ff e4 24 32 2c e5 00 00 0c 00 f2 03 ed c4 06 22
>024348	cf 47 00 00 0c 00 fc 03 ee c4 06 22 9a 42 00 00
>024358	30 00 fd 03 ff e4 06 22 06 00 03 49 6e 31 26 32
>024368	2c e5 06 22 1a 00 16 41 6c 74 65 72 6e 61 74 65
>024378	20 53 74 72 69 6e 67 20 2e 2e 2e 2e 2e 00 00 00
>024388	26 00 00 04 35 3e 0e 00 0a 49 6e 20 74 65 73 74
>024398	23 32 20 00 24 32 ed c4 24 32 ee c4 24 32 ff e4
>0243a8	24 32 2c e5 00 00 10 00 02 04 41 3e c4 cb 1e ca
>0243b8	e3 cb 21 c2 00 00 26 00 04 04 35 3e 0e 00 0a 49
>0243c8	6e 20 74 65 73 74 23 33 20 00 24 32 ed c4 24 32
>0243d8	ee c4 24 32 ff e4 24 32 2c e5 00 00 08 00 4c 04
>0243e8	4e 3a 00 00 10 00 b0 04 48 3c c4 cb 1e ca e3 cb
>0243f8	21 c2 00 00 0e 00 ba 04 42 3e ed c4 24 32 ee c4
>024408	00 00 14 00 c4 04 ed c4 06 22 01 40 26 32 ee c4
>024418	06 22 02 40 00 00 24 00 ce 04 35 3e 0c 00 08 53
>024428	75 62 6c 65 76 65 6c 00 24 32 ed c4 24 32 ee c4
>024438	24 32 ff e4 24 32 2c e5 00 00 08 00 d8 04 4e 3a
>024448	00 00 1a 00 14 05 48 3c e4 da 2b db 4a d2 ed cc
>024458	1d c0 24 32 ff ec 1d e0 28 32 00 00 22 00 1e 05
>024468	35 3e 0e 00 0a 49 6e 20 54 50 61 72 61 6d 20 00
>024478	24 32 ed cc 1d c0 24 32 ff ec 1d e0 00 00 08 00
>024488	28 05 4e 3a 00 00 00 00 ee ee ee ee 00 00 00 00
>024498	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
;	...repeated 1973 times (31568 bytes)...
>02bff8	00 00 00 00 00 00 00 00
.02c000					CodeEndSpace:

;******  End of listing
