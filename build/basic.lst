
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass --m65816 -f -q -o basic.bin -L basic.lst ../source/start.asm
; Mon Jun 24 20:26:59 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: ../source/start.asm

.0000	18		clc				clc											; switch into 65816 16 bit mode.
.0001	fb		xce				xce
.0002	c2 30		rep #$30			rep 	#$30
.0004	a2 fe f3	ldx #$f3fe			ldx 	#DirectPage+CPUStack 				; 65816 Stack
.0007	9a		txs				txs
.0008	a9 00 f0	lda #$f000			lda 	#DirectPage 						; set Direct Page.
.000b	5b		tcd				tcd
.000c	a9 02 00	lda #$0002			lda 	#CodeSpace >> 16 					; put the page number in A ($2)
.000f	a2 00 40	ldx #$4000			ldx 	#CodeSpace & $FFFF 					; and the base address in X ($4000)
.0012	a0 00 c0	ldy #$c000			ldy 	#CodeEndSpace & $FFFF				; and the end address in Y ($C000)
.0015	5c 4e 1f 01	jmp $011f4e			jmp 	SwitchBasicInstance

;******  Processing file: ../source/basic.asm

.010000					StartOfBasicCode:

;******  Processing file: ../source/temp/block.inc

=$0010					Block_FastVariables = $0010
=$0080					Block_HashTable = $0080
=$000f					Block_HashMask = $000f
=$0008					Block_LowMemoryPtr = $0008
=$000a					Block_HighMemoryPtr = $000a
=$000c					Block_NullString = $000c
=$000e					Block_BootFlag = $000e
=$0200					Block_ProgramStart = $0200
=$0100					Block_TokenBuffer = $0100
=$0010					Block_HashTableEntrySize = $0010

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/temp/tokens.inc

.010000					CommandJumpTable:
>010000	ae 05					.word IllegalToken & $FFFF ; for the $0000 token.
>010002	00 0b					.word Binary_And               & $FFFF ; token $2001 "&"
>010004	10 0b					.word Binary_Or                & $FFFF ; token $2002 "|"
>010006	20 0b					.word Binary_Xor               & $FFFF ; token $2003 "^"
>010008	64 0b					.word Binary_Less              & $FFFF ; token $2204 "<"
>01000a	cb 0b					.word Binary_Greater           & $FFFF ; token $2205 ">"
>01000c	30 0b					.word Binary_Equals            & $FFFF ; token $2206 "="
>01000e	ad 0b					.word Binary_LessEqual         & $FFFF ; token $2207 "<="
>010010	8f 0b					.word Binary_GreaterEqual      & $FFFF ; token $2208 ">="
>010012	4a 0b					.word Binary_NotEquals         & $FFFF ; token $2209 "<>"
>010014	4a 0a					.word Binary_Add               & $FFFF ; token $240a "+"
>010016	cb 0a					.word Binary_Subtract          & $FFFF ; token $240b "-"
>010018	db 0c					.word Binary_Multiply          & $FFFF ; token $260c "*"
>01001a	54 0c					.word Binary_Divide            & $FFFF ; token $260d "/"
>01001c	cf 0c					.word Binary_Modulus           & $FFFF ; token $260e "%"
>01001e	dc 0a					.word Binary_ShiftRight        & $FFFF ; token $260f ">>"
>010020	ee 0a					.word Binary_ShiftLeft         & $FFFF ; token $2610 "<<"
>010022	69 0d					.word Function_Random          & $FFFF ; token $3011 "rnd("
>010024	49 0d					.word Function_Sgn             & $FFFF ; token $3012 "sgn("
>010026	25 0d					.word Function_Abs             & $FFFF ; token $3013 "abs("
>010028	0f 0d					.word Function_Len             & $FFFF ; token $3014 "len("
>01002a	91 0f					.word Function_VAL             & $FFFF ; token $3015 "val("
>01002c	b1 10					.word Function_Str             & $FFFF ; token $3016 "str$("
>01002e	a3 0d					.word Function_Chr             & $FFFF ; token $3017 "chr$("
>010030	db 0d					.word Function_Asc             & $FFFF ; token $3018 "asc("
>010032	0f 0e					.word Function_SPC             & $FFFF ; token $3019 "spc("
>010034	45 0f					.word Function_Peek            & $FFFF ; token $301a "peek("
>010036	5f 0f					.word Function_Deek            & $FFFF ; token $301b "deek("
>010038	76 0f					.word Function_Leek            & $FFFF ; token $301c "leek("
>01003a	1a 12					.word Function_LOWER           & $FFFF ; token $301d "lower$("
>01003c	d8 11					.word Function_UPPER           & $FFFF ; token $301e "upper$("
>01003e	59 0e					.word Function_LEFT            & $FFFF ; token $301f "left$("
>010040	f0 0e					.word Function_MID             & $FFFF ; token $3020 "mid$("
>010042	82 0e					.word Function_RIGHT           & $FFFF ; token $3021 "right$("
>010044	71 11					.word Function_INSTR           & $FFFF ; token $3022 "instr("
>010046	4b 0e					.word Function_Inkey           & $FFFF ; token $3023 "inkey("
>010048	ae 05					.word IllegalToken             & $FFFF ; token $3224 ","
>01004a	ae 05					.word IllegalToken             & $FFFF ; token $3225 ";"
>01004c	ae 05					.word IllegalToken             & $FFFF ; token $3226 ":"
>01004e	ae 05					.word IllegalToken             & $FFFF ; token $3227 "("
>010050	ae 05					.word IllegalToken             & $FFFF ; token $3228 ")"
>010052	ae 05					.word IllegalToken             & $FFFF ; token $3229 "'"
>010054	ae 05					.word IllegalToken             & $FFFF ; token $382a "to"
>010056	ae 05					.word IllegalToken             & $FFFF ; token $382b "step"
>010058	82 1d					.word Command_REM              & $FFFF ; token $3e2c "rem"
>01005a	5c 12					.word Command_Let              & $FFFF ; token $3e2d "let"
>01005c	62 1d					.word Command_ASSERT           & $FFFF ; token $3e2e "assert"
>01005e	8e 1b					.word Command_END              & $FFFF ; token $3e2f "end"
>010060	91 1b					.word Command_RUN              & $FFFF ; token $3e30 "run"
>010062	20 1c					.word Command_STOP             & $FFFF ; token $3e31 "stop"
>010064	1c 1c					.word Command_CLEAR            & $FFFF ; token $3e32 "clear"
>010066	79 1c					.word Function_Dim             & $FFFF ; token $3e33 "dim"
>010068	7e 1d					.word Command_CLS              & $FFFF ; token $3e34 "cls"
>01006a	2c 17					.word Command_PRINT            & $FFFF ; token $3e35 "print"
>01006c	1c 1a					.word Command_GOTO             & $FFFF ; token $3e36 "goto"
>01006e	7b 1a					.word Command_GOSUB            & $FFFF ; token $3e37 "gosub"
>010070	97 1a					.word Command_RETURN           & $FFFF ; token $3e38 "return"
>010072	d9 19					.word Command_ONGOTO           & $FFFF ; token $3e39 "on"
>010074	df 17					.word Handler_ELSE             & $FFFF ; token $3e3a "else"
>010076	1c 1d					.word Command_POKE             & $FFFF ; token $3e3b "poke"
>010078	34 1d					.word Command_DOKE             & $FFFF ; token $3e3c "doke"
>01007a	48 1d					.word Command_LOKE             & $FFFF ; token $3e3d "loke"
>01007c	f4 14					.word Command_List             & $FFFF ; token $3e3e "list"
>01007e	99 1d					.word Command_LINK             & $FFFF ; token $3e3f "link"
>010080	0d 1c					.word Command_NEW              & $FFFF ; token $3e40 "new"
>010082	d3 12					.word Command_PROC             & $FFFF ; token $3e41 "proc"
>010084	1e 14					.word Command_LOCAL            & $FFFF ; token $3e42 "local"
>010086	dc 1d					.word Command_VDU              & $FFFF ; token $3e43 "vdu"
>010088	c9 1a					.word Command_REPEAT           & $FFFF ; token $3c44 "repeat"
>01008a	27 1b					.word Command_WHILE            & $FFFF ; token $3c45 "while"
>01008c	78 17					.word Command_IF               & $FFFF ; token $3c46 "if"
>01008e	b4 18					.word Command_FOR              & $FFFF ; token $3c47 "for"
>010090	ae 05					.word IllegalToken             & $FFFF ; token $3c48 "defproc"
>010092	5e 1b					.word Command_WEND             & $FFFF ; token $3a49 "wend"
>010094	e0 1a					.word Command_UNTIL            & $FFFF ; token $3a4a "until"
>010096	ae 05					.word IllegalToken             & $FFFF ; token $3a4b "then"
>010098	0d 18					.word Handler_ENDIF            & $FFFF ; token $3a4c "endif"
>01009a	1d 19					.word Command_NEXT             & $FFFF ; token $3a4d "next"
>01009c	e9 13					.word Command_ENDPROC          & $FFFF ; token $3a4e "endproc"
.01009e					TokenText:
>01009e	02 26					 .text $02,"&"        ; token $2001
>0100a0	02 7c					 .text $02,"|"        ; token $2002
>0100a2	02 5e					 .text $02,"^"        ; token $2003
>0100a4	12 3c					 .text $12,"<"        ; token $2204
>0100a6	12 3e					 .text $12,">"        ; token $2205
>0100a8	12 3d					 .text $12,"="        ; token $2206
>0100aa	13 3c 3d				 .text $13,"<="       ; token $2207
>0100ad	13 3e 3d				 .text $13,">="       ; token $2208
>0100b0	13 3c 3e				 .text $13,"<>"       ; token $2209
>0100b3	22 2b					 .text $22,"+"        ; token $240a
>0100b5	22 2d					 .text $22,"-"        ; token $240b
>0100b7	32 2a					 .text $32,"*"        ; token $260c
>0100b9	32 2f					 .text $32,"/"        ; token $260d
>0100bb	32 25					 .text $32,"%"        ; token $260e
>0100bd	33 3e 3e				 .text $33,">>"       ; token $260f
>0100c0	33 3c 3c				 .text $33,"<<"       ; token $2610
>0100c3	85 52 4e 44 28				 .text $85,"RND("     ; token $3011
>0100c8	85 53 47 4e 28				 .text $85,"SGN("     ; token $3012
>0100cd	85 41 42 53 28				 .text $85,"ABS("     ; token $3013
>0100d2	85 4c 45 4e 28				 .text $85,"LEN("     ; token $3014
>0100d7	85 56 41 4c 28				 .text $85,"VAL("     ; token $3015
>0100dc	86 53 54 52 24 28			 .text $86,"STR$("    ; token $3016
>0100e2	86 43 48 52 24 28			 .text $86,"CHR$("    ; token $3017
>0100e8	85 41 53 43 28				 .text $85,"ASC("     ; token $3018
>0100ed	85 53 50 43 28				 .text $85,"SPC("     ; token $3019
>0100f2	86 50 45 45 4b 28			 .text $86,"PEEK("    ; token $301a
>0100f8	86 44 45 45 4b 28			 .text $86,"DEEK("    ; token $301b
>0100fe	86 4c 45 45 4b 28			 .text $86,"LEEK("    ; token $301c
>010104	88 4c 4f 57 45 52 24 28			 .text $88,"LOWER$("  ; token $301d
>01010c	88 55 50 50 45 52 24 28			 .text $88,"UPPER$("  ; token $301e
>010114	87 4c 45 46 54 24 28			 .text $87,"LEFT$("   ; token $301f
>01011b	86 4d 49 44 24 28			 .text $86,"MID$("    ; token $3020
>010121	88 52 49 47 48 54 24 28			 .text $88,"RIGHT$("  ; token $3021
>010129	87 49 4e 53 54 52 28			 .text $87,"INSTR("   ; token $3022
>010130	87 49 4e 4b 45 59 28			 .text $87,"INKEY("   ; token $3023
>010137	92 2c					 .text $92,","        ; token $3224
>010139	92 3b					 .text $92,";"        ; token $3225
>01013b	92 3a					 .text $92,":"        ; token $3226
>01013d	92 28					 .text $92,"("        ; token $3227
>01013f	92 29					 .text $92,")"        ; token $3228
>010141	92 27					 .text $92,"'"        ; token $3229
>010143	c3 54 4f				 .text $c3,"TO"       ; token $382a
>010146	c5 53 54 45 50				 .text $c5,"STEP"     ; token $382b
>01014b	f4 52 45 4d				 .text $f4,"REM"      ; token $3e2c
>01014f	f4 4c 45 54				 .text $f4,"LET"      ; token $3e2d
>010153	f7 41 53 53 45 52 54			 .text $f7,"ASSERT"   ; token $3e2e
>01015a	f4 45 4e 44				 .text $f4,"END"      ; token $3e2f
>01015e	f4 52 55 4e				 .text $f4,"RUN"      ; token $3e30
>010162	f5 53 54 4f 50				 .text $f5,"STOP"     ; token $3e31
>010167	f6 43 4c 45 41 52			 .text $f6,"CLEAR"    ; token $3e32
>01016d	f4 44 49 4d				 .text $f4,"DIM"      ; token $3e33
>010171	f4 43 4c 53				 .text $f4,"CLS"      ; token $3e34
>010175	f6 50 52 49 4e 54			 .text $f6,"PRINT"    ; token $3e35
>01017b	f5 47 4f 54 4f				 .text $f5,"GOTO"     ; token $3e36
>010180	f6 47 4f 53 55 42			 .text $f6,"GOSUB"    ; token $3e37
>010186	f7 52 45 54 55 52 4e			 .text $f7,"RETURN"   ; token $3e38
>01018d	f3 4f 4e				 .text $f3,"ON"       ; token $3e39
>010190	f5 45 4c 53 45				 .text $f5,"ELSE"     ; token $3e3a
>010195	f5 50 4f 4b 45				 .text $f5,"POKE"     ; token $3e3b
>01019a	f5 44 4f 4b 45				 .text $f5,"DOKE"     ; token $3e3c
>01019f	f5 4c 4f 4b 45				 .text $f5,"LOKE"     ; token $3e3d
>0101a4	f5 4c 49 53 54				 .text $f5,"LIST"     ; token $3e3e
>0101a9	f5 4c 49 4e 4b				 .text $f5,"LINK"     ; token $3e3f
>0101ae	f4 4e 45 57				 .text $f4,"NEW"      ; token $3e40
>0101b2	f5 50 52 4f 43				 .text $f5,"PROC"     ; token $3e41
>0101b7	f6 4c 4f 43 41 4c			 .text $f6,"LOCAL"    ; token $3e42
>0101bd	f4 56 44 55				 .text $f4,"VDU"      ; token $3e43
>0101c1	e7 52 45 50 45 41 54			 .text $e7,"REPEAT"   ; token $3c44
>0101c8	e6 57 48 49 4c 45			 .text $e6,"WHILE"    ; token $3c45
>0101ce	e3 49 46				 .text $e3,"IF"       ; token $3c46
>0101d1	e4 46 4f 52				 .text $e4,"FOR"      ; token $3c47
>0101d5	e8 44 45 46 50 52 4f 43			 .text $e8,"DEFPROC"  ; token $3c48
>0101dd	d5 57 45 4e 44				 .text $d5,"WEND"     ; token $3a49
>0101e2	d6 55 4e 54 49 4c			 .text $d6,"UNTIL"    ; token $3a4a
>0101e8	d5 54 48 45 4e				 .text $d5,"THEN"     ; token $3a4b
>0101ed	d6 45 4e 44 49 46			 .text $d6,"ENDIF"    ; token $3a4c
>0101f3	d5 4e 45 58 54				 .text $d5,"NEXT"     ; token $3a4d
>0101f8	d8 45 4e 44 50 52 4f 43			 .text $d8,"ENDPROC"  ; token $3a4e
>010200	00					.byte $00
=$2001					ampersandTokenID                 = $2001
=$2002					barTokenID                       = $2002
=$2003					hatTokenID                       = $2003
=$2204					lessTokenID                      = $2204
=$2205					greaterTokenID                   = $2205
=$2206					equalTokenID                     = $2206
=$2207					lessequalTokenID                 = $2207
=$2208					greaterequalTokenID              = $2208
=$2209					lessgreaterTokenID               = $2209
=$240a					plusTokenID                      = $240a
=$240b					minusTokenID                     = $240b
=$260c					starTokenID                      = $260c
=$260d					slashTokenID                     = $260d
=$260e					percentTokenID                   = $260e
=$260f					greatergreaterTokenID            = $260f
=$2610					lesslessTokenID                  = $2610
=$3011					rndlparenTokenID                 = $3011
=$3012					sgnlparenTokenID                 = $3012
=$3013					abslparenTokenID                 = $3013
=$3014					lenlparenTokenID                 = $3014
=$3015					vallparenTokenID                 = $3015
=$3016					strdollarlparenTokenID           = $3016
=$3017					chrdollarlparenTokenID           = $3017
=$3018					asclparenTokenID                 = $3018
=$3019					spclparenTokenID                 = $3019
=$301a					peeklparenTokenID                = $301a
=$301b					deeklparenTokenID                = $301b
=$301c					leeklparenTokenID                = $301c
=$301d					lowerdollarlparenTokenID         = $301d
=$301e					upperdollarlparenTokenID         = $301e
=$301f					leftdollarlparenTokenID          = $301f
=$3020					middollarlparenTokenID           = $3020
=$3021					rightdollarlparenTokenID         = $3021
=$3022					instrlparenTokenID               = $3022
=$3023					inkeylparenTokenID               = $3023
=$3224					commaTokenID                     = $3224
=$3225					semicolonTokenID                 = $3225
=$3226					colonTokenID                     = $3226
=$3227					lparenTokenID                    = $3227
=$3228					rparenTokenID                    = $3228
=$3229					squoteTokenID                    = $3229
=$382a					toTokenID                        = $382a
=$382b					stepTokenID                      = $382b
=$3e2c					remTokenID                       = $3e2c
=$3e2d					letTokenID                       = $3e2d
=$3e2e					assertTokenID                    = $3e2e
=$3e2f					endTokenID                       = $3e2f
=$3e30					runTokenID                       = $3e30
=$3e31					stopTokenID                      = $3e31
=$3e32					clearTokenID                     = $3e32
=$3e33					dimTokenID                       = $3e33
=$3e34					clsTokenID                       = $3e34
=$3e35					printTokenID                     = $3e35
=$3e36					gotoTokenID                      = $3e36
=$3e37					gosubTokenID                     = $3e37
=$3e38					returnTokenID                    = $3e38
=$3e39					onTokenID                        = $3e39
=$3e3a					elseTokenID                      = $3e3a
=$3e3b					pokeTokenID                      = $3e3b
=$3e3c					dokeTokenID                      = $3e3c
=$3e3d					lokeTokenID                      = $3e3d
=$3e3e					listTokenID                      = $3e3e
=$3e3f					linkTokenID                      = $3e3f
=$3e40					newTokenID                       = $3e40
=$3e41					procTokenID                      = $3e41
=$3e42					localTokenID                     = $3e42
=$3e43					vduTokenID                       = $3e43
=$3c44					repeatTokenID                    = $3c44
=$3c45					whileTokenID                     = $3c45
=$3c46					ifTokenID                        = $3c46
=$3c47					forTokenID                       = $3c47
=$3c48					defprocTokenID                   = $3c48
=$3a49					wendTokenID                      = $3a49
=$3a4a					untilTokenID                     = $3a4a
=$3a4b					thenTokenID                      = $3a4b
=$3a4c					endifTokenID                     = $3a4c
=$3a4d					nextTokenID                      = $3a4d
=$3a4e					endprocTokenID                   = $3a4e

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/data.asm

=$f000					DirectPage = $F000
=$00					DPBaseAddress = $00 						; Base address used for direct page.
=0					DPageNumber = DPBaseAddress+0 				; page number of workspace area (upper 8 bits of address)
=2					DBaseAddress = DPBaseAddress+2 				; low memory for workspace area
=4					DHighAddress = DPBaseAddress+4 				; high memory for workspace area
=6					DCodePtr = DPBaseAddress+6 					; address of code - current token.
=8					DTempStringPointer = DPBaseAddress + 8	 	; memory allocated to temp string pointer, going down.
=10					DStartTempString = DPBaseAddress + 10 		; start of current temporary string
=12					DCurrentTempString = DPBaseAddress + 12 	; current position in temporary string.
=14					DConstantShift = DPBaseAddress + 14 		; constant shift store.
=16					DVariablePtr = DPBaseAddress + 16			; address of found variable.
=18					DHashTablePtr = DPBaseAddress + 18 			; address of hash entry of searched variable.
=20					DLineNumber = DPBaseAddress + 20 			; current line number.
=22					DSignCount = DPBaseAddress + 22				; Sign count in division.
=24					DCursor = DPBaseAddress + 24 				; cursor (for external routines, not used by BASIC)
=26					DStack = DPBaseAddress + 26					; BASIC stack pointer.
=28					DIndent = DPBaseAddress + 28 				; indent for LIST
=30					DIndent2 = DPBaseAddress + 30 				; previous indent.
=32					DListBuffer = DPBaseAddress + 32 			; list buffer address.
=34					DStack65816 = DPBaseAddress + 34 			; 65816 Stack pointer.
=64					DLongVars = DPBaseAddress + $40 			; 4 byte variables.
=64					DTemp1 = DLongVars + 0 						; general temporary variables.
=68					DTemp2 = DLongVars + 4
=72					DTemp3 = DLongVars + 8
=76					DTemp4 = DLongVars + 12
=80					DTemp5 = DLongVars + 16
=84					DRandom = DLongVars + 20 					; random seed
=$80					PRMBuffer = $80							 	; buffer for parameter values.
=$c0					BASStack = $C0 								; start of Basic stack.
=0					EXSValueL = 0 								; Low word
=2					EXSValueH = 2  								; High word
=4					EXSPrecType = 4								; Precedence level / type is in bit 15, 1 = string.
=6					EXSNext = 6 								; offset to next level.
=1022					CPUStack = $400-2 							; CPU Stack initial value.

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/expression.asm

.010201					Evaluate:
.010201	a5 1a		lda $1a				lda		DStack 						; reset the stack
.010203	18		clc				clc
.010204	69 10 00	adc #$0010			adc 	#16
.010207	aa		tax				tax
.010208	a9 00 00	lda #$0000			lda 	#0<<TokenShift 				; start at the lowest precedence level.
.01020b					EvaluateLevel:
.01020b	29 ff 7f	and #$7fff			and 	#$7FFF 						; zero type bit, which means integer unless we change it.
.01020e	95 04		sta $04,x			sta 	EXSPrecType+0,x 			; save precedence level.
.010210	b2 06		lda ($06)			lda 	(DCodePtr)					; look at the next token
.010212	c9 00 c0	cmp #$c000			cmp 	#$C000 						; if $C000-$CFFF then variable.
.010215	b0 75		bcs $01028c			bcs 	_ELVariable
.010217	c9 00 40	cmp #$4000			cmp 	#$4000 						; if $4000-$BFFF then constant
.01021a	b0 16		bcs $010232			bcs 	_ELConstant
.01021c	c9 00 10	cmp #$1000			cmp 	#$1000 						; if $0000-$00FF then it's a end of line or string.
.01021f	90 7b		bcc $01029c			bcc 	_ELStringConstant
.010221	c9 00 20	cmp #$2000			cmp 	#$2000 						; if $1000-$1FFF then it's a constant shift
.010224	90 03		bcc $010229			bcc 	_ELConstantShift
.010226	82 90 00	brl $0102b9			brl 	_ELUnaryKeyword 			; if $2000-$3FFF then it's a unary operator/keyword
.010229					_ELConstantShift:
.010229	29 ff 0f	and #$0fff			and 	#$0FFF 						; mask out bits 11-0
.01022c	85 0e		sta $0e				sta 	DConstantShift 				; save in constant shift
.01022e	e6 06		inc $06				inc 	DCodePtr 					; skip over the token.
.010230	e6 06		inc $06				inc 	DCodePtr
.010232					_ELConstant:
.010232	b2 06		lda ($06)			lda 	(DCodePtr)					; get the constant value
.010234	38		sec				sec  								; shift it in the range 0-32767
.010235	e9 00 40	sbc #$4000			sbc 	#$4000
.010238	0a		asl a				asl 	a 							; shift it left, losing bit 15
.010239	46 0e		lsr $0e				lsr 	DConstantShift 				; shift constant right into carry.
.01023b	6a		ror a				ror 	a 							; rotate that into the constant value
.01023c	95 00		sta $00,x			sta 	EXSValueL+0,x 				; save as low word
.01023e	a5 0e		lda $0e				lda 	DConstantShift 				; constant shift is high word.
.010240	95 02		sta $02,x			sta 	EXSValueH+0,x
.010242	64 0e		stz $0e				stz 	DConstantShift 				; clear the constant shift
.010244	e6 06		inc $06				inc 	DCodePtr 					; skip over constant
.010246	e6 06		inc $06				inc 	DCodePtr
.010248					_ELGotAtom:
.010248	b2 06		lda ($06)			lda 	(DCodePtr) 					; get code pointer.
.01024a	a8		tay				tay 								; save in Y
.01024b	29 00 f0	and #$f000			and 	#$F000 						; is it 0010 xxxk e.g. a binary operator.
.01024e	c9 00 20	cmp #$2000			cmp 	#$2000 						; if not then exit
.010251	d0 31		bne $010284			bne 	_ELExit
.010253	b5 04		lda $04,x			lda 	EXSPrecType+0,x 			; get precedence/type
.010255	29 00 1e	and #$1e00			and 	#15 << TokenShift 			; mask out the precedence bits.
.010258	85 40		sta $40				sta 	DTemp1 						; save in temporary register
.01025a	98		tya				tya 								; get the keyword token back
.01025b	29 00 1e	and #$1e00			and 	#15 << TokenShift 			; mask out the precedence bits.
.01025e	c5 40		cmp $40				cmp 	DTemp1 						; compare against precedence of the new binary operator.
.010260	90 22		bcc $010284			bcc 	_ELExit 					; precedence too low, then exit.
.010262	5a		phy				phy 								; save the binary operator on the stack
.010263	e6 06		inc $06				inc 	DCodePtr 					; skip over the binary operator.
.010265	e6 06		inc $06				inc 	DCodePtr
.010267	18		clc				clc 								; try the next level up
.010268	69 00 02	adc #$0200			adc 	#1 << TokenShift
.01026b	20 05 03	jsr $010305			jsr 	EvaluateNextGivenLevel
.01026e	7a		ply				ply 								; get operator token back into Y
.01026f					_ELExecuteY:
.01026f	98		tya				tya
.010270	29 ff 01	and #$01ff			and 	#$01FF 						; keyword ID.
.010273	0a		asl a				asl 	a 							; double it as keyword vector table is word data
.010274	9b		txy				txy 								; save X in Y
.010275	aa		tax				tax 								; double keyword ID in X
.010276	bf 00 00 01	lda $010000,x			lda 	CommandJumpTable,x 			; this is the vector address
.01027a	bb		tyx				tyx 								; restore X.
.01027b	8f 80 02 01	sta $010280			sta 	_ELCallRoutine+1 			; Self modifying, will not work in ROM.
.01027f					_ELCallRoutine:
.01027f	20 7f 02	jsr $01027f			jsr 	_ELCallRoutine 				; call the new address *MODIFIED*
.010282	80 c4		bra $010248			bra 	_ELGotAtom 					; go round operator level again.
.010284	b5 04		lda $04,x	_ELExit:lda 	EXSPrecType+0,x 			; type into carry
.010286	0a		asl a				asl 	a
.010287	b5 00		lda $00,x			lda 	EXSValueL+0,x 				; put result into YA
.010289	b4 02		ldy $02,x			ldy 	EXSValueH+0,x
.01028b	60		rts				rts
.01028c					_ELVariable:
.01028c	16 04		asl $04,x			asl 	EXSPrecType+0,x 			; shift it left
.01028e	20 4f 03	jsr $01034f			jsr 	VariableAccessExpression	; this will be 'find variable, error if failed', get value.
.010291	95 00		sta $00,x			sta 	EXSValueL+0,x 				; save variable contents in stack
.010293	94 02		sty $02,x			sty 	EXSValueH+0,x
.010295	76 04		ror $04,x			ror 	EXSPrecType+0,x 			; shift right rotating the carry in.
.010297	80 af		bra $010248			bra 	_ELGotAtom
.010299					_ELSyntax
.010299	82 23 03	brl $0105bf			brl 	SyntaxError
.01029c					_ELStringConstant:
.01029c	09 00 00	ora #$0000			ora 	#0000 						; if it is $0000 then we have an error, end of line.
.01029f	f0 f8		beq $010299			beq 	_ELSyntax
.0102a1	a5 06		lda $06				lda 	DCodePtr 					; get the code pointer and add 2, to point to the string
.0102a3	1a		inc a				inc 	a
.0102a4	1a		inc a				inc 	a
.0102a5	95 00		sta $00,x			sta 	EXSValueL+0,x 				; this is the low word
.0102a7	74 02		stz $02,x			stz 	EXSValueH+0,x 				; high word is zero.
.0102a9	b2 06		lda ($06)			lda 	(DCodePtr)					; get length to skip
.0102ab	18		clc				clc 								; add to string constant.
.0102ac	65 06		adc $06				adc 	DCodePtr
.0102ae	85 06		sta $06				sta 	DCodePtr
.0102b0	b5 04		lda $04,x			lda 	EXSPrecType+0,x 			; set type to string
.0102b2	09 00 80	ora #$8000			ora 	#$8000
.0102b5	95 04		sta $04,x			sta 	EXSPrecType+0,x
.0102b7	80 8f		bra $010248			bra 	_ELGotAtom
.0102b9					_ELUnaryKeyword:
.0102b9	b2 06		lda ($06)			lda 	(DCodePtr)					; look at the next token
.0102bb	a8		tay				tay 								; put the token in Y.
.0102bc	e6 06		inc $06				inc 	DCodePtr 					; skip over it
.0102be	e6 06		inc $06				inc 	DCodePtr
.0102c0	29 00 1e	and #$1e00			and 	#15 << TokenShift			; mask out the keyword type.
.0102c3	c9 00 10	cmp #$1000			cmp 	#UnaryFunction<<TokenShift 	; if it is xxx1 000x then it's a unary function
.0102c6	f0 a7		beq $01026f			beq 	_ELExecuteY					; go back and execute it
.0102c8	c0 27 32	cpy #$3227			cpy 	#lparenTokenID 				; is it an open bracket ?
.0102cb	d0 11		bne $0102de			bne 	_ELUnaryOperator 			; it not, try unary operators.
.0102cd	20 02 03	jsr $010302			jsr 	EvaluateNext 				; evaluate the expression
.0102d0	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket 			; consume the right bracket.
.0102d3					_ELCopy:
.0102d3	b5 06		lda $06,x			lda 	EXSValueL+EXSNext,x 		; just copy the value
.0102d5	95 00		sta $00,x			sta 	EXSValueL+0,x
.0102d7	b5 08		lda $08,x			lda 	EXSValueH+EXSNext,x
.0102d9	95 02		sta $02,x			sta 	EXSValueH+0,x
.0102db	82 6a ff	brl $010248			brl 	_ELGotAtom 					; and continue.
.0102de					_ELUnaryOperator:
.0102de	5a		phy				phy 								; save the operator on the stack.
.0102df	20 fd 02	jsr $0102fd			jsr 	EvaluateNextAtomic 			; evaluate atom to be operated on.
.0102e2	68		pla				pla 								; restore the unary operator.
.0102e3	c9 0b 24	cmp #$240b			cmp 	#minusTokenID				; -xxx is unary negation
.0102e6	f0 03		beq $0102eb			beq 	_ELMinus
.0102e8	4c bf 05	jmp $0105bf			jmp 	SyntaxError
.0102eb					_ELMinus:
.0102eb	38		sec				sec 								; do the negation calculation.
.0102ec	a9 00 00	lda #$0000			lda 	#0
.0102ef	f5 06		sbc $06,x			sbc 	EXSValueL+EXSNext,x
.0102f1	95 00		sta $00,x			sta 	EXSValueL+0,x
.0102f3	a9 00 00	lda #$0000			lda 	#0
.0102f6	f5 08		sbc $08,x			sbc 	EXSValueH+EXSNext,x
.0102f8	95 02		sta $02,x			sta 	EXSValueH+0,x
.0102fa	82 4b ff	brl $010248			brl 	_ELGotAtom					; and continue.
.0102fd					EvaluateNextAtomic:
.0102fd	a9 00 0e	lda #$0e00			lda 	#7<<TokenShift
.010300	80 03		bra $010305			bra 	EvaluateNextGivenLevel
.010302					EvaluateNext:
.010302	a9 00 00	lda #$0000			lda 	#0<<TokenShift
.010305					EvaluateNextGivenLevel:
.010305	da		phx				phx
.010306	e8		inx				inx
.010307	e8		inx				inx
.010308	e8		inx				inx
.010309	e8		inx				inx
.01030a	e8		inx				inx
.01030b	e8		inx				inx
.01030c	20 0b 02	jsr $01020b			jsr 	EvaluateLevel
.01030f	fa		plx				plx
.010310	60		rts				rts
.010311					EvaluateInteger:
.010311	20 01 02	jsr $010201			jsr 	Evaluate
.010314	b0 01		bcs $010317			bcs 	EIType
.010316	60		rts				rts
.010317					EIType:
.010317	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>01031a	4e 75 6d 62 65 72 20 65				.text 	"Number expected",$00 								; with this message
>010322	78 70 65 63 74 65 64 00
.01032a					EvaluateNextInteger:
.01032a	20 02 03	jsr $010302			jsr 	EvaluateNext
.01032d	b0 e8		bcs $010317			bcs 	EIType
.01032f	60		rts				rts
.010330					EvaluateString:
.010330	20 01 02	jsr $010201			jsr 	Evaluate
.010333	90 01		bcc $010336			bcc 	ESType
.010335	60		rts				rts
.010336					ESType:
.010336	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>010339	53 74 72 69 6e 67 20 65				.text 	"String expected",$00 								; with this message
>010341	78 70 65 63 74 65 64 00
.010349					EvaluateNextString:
.010349	20 02 03	jsr $010302			jsr 	EvaluateNext
.01034c	90 e8		bcc $010336			bcc 	ESType
.01034e	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/variable.asm

.01034f					VariableAccessExpression:
.01034f	b2 06		lda ($06)			lda 	(DCodePtr)					; get the first token, push on stack
.010351	48		pha				pha
.010352	20 9e 03	jsr $01039e			jsr 	VariableFind 				; try to find the variables
.010355	85 10		sta $10				sta 	DVariablePtr 				; store the result in DVariablePtr
.010357	90 31		bcc $01038a			bcc 	_VANError 					; not found, so report an error.
.010359	68		pla				pla 								; get and save that first token
.01035a	48		pha				pha 								; we use it for typing.
.01035b	a8		tay				tay 								; put first token in Y.
.01035c	29 00 10	and #$1000			and 	#IDArrayMask 				; is it an array ?
.01035f	f0 07		beq $010368			beq 	_VANNotArray
.010361	a5 10		lda $10				lda 	DVariablePtr 				; variable pointer into A
.010363	20 15 04	jsr $010415			jsr 	VariableSubscript			; index calculation
.010366	85 10		sta $10				sta 	DVariablePtr 				; and write it back.
.010368					_VANNotArray:
.010368	68		pla				pla 								; get the token back.
.010369	29 00 20	and #$2000			and 	#IDTypeMask 				; this is the integer/string bit. $2000 if string, $0000 if int
.01036c	49 00 20	eor #$2000			eor 	#IDTypeMask 				; now $0000 if string, $2000 if integer.
.01036f	f0 0a		beq $01037b			beq 	_VANIsString 				; if zero, Y = 0 and just load the lower address with the variable (string)
.010371	18		clc				clc 								; returning a number, read high data word
.010372	a0 02 00	ldy #$0002			ldy 	#2
.010375	b1 10		lda ($10),y			lda 	(DVariablePtr),y
.010377	a8		tay				tay 								; put A into Y (this is the high byte)
.010378	b2 10		lda ($10)			lda 	(DVariablePtr)				; read the low data word
.01037a	60		rts				rts
.01037b					_VANIsString:
.01037b	a0 00 00	ldy #$0000			ldy 	#0 							; load string into YA
.01037e	b2 10		lda ($10)			lda 	(DVariablePtr)
.010380	d0 06		bne $010388			bne 	_VANNotEmptyString
.010382	a9 0c 00	lda #$000c			lda 	#Block_NullString 			; if value is $0000 then return the empty string
.010385	18		clc				clc 								; which is always maintained.
.010386	65 02		adc $02				adc 	DBaseAddress
.010388					_VANNotEmptyString:
.010388	38		sec				sec
.010389	60		rts				rts
.01038a					_VANError:
.01038a	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>01038d	56 61 72 69 61 62 6c 65				.text 	"Variable unknown",$00 								; with this message
>010395	20 75 6e 6b 6e 6f 77 6e 00
.01039e					VariableFind:
.01039e	b2 06		lda ($06)			lda 	(DCodePtr)					; look at the first token
.0103a0	c9 00 c0	cmp #$c000			cmp 	#$C000 						; must be $C000-$FFFF, an identifier.
.0103a3	90 5c		bcc $010401			bcc 	_VFError
.0103a5	c9 1b c0	cmp #$c01b			cmp 	#$C01A+1					; C01A is identifier, no continuation Z
.0103a8	b0 11		bcs $0103bb			bcs 	_VFSlowVariable 			; < this it is the fast variable A-Z
.0103aa	29 1f 00	and #$001f			and 	#$001F 						; now it is 1-26.
.0103ad	3a		dec a				dec 	a 							; now 0-25
.0103ae	0a		asl a				asl 	a 							; x 4 and clear carry
.0103af	0a		asl a				asl 	a
.0103b0	69 10 00	adc #$0010			adc 	#Block_FastVariables 		; offset to fast variables
.0103b3	65 02		adc $02				adc 	DBaseAddress 				; now an actual address in A
.0103b5	e6 06		inc $06				inc 	DCodePtr 					; skip over the token (only one)
.0103b7	e6 06		inc $06				inc 	DCodePtr
.0103b9	38		sec				sec 								; return with carry set.
.0103ba	60		rts				rts
.0103bb					_VFSlowVariable:
.0103bb	b2 06		lda ($06)			lda 	(DCodePtr)					; get the token
.0103bd	29 00 30	and #$3000			and 	#(IDTypeMask+IDArrayMask) 	; get the type bits out --tt ---- ---- ----
.0103c0	eb		xba				xba 								; now this is 0000 0000 00tt 0000 e.g. tt x 16
.0103c1	0a		asl a				asl 	a 							; 32 bytes (16 x 2 byteentries) per table, also clc
.0103c2	69 80 00	adc #$0080			adc 	#Block_HashTable 			; now its the correct has table offset
.0103c5	65 02		adc $02				adc 	DBaseAddress 				; now the actual address
.0103c7	85 40		sta $40				sta 	DTemp1 						; so this is the base of the hash table for the type
.0103c9	b2 06		lda ($06)			lda 	(DCodePtr) 					; get the token - building the hash code.
.0103cb	29 0f 00	and #$000f			and 	#Block_HashMask 			; now a mask value, very simple but okay I think.
.0103ce	0a		asl a				asl 	a 							; double (word entries) and clear carry
.0103cf	65 40		adc $40				adc 	DTemp1 						; add to the base hash table
.0103d1	85 12		sta $12				sta 	DHashTablePtr 				; save pointer for later
.0103d3	85 40		sta $40				sta 	DTemp1 						; save in DTemp1, which we will use to follow the chain.
.0103d5					_VFNext:
.0103d5	b2 40		lda ($40)			lda 	(DTemp1) 					; normally the link, first time will be the header.
.0103d7	f0 26		beq $0103ff			beq 	_VFFail 					; if zero, then it's the end of the list.
.0103d9	85 40		sta $40				sta 	DTemp1 						; this is the new variable record to check
.0103db	a8		tay				tay 								; read the address of the name at $0002,y
.0103dc	b9 02 00	lda $0002,y			lda 	$0002,y
.0103df	85 44		sta $44				sta 	DTemp2 						; save in DTemp2
.0103e1	a0 00 00	ldy #$0000			ldy 	#0 							; start matching lists of tokens, we can do it in words
.0103e4					_VFCompare:
.0103e4	b1 44		lda ($44),y			lda 	(DTemp2),y 					; see if they match
.0103e6	d1 06		cmp ($06),y			cmp 	(DCodePtr),y
.0103e8	d0 eb		bne $0103d5			bne 	_VFNext 					; if not, go to the next one.
.0103ea	c8		iny				iny 								; advance token pointer
.0103eb	c8		iny				iny
.0103ec	29 00 08	and #$0800			and 	#IDContMask 				; if continuation bit set, keep going (if they match)
.0103ef	d0 f3		bne $0103e4			bne 	_VFCompare
.0103f1	98		tya				tya 								; this is the length of the word.
.0103f2	18		clc				clc 								; so we add it to the code pointer
.0103f3	65 06		adc $06				adc 	DCodePtr
.0103f5	85 06		sta $06				sta 	DCodePtr 					; now points to the token after the identifier.
.0103f7	a5 40		lda $40				lda 	DTemp1 						; this is the variable record
.0103f9	18		clc				clc 								; four on is the actual data
.0103fa	69 04 00	adc #$0004			adc 	#4 							; or it's the reference for the data for arrays.
.0103fd	38		sec				sec 								; return with CS indicating success
.0103fe	60		rts				rts
.0103ff					_VFFail:
.0103ff	18		clc				clc
.010400	60		rts				rts
.010401					_VFError:
.010401	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>010404	4d 69 73 73 69 6e 67 20				.text 	"Missing variable",$00 								; with this message
>01040c	76 61 72 69 61 62 6c 65 00
.010415					VariableSubscript:
.010415	5a		phy				phy 								; save Y
.010416	a8		tay				tay 								; put the link pointer into Y
.010417	b9 00 00	lda $0000,y			lda 	$0000,y 					; read the link, this is the array data block.
.01041a	48		pha				pha		 							; save array data block address on stack.
.01041b	20 2a 03	jsr $01032a			jsr		EvaluateNextInteger 		; get the subscript
.01041e	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket 			; skip right bracket.
.010421	c0 00 00	cpy #$0000			cpy 	#0 							; msword must be zero
.010424	d0 14		bne $01043a			bne 	_VANSubscript
.010426	7a		ply				ply 								; start of array memory block.
.010427	d9 00 00	cmp $0000,y			cmp 	$0000,y						; the max index is at the start, so check against that.
.01042a	f0 02		beq $01042e			beq 	_VANSubOkay 				; fail if subscript > high subscript
.01042c	b0 0c		bcs $01043a			bcs 	_VANSubscript
.01042e					_VANSubOkay:
.01042e	0a		asl a				asl 	a 							; double lsword
.01042f	0a		asl a				asl 	a 							; and again, also clears carry.
.010430	85 40		sta $40				sta 	DTemp1	 					; 4 x subscript in DTemp1
.010432	98		tya				tya 								; restore the address of the array memory block.
.010433	1a		inc a				inc 	a 							; add 2 to get it past the high subscript
.010434	1a		inc a				inc 	a
.010435	18		clc				clc
.010436	65 40		adc $40				adc 	DTemp1 						; add the subscript x 4
.010438	7a		ply				ply 								; restore Y
.010439	60		rts				rts
.01043a					_VANSubscript:
.01043a	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>01043d	42 61 64 20 41 72 72 61				.text 	"Bad Array Subscript",$00 								; with this message
>010445	79 20 53 75 62 73 63 72 69 70 74 00
.010451					VariableCreate:
.010451	a0 08 00	ldy #$0008			ldy 	#Block_LowMemoryPtr 		; get low memory
.010454	b1 02		lda ($02),y			lda 	(DBaseAddress),y
.010456	48		pha				pha 								; save it
.010457	18		clc				clc
.010458	69 08 00	adc #$0008			adc 	#8
.01045b	91 02		sta ($02),y			sta 	(DBaseAddress),y 			; update low memory
.01045d	a0 0a 00	ldy #$000a			ldy 	#Block_HighMemoryPtr 		; check allocation.
.010460	d1 02		cmp ($02),y			cmp 	(DBaseAddress),y
.010462	b0 38		bcs $01049c			bcs 	_VCOutOfMemory
.010464	7a		ply				ply 								; restore new variable address to Y.
.010465	a9 00 00	lda #$0000			lda 	#$0000 						; clear that word to empty string/zero.
.010468	99 04 00	sta $0004,y			sta 	$0004,y 					; data from +4..+7 is zeroed.
.01046b	99 06 00	sta $0006,y			sta 	$0006,y
.01046e	b2 12		lda ($12)			lda 	(DHashTablePtr)				; get the link to next.
.010470	99 00 00	sta $0000,y			sta 	$0000,y 					; save at offset +0
.010473	a9 00 02	lda #$0200			lda 	#Block_ProgramStart 		; work out the program start
.010476	18		clc				clc 								; in DTemp1.
.010477	65 02		adc $02				adc 	DBaseAddress
.010479	85 40		sta $40				sta 	DTemp1
.01047b	a5 06		lda $06				lda 	DCodePtr 					; get the address of the token.
.01047d	c5 40		cmp $40				cmp 	DTemp1 						; if it is below the program start we need to clone it.
.01047f	b0 03		bcs $010484			bcs 	_VCDontClone 				; because the variable being created has its identifier
.010481	20 9f 04	jsr $01049f			jsr 	VCCloneIdentifier	 		; in the token workspace, done via the command line
.010484					_VCDontClone:
.010484	99 02 00	sta $0002,y			sta 	$0002,y 					; save at offset +2
.010487	98		tya				tya 								; update the head link
.010488	92 12		sta ($12)			sta 	(DHashTablePtr)
.01048a	18		clc				clc 								; advance pointer to the data part.
.01048b	69 04 00	adc #$0004			adc 	#4
.01048e	48		pha				pha 								; save on stack.
.01048f					_VCSkipToken:
.01048f	b2 06		lda ($06)			lda 	(DCodePtr) 					; skip over the token
.010491	e6 06		inc $06				inc 	DCodePtr
.010493	e6 06		inc $06				inc 	DCodePtr
.010495	29 00 08	and #$0800			and 	#IDContMask 				; if there is a continuation
.010498	d0 f5		bne $01048f			bne 	_VCSkipToken
.01049a	68		pla				pla 								; restore data address
.01049b	60		rts				rts 								; and done.
.01049c					_VCOutOfMemory:
.01049c	82 30 01	brl $0105cf			brl 	OutOfMemoryError
.01049f					VCCloneIdentifier:
.01049f	da		phx				phx 								; save XY
.0104a0	5a		phy				phy
.0104a1	aa		tax				tax 								; identifier address in Y.
.0104a2	a0 08 00	ldy #$0008			ldy 	#Block_LowMemoryPtr		 	; get low memory address, this will be the new identifier.
.0104a5	b1 02		lda ($02),y			lda 	(DBaseAddress),y
.0104a7	48		pha				pha
.0104a8					_VCCloneLoop:
.0104a8	a0 08 00	ldy #$0008			ldy 	#Block_LowMemoryPtr 		; get low memory
.0104ab	b1 02		lda ($02),y			lda 	(DBaseAddress),y
.0104ad	48		pha				pha 								; save on stack
.0104ae	1a		inc a				inc 	a 							; space for one token.
.0104af	1a		inc a				inc 	a
.0104b0	91 02		sta ($02),y			sta 	(DBaseAddress),y
.0104b2	7a		ply				ply 								; address of word in Y
.0104b3	bd 00 00	lda $0000,x			lda 	@w$0000,x 					; read the token
.0104b6	99 00 00	sta $0000,y			sta 	$0000,y 					; copy it into that new byte.
.0104b9	e8		inx				inx 								; advance the token pointer
.0104ba	e8		inx				inx
.0104bb	29 00 08	and #$0800			and 	#IDContMask 				; continuation ?
.0104be	d0 e8		bne $0104a8			bne 	_VCCloneLoop
.0104c0	68		pla				pla 								; restore start address
.0104c1	7a		ply				ply 								; and the others
.0104c2	fa		plx				plx
.0104c3	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/utility/editline.asm

.0104c4					LineDelete:
.0104c4	aa		tax				tax 	 							; this is the one we're looking for ....
.0104c5	a5 02		lda $02				lda 	DBaseAddress 				; work the start position
.0104c7	18		clc				clc
.0104c8	69 00 02	adc #$0200			adc 	#Block_ProgramStart
.0104cb	a8		tay				tay
.0104cc					_LDLoop:
.0104cc	b9 00 00	lda $0000,y			lda 	$0000,y 					; look at the link
.0104cf	f0 2d		beq $0104fe			beq 	_LDExit						; exit if zero ; line does not exist
.0104d1	8a		txa				txa 								; found a match
.0104d2	d9 02 00	cmp $0002,y			cmp 	$0002,y
.0104d5	f0 08		beq $0104df			beq		_LDFound
.0104d7	98		tya				tya 								; follow the link.
.0104d8	18		clc				clc
.0104d9	79 00 00	adc $0000,y			adc 	$0000,y
.0104dc	a8		tay				tay
.0104dd	80 ed		bra $0104cc			bra 	_LDLoop
.0104df					_LDFound:
.0104df	84 40		sty $40				sty 	DTemp1 						; copy to DTemp1
.0104e1	98		tya				tya 								; follow link to next.
.0104e2	18		clc				clc
.0104e3	79 00 00	adc $0000,y			adc 	$0000,y
.0104e6	85 44		sta $44				sta 	DTemp2 						; copy from DTemp2
.0104e8	20 63 1c	jsr $011c63			jsr 	FindCodeEnd 				; find the end of the code.
.0104eb	38		sec				sec
.0104ec	e5 44		sbc $44				sbc 	DTemp2 						; copy count
.0104ee	1a		inc a				inc 	a 							; copy the $0000 trailer (e.g. the last link/offset)
.0104ef	1a		inc a				inc 	a
.0104f0	aa		tax				tax
.0104f1	a0 00 00	ldy #$0000			ldy 	#0 							; block copy memory down.
.0104f4	b1 44		lda ($44),y	_LDCopy:lda 	(DTemp2),y
.0104f6	91 40		sta ($40),y			sta 	(DTemp1),y
.0104f8	c8		iny				iny
.0104f9	c8		iny				iny
.0104fa	ca		dex				dex
.0104fb	ca		dex				dex
.0104fc	d0 f6		bne $0104f4			bne 	_LDCopy
.0104fe					_LDExit:
.0104fe	60		rts				rts
.0104ff					LineInsert:
.0104ff	84 40		sty $40				sty 	DTemp1 						; save code in DTemp1
.010501	85 44		sta $44				sta 	DTemp2 						; save Line # in DTemp2
.010503	a0 00 00	ldy #$0000			ldy 	#0
.010506					_LIFindLength:
.010506	b1 40		lda ($40),y			lda 	(DTemp1),y 					; examine token
.010508	c9 00 00	cmp #$0000			cmp 	#$0000 						; if $0000 then found the end
.01050b	f0 10		beq $01051d			beq 	_LIFindEnd
.01050d	c9 00 01	cmp #$0100			cmp 	#$0100 						; if < $0100 then just skip it
.010510	90 04		bcc $010516			bcc 	_LIQString
.010512	c8		iny				iny 								; otherwise just skip it.
.010513	c8		iny				iny
.010514	80 f0		bra $010506			bra 	_LIFindLength
.010516					_LIQString:
.010516	98		tya				tya 								; skip quoted strings
.010517	18		clc				clc
.010518	71 40		adc ($40),y			adc 	(DTemp1),y
.01051a	a8		tay				tay
.01051b	80 e9		bra $010506			bra 	_LIFindLength
.01051d					_LIFindEnd:
.01051d	98		tya				tya 								; the tokens in the line
.01051e	18		clc				clc
.01051f	69 06 00	adc #$0006			adc 	#6 							; add 6. One for the ending zero, one for line, one for offset.
.010522	85 48		sta $48				sta 	DTemp3 						; save this in DTemp3
.010524	a9 00 02	lda #$0200			lda 	#Block_ProgramStart
.010527	18		clc				clc
.010528	65 02		adc $02				adc 	DBaseAddress
.01052a	a8		tay				tay
.01052b					_LIFindInsertPoint:
.01052b	b9 00 00	lda $0000,y			lda 	$0000,y						; if offset is zero, end, so insert here.
.01052e	f0 0f		beq $01053f			beq		_LIFoundInsertPoint
.010530	b9 02 00	lda $0002,y			lda 	$0002,y 					; if line number here > line number required insert here.
.010533	c5 44		cmp $44				cmp 	DTemp2
.010535	b0 08		bcs $01053f			bcs 	_LIFoundInsertPoint
.010537	98		tya				tya 								; if < go to the next line.
.010538	18		clc				clc
.010539	79 00 00	adc $0000,y			adc 	$0000,y
.01053c	a8		tay				tay
.01053d	80 ec		bra $01052b			bra 	_LIFindInsertPoint
.01053f					_LIFoundInsertPoint:
.01053f	84 50		sty $50				sty 	DTemp5 						; save in DTemp5
.010541	20 63 1c	jsr $011c63			jsr 	FindCodeEnd 				; get the end of the code.
.010544	85 4c		sta $4c				sta 	DTemp4 						; save in DTemp4
.010546	18		clc				clc
.010547	65 48		adc $48				adc 	DTemp3
.010549	85 4e		sta $4e				sta 	DTemp4+2 					; copying it to DTemp4 + length.
.01054b					_LICopyMove:
.01054b	b2 4c		lda ($4c)			lda 	(DTemp4) 					; copy the word
.01054d	92 4e		sta ($4e)			sta 	(DTemp4+2)
.01054f	a5 4c		lda $4c				lda 	DTemp4 						; reached the insert point
.010551	c5 50		cmp $50				cmp 	DTemp5
.010553	f0 0a		beq $01055f			beq 	_LICopyMoveOver
.010555	c6 4c		dec $4c				dec 	DTemp4 						; shift all pointers.
.010557	c6 4c		dec $4c				dec 	DTemp4
.010559	c6 4e		dec $4e				dec 	DTemp4+2
.01055b	c6 4e		dec $4e				dec 	DTemp4+2
.01055d	80 ec		bra $01054b			bra 	_LICopyMove
.01055f					_LICopyMoveOver:
.01055f	a5 48		lda $48				lda 	DTemp3 						; copy the length in, this is the offset
.010561	92 50		sta ($50)			sta 	(DTemp5)
.010563	a0 02 00	ldy #$0002			ldy 	#2
.010566	a5 44		lda $44				lda 	DTemp2 						; copy the line number in.
.010568	91 50		sta ($50),y			sta 	(DTemp5),y
.01056a	a0 04 00	ldy #$0004			ldy 	#4
.01056d					_LICopyTokens:
.01056d	b2 40		lda ($40)			lda 	(DTemp1) 					; copy token over.
.01056f	91 50		sta ($50),y			sta 	(DTemp5),y
.010571	c8		iny				iny
.010572	c8		iny				iny
.010573	e6 40		inc $40				inc 	DTemp1
.010575	e6 40		inc $40				inc 	DTemp1
.010577	c6 48		dec $48				dec 	DTemp3 						; count - 4 times.
.010579	c6 48		dec $48				dec 	DTemp3
.01057b	a5 48		lda $48				lda 	DTemp3
.01057d	c9 04 00	cmp #$0004			cmp 	#4
.010580	d0 eb		bne $01056d			bne 	_LICopyTokens
.010582	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/utility/utility.asm

.010583					ErrorHandler:
.010583	c2 30		rep #$30			rep 	#$30 						; in case we changed it.
.010585	fa		plx				plx 								; address of error message -1
.010586	e8		inx				inx 								; error message.
.010587	20 3c 06	jsr $01063c			jsr 	PrintROMMessage 			; print message in ROM
.01058a	a5 14		lda $14				lda 	DLineNumber 				; is it line 0 (e.g. typed in)
.01058c	f0 15		beq $0105a3			beq 	_EHEndMessage
.01058e	a2 a9 05	ldx #$05a9			ldx 	#_EHAt & $FFFF 				; print " at "
.010591	20 3c 06	jsr $01063c			jsr 	PrintROMMessage
.010594	a5 14		lda $14				lda 	DLineNumber 				; Line# in YA
.010596	a0 00 00	ldy #$0000			ldy 	#0
.010599	a2 0a 00	ldx #$000a			ldx 	#10 						; base 10
.01059c	20 cc 10	jsr $0110cc			jsr 	ConvertToString 			; convert and print it.
.01059f	a8		tay				tay
.0105a0	20 5a 06	jsr $01065a			jsr 	PrintBASICString
.0105a3					_EHEndMessage:
.0105a3	20 74 1e	jsr $011e74			jsr 	HWNewLine
.0105a6	4c 78 1f	jmp $011f78			jmp 	NextCommand 				; get next command.
>0105a9	20 61 74 20 00			_EHAt:	.text 	" at ",$00
.0105ae					IllegalToken:
.0105ae	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>0105b1	49 6c 6c 65 67 61 6c 20				.text 	"Illegal Token",$00 								; with this message
>0105b9	54 6f 6b 65 6e 00
.0105bf					SyntaxError:
.0105bf	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>0105c2	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",$00 								; with this message
>0105ca	72 72 6f 72 00
.0105cf					OutOfMemoryError:
.0105cf	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>0105d2	4f 75 74 20 6f 66 20 6d				.text 	"Out of memory",$00 								; with this message
>0105da	65 6d 6f 72 79 00
.0105e0					ExpectToken:
.0105e0	d2 06		cmp ($06)			cmp 	(DCodePtr) 					; does it match the next token
.0105e2	d0 05		bne $0105e9			bne 	_CTKError					; error if not
.0105e4	e6 06		inc $06				inc 	DCodePtr 					; skip the token
.0105e6	e6 06		inc $06				inc 	DCodePtr
.0105e8	60		rts				rts
.0105e9					_CTKError:
.0105e9	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>0105ec	4d 69 73 73 69 6e 67 20				.text 	"Missing token",$00 								; with this message
>0105f4	74 6f 6b 65 6e 00
.0105fa					ExpectRightBracket:
.0105fa	48		pha				pha
.0105fb	a9 28 32	lda #$3228			lda 	#rparenTokenID
.0105fe	20 e0 05	jsr $0105e0			jsr 	ExpectToken
.010601	68		pla				pla
.010602	60		rts				rts
.010603					ExpectComma:
.010603	48		pha				pha
.010604	a9 24 32	lda #$3224			lda 	#commaTokenID 				; shorthand because comma is used a fair bit.
.010607	20 e0 05	jsr $0105e0			jsr 	ExpectToken
.01060a	68		pla				pla
.01060b	60		rts				rts
.01060c					CheckBothNumeric:
.01060c	b5 04		lda $04,x			lda 	EXSPrecType+0,x 			; OR together their prec/type
.01060e	15 0a		ora $0a,x			ora 	EXSPrecType+EXSNext,x
.010610	30 01		bmi $010613			bmi 	_CBNFail 					; need to both be zero in bit 15
.010612	60		rts				rts
.010613					_CBNFail:
.010613	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>010616	4f 70 65 72 61 74 6f 72				.text 	"Operator integer only",$00 								; with this message
>01061e	20 69 6e 74 65 67 65 72 20 6f 6e 6c 79 00
.01062c					ResetTypeInteger:
.01062c	b5 04		lda $04,x			lda 	EXSPrecType+0,x 			; clear bit 15
.01062e	29 ff 7f	and #$7fff			and 	#$7FFF
.010631	95 04		sta $04,x			sta 	EXSPrecType+0,x
.010633	60		rts				rts
.010634					ResetTypeString:
.010634	b5 04		lda $04,x			lda 	EXSPrecType+0,x 			; clear bit 15
.010636	09 00 80	ora #$8000			ora 	#$8000
.010639	95 04		sta $04,x			sta 	EXSPrecType+0,x
.01063b	60		rts				rts
.01063c					PrintROMMessage:
.01063c	48		pha				pha
.01063d	da		phx				phx
.01063e					_PRMLoop:
.01063e	bf 00 00 01	lda $010000,x			lda 	StartOfBasicCode,x 			; print characters until $00 found.
.010642	29 ff 00	and #$00ff			and 	#$00FF
.010645	f0 10		beq $010657			beq 	_PRMExit
.010647	c9 0d 00	cmp #$000d			cmp 	#13
.01064a	d0 05		bne $010651			bne 	_PRMChar
.01064c	20 74 1e	jsr $011e74			jsr 	HWNewLine
.01064f	80 03		bra $010654			bra 	_PRMNext
.010651					_PRMChar:
.010651	20 23 1e	jsr $011e23			jsr 	HWPrintChar
.010654					_PRMNext:
.010654	e8		inx				inx
.010655	80 e7		bra $01063e			bra 	_PRMLoop
.010657					_PRMExit:
.010657	fa		plx				plx
.010658	68		pla				pla
.010659	60		rts				rts
.01065a					PrintBASICString:
.01065a	48		pha				pha
.01065b	da		phx				phx
.01065c	5a		phy				phy
.01065d	b9 00 00	lda $0000,y			lda 	$0000,y 					; get length
.010660	29 ff 00	and #$00ff			and 	#$00FF
.010663	f0 0b		beq $010670			beq 	_PBSExit 					; null string
.010665	aa		tax				tax
.010666					_PBSLoop:
.010666	c8		iny				iny
.010667	b9 00 00	lda $0000,y			lda 	$0000,y
.01066a	20 23 1e	jsr $011e23			jsr 	HWPrintChar
.01066d	ca		dex				dex
.01066e	d0 f6		bne $010666			bne 	_PBSLoop
.010670					_PBSExit:
.010670	7a		ply				ply
.010671	fa		plx				plx
.010672	68		pla				pla
.010673	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/utility/stringconcrete.asm

.010674					StringResetPermanent:
.010674	a5 04		lda $04				lda 	DHighAddress				; the end of memory
.010676	a8		tay				tay
.010677	a0 0a 00	ldy #$000a			ldy 	#Block_HighMemoryPtr		; save the high memory pointer, which is the first link.
.01067a	91 02		sta ($02),y			sta 	(DBaseAddress),y
.01067c	60		rts				rts
.01067d					StringAssign:
.01067d	da		phx				phx 								; save X
.01067e	aa		tax				tax 								; new string address to X.
.01067f	b9 00 00	lda $0000,y			lda 	$0000,y 					; does the string pointer we replace have an address yet.
.010682	f0 49		beq $0106cd			beq 	_SAAllocate 				; if not , allocate space for it and copy the string.
.010684	5a		phy				phy
.010685	b9 00 00	lda $0000,y			lda 	$0000,y 					; compare calculate saved address - high memory pointer
.010688	a0 0a 00	ldy #$000a			ldy 	#Block_HighMemoryPtr
.01068b	d1 02		cmp ($02),y			cmp 	(DBaseAddress),y
.01068d	7a		ply				ply
.01068e	90 3d		bcc $0106cd			bcc 	_SAAllocate					; if < high memory pointer, first allocation.
.010690	5a		phy				phy
.010691	b9 00 00	lda $0000,y			lda 	$0000,y 					; address of the string
.010694	a8		tay				tay
.010695	88		dey				dey 								; point to the max length of the old string.
.010696	b9 00 00	lda $0000,y			lda 	$0000,y 					; length of string
.010699	7a		ply				ply
.01069a	29 ff 00	and #$00ff			and 	#$00FF 						; max length of old string
.01069d	e2 20		sep #$20			sep 	#$20
.01069f	dd 00 00	cmp $0000,x			cmp 	@w$0000,x 					; compare against length of new string
.0106a2	c2 20		rep #$20			rep 	#$20
.0106a4	b0 5a		bcs $010700			bcs 	_SACopyString 				; just copy it in if old max length >= new
.0106a6	b9 00 00	lda $0000,y			lda 	$0000,y 					; get the address of the string.
.0106a9	3a		dec a				dec 	a 							; if bottom, compare the previous byte address
.0106aa	5a		phy				phy 								; which is the max length.
.0106ab	a0 0a 00	ldy #$000a			ldy 	#Block_HighMemoryPtr
.0106ae	51 02		eor ($02),y			eor 	(DBaseAddress),y
.0106b0	7a		ply				ply
.0106b1	09 00 00	ora #$0000			ora 	#$0000 						; if not, then allocate memory.
.0106b4	d0 17		bne $0106cd			bne 	_SAAllocate
.0106b6	5a		phy				phy
.0106b7	b9 00 00	lda $0000,y			lda 	$0000,y 					; address of old string
.0106ba	a8		tay				tay 								; to Y
.0106bb	88		dey				dey 								; get maximum length.
.0106bc	b9 00 00	lda $0000,y			lda 	$0000,y
.0106bf	29 ff 00	and #$00ff			and 	#$00FF
.0106c2	1a		inc a				inc 	a 							; add 2 (string,max)
.0106c3	1a		inc a				inc 	a
.0106c4	a0 0a 00	ldy #$000a			ldy 	#Block_HighMemoryPtr 		; return memory back
.0106c7	18		clc				clc
.0106c8	71 02		adc ($02),y			adc 	(DBaseAddress),y
.0106ca	91 02		sta ($02),y			sta 	(DBaseAddress),y
.0106cc	7a		ply				ply
.0106cd					_SAAllocate:
.0106cd	bd 00 00	lda $0000,x			lda 	@w$0000,x 					; get the length of the string
.0106d0	29 ff 00	and #$00ff			and 	#$00FF
.0106d3	18		clc				clc
.0106d4	69 08 00	adc #$0008			adc 	#8 							; allocate extra space if needed.
.0106d7	c9 ff 00	cmp #$00ff			cmp 	#255 						; can't be larger than this.
.0106da	90 03		bcc $0106df			bcc 	_SASizeOkay
.0106dc	a9 ff 00	lda #$00ff			lda 	#255
.0106df					_SASizeOkay:
.0106df	5a		phy				phy 								; push [string] on the stack.
.0106e0	48		pha				pha 								; push largest string size on the stack.
.0106e1	1a		inc a				inc 	a  							; one more for the string size byte
.0106e2	1a		inc a				inc 	a 							; one more for the maximum size byte
.0106e3	49 ff ff	eor #$ffff			eor 	#$FFFF 						; subtract from the high memory pointer
.0106e6	38		sec				sec
.0106e7	a0 0a 00	ldy #$000a			ldy 	#Block_HighMemoryPtr
.0106ea	71 02		adc ($02),y			adc 	(DBaseAddress),y
.0106ec	91 02		sta ($02),y			sta 	(DBaseAddress),y
.0106ee	a0 08 00	ldy #$0008			ldy 	#Block_LowMemoryPtr 		; out of memory ? - if below the lowmemorypointer
.0106f1	d1 02		cmp ($02),y			cmp 	(DBaseAddress),y
.0106f3	90 29		bcc $01071e			bcc 	_SAMemory
.0106f5	a8		tay				tay 								; address of start of space in Y.
.0106f6	68		pla				pla 								; restore largest string size and save it
.0106f7	99 00 00	sta $0000,y			sta 	@w$0000,y 					; doesn't matter it's a word.
.0106fa	c8		iny				iny 								; Y now points to the first byte of the string we'll copy
.0106fb	98		tya				tya 								; in A now
.0106fc	7a		ply				ply 								; Y is the address of the variable pointer.
.0106fd	99 00 00	sta $0000,y			sta 	@w$0000,y 					; make that pointer the first byte
.010700					_SACopyString
.010700	bd 00 00	lda $0000,x			lda 	@w$0000,x 					; get length
.010703	29 ff 00	and #$00ff			and 	#$00FF
.010706	85 40		sta $40				sta 	DTemp1 						; save it.
.010708	b9 00 00	lda $0000,y			lda 	@w$0000,y 					; Y now contains the actual address of the string
.01070b	a8		tay				tay
.01070c					_SACopyStringLoop:
.01070c	e2 20		sep #$20			sep 	#$20
.01070e	bd 00 00	lda $0000,x			lda 	@w$0000,x
.010711	99 00 00	sta $0000,y			sta 	@w$0000,y
.010714	c2 20		rep #$20			rep 	#$20
.010716	e8		inx				inx
.010717	c8		iny				iny
.010718	c6 40		dec $40				dec 	DTemp1
.01071a	10 f0		bpl $01070c			bpl 	_SACopyStringLoop
.01071c	fa		plx				plx 								; restore X
.01071d	60		rts				rts
.01071e					_SAMemory:
.01071e	82 ae fe	brl $0105cf			brl 	OutOfMemoryError

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/utility/stringtemp.asm

.010721					StringTempAllocate:
.010721	48		pha				pha
.010722	a5 08		lda $08				lda 	DTempStringPointer 			; needs resetting ? we do this by zeroing this
.010724	d0 0d		bne $010733			bne 	_STANoReset 				; string pointer.
.010726	5a		phy				phy 								; reset the temp string pointer.
.010727	a0 0a 00	ldy #$000a			ldy 	#Block_HighMemoryPtr 		; this is at high memory - 256, so we can
.01072a	b1 02		lda ($02),y			lda 	(DBaseAddress),y 			; create permanent strings if needed.
.01072c	38		sec				sec
.01072d	e9 00 01	sbc #$0100			sbc 	#256
.010730	85 08		sta $08				sta 	DTempStringPointer
.010732	7a		ply				ply
.010733					_STANoReset:
.010733	68		pla				pla 								; get length.
.010734	29 ff 00	and #$00ff			and 	#$00FF 						; check it's a byte size
.010737	49 ff ff	eor #$ffff			eor 	#$FFFF 						; 2's complement add to temporary pointer.
.01073a	18		clc				clc 								; this adds one, for the length.
.01073b	65 08		adc $08				adc 	DTempStringPointer
.01073d	85 08		sta $08				sta 	DTempStringPointer
.01073f	48		pha				pha 								; save start address
.010740	a9 00 00	lda #$0000			lda 	#$0000
.010743	e2 20		sep #$20			sep 	#$20 						; zero the length of this new string.
.010745	92 08		sta ($08)			sta		(DTempStringPointer)
.010747	c2 20		rep #$20			rep 	#$20
.010749	68		pla				pla 								; restore start address
.01074a	85 0a		sta $0a				sta 	DStartTempString 			; start of new temporary string.
.01074c	85 0c		sta $0c				sta 	DCurrentTempString 			; save current temporary string
.01074e	e6 0c		inc $0c				inc 	DCurrentTempString 			; step over length byte.
.010750	60		rts				rts
.010751					StringWriteCharacter:
.010751	e2 20		sep #$20			sep 	#$20						; 8 bit mode
.010753	92 0c		sta ($0c)			sta 	(DCurrentTempString) 		; save character
.010755	b2 0a		lda ($0a)			lda 	(DStartTempString) 			; bump length
.010757	1a		inc a				inc 	a
.010758	92 0a		sta ($0a)			sta 	(DStartTempString)
.01075a	c2 20		rep #$20			rep 	#$20						; 16 bit mode
.01075c	e6 0c		inc $0c				inc 	DCurrentTempString 			; increment write pointer
.01075e	60		rts				rts
.01075f					StringCreateCopy:
.01075f	a8		tay				tay 								; put pointer to string in Y
.010760	b9 00 00	lda $0000,y			lda 	$0000,y 					; read the first byte, the length.
.010763	29 ff 00	and #$00ff			and 	#$00FF 						; mask out the length byte.
.010766	f0 17		beq $01077f			beq 	_SCCExit 					; do nothing if length zero (the length byte is reset when allocated)
.010768	da		phx				phx 								; save X and put the character count in X
.010769	aa		tax				tax
.01076a					_SCCCopy:
.01076a	c8		iny				iny 								; advance and read (first time skips length)
.01076b	e2 20		sep #$20			sep 	#$20 						; switch to 8 bit mode.
.01076d	b9 00 00	lda $0000,y			lda 	$0000,y
.010770	92 0c		sta ($0c)			sta 	(DCurrentTempString) 		; write into target
.010772	b2 0a		lda ($0a)			lda 	(DStartTempString)			; one more character
.010774	1a		inc a				inc 	a
.010775	92 0a		sta ($0a)			sta 	(DStartTempString)
.010777	c2 20		rep #$20			rep 	#$20 						; switch back to 16 bit mode
.010779	e6 0c		inc $0c				inc 	DCurrentTempString 			; bump target pointer
.01077b	ca		dex				dex 								; do X times
.01077c	d0 ec		bne $01076a			bne 	_SCCCopy
.01077e	fa		plx				plx
.01077f					_SCCExit:
.01077f	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/utility/tokeniser.asm

.010780					Tokenise:
.010780	85 40		sta $40				sta 	DTemp1						; DTemp1 is the string to tokenise.
.010782	84 42		sty $42				sty 	DTemp1+2
.010784	a9 00 01	lda #$0100			lda 	#Block_TokenBuffer 			; reset workspace pointer.
.010787	18		clc				clc
.010788	65 02		adc $02				adc 	DBaseAddress
.01078a	85 44		sta $44				sta 	DTemp2 						; which is DTemp2
.01078c	a0 ff ff	ldy #$ffff			ldy 	#-1 						; index
.01078f	a2 00 00	ldx #$0000			ldx 	#0 							; bit 0 1 when in quotes.
.010792					_TOKCap:
.010792	c8		iny				iny 								; go to next
.010793	b7 40		lda [$40],y			lda 	[DTemp1],y
.010795	29 ff 00	and #$00ff			and 	#$00FF
.010798	f0 22		beq $0107bc			beq 	_TOKEndCap
.01079a	c9 22 00	cmp #$0022			cmp 	#'"'						; quote mark
.01079d	d0 01		bne $0107a0			bne 	_TOKNotQuote
.01079f	e8		inx				inx  								; X counts them, bit 0 is yes/no.
.0107a0					_TOKNotQuote:
.0107a0	c9 61 00	cmp #$0061			cmp 	#"a"						; skip if L/C
.0107a3	90 ed		bcc $010792			bcc 	_TOKCap
.0107a5	c9 7b 00	cmp #$007b			cmp 	#"z"+1
.0107a8	b0 e8		bcs $010792			bcs 	_TOKCap
.0107aa	8a		txa				txa 								; check if in quotes
.0107ab	4a		lsr a				lsr 	a
.0107ac	b0 e4		bcs $010792			bcs 	_TOKCap
.0107ae	b7 40		lda [$40],y			lda 	[DTemp1],y 					; capitalise
.0107b0	38		sec				sec
.0107b1	e9 20 00	sbc #$0020			sbc 	#32
.0107b4	e2 20		sep #$20			sep 	#$20
.0107b6	97 40		sta [$40],y			sta 	[DTemp1],y
.0107b8	c2 20		rep #$20			rep 	#$20
.0107ba	80 d6		bra $010792			bra 	_TOKCap
.0107bc					_TOKEndCap:
.0107bc	c6 40		dec $40				dec 	DTemp1
.0107be					_TOKMainNext:
.0107be	e6 40		inc $40				inc 	DTemp1
.0107c0					_TOKMainLoop:
.0107c0	a7 40		lda [$40]			lda 	[DTemp1] 					; get first character
.0107c2	29 ff 00	and #$00ff			and 	#$00FF
.0107c5	c9 20 00	cmp #$0020			cmp 	#32
.0107c8	90 1d		bcc $0107e7			bcc 	_TOKExit 					; 0-31 exit.
.0107ca	f0 f2		beq $0107be			beq 	_TOKMainNext 				; 32 (space) skip.
.0107cc	c9 22 00	cmp #$0022			cmp 	#34 						; if 34 (quote marks) do a string.
.0107cf	f0 1d		beq $0107ee			beq 	_TOKString
.0107d1	c9 30 00	cmp #$0030			cmp 	#48 						; 33-47 (not 34) check for punctuation.
.0107d4	90 1d		bcc $0107f3			bcc 	_TOKPunctuation
.0107d6	c9 3a 00	cmp #$003a			cmp 	#58 						; 48-57 tokenise a number
.0107d9	90 42		bcc $01081d			bcc 	_TOKNumber
.0107db	c9 41 00	cmp #$0041			cmp 	#65 						; 58-64 more punctuation
.0107de	90 13		bcc $0107f3			bcc 	_TOKPunctuation
.0107e0	c9 5b 00	cmp #$005b			cmp 	#91 						; 65-90 identifier/keyword.
.0107e3	90 3d		bcc $010822			bcc 	_TOKIdentifier
.0107e5	80 0c		bra $0107f3			bra 	_TOKPunctuation 			; 91-   punctuation.
.0107e7					_TOKExit:
.0107e7	a9 00 00	lda #$0000			lda 	#$0000
.0107ea	20 27 08	jsr $010827			jsr 	TOKWriteToken
.0107ed	60		rts				rts
.0107ee					_TOKString:
.0107ee	20 c5 08	jsr $0108c5			jsr 	TOKQuotedString
.0107f1	80 cd		bra $0107c0			bra 	_TOKMainLoop
.0107f3					_TOKPunctuation:
.0107f3	a2 02 00	ldx #$0002			ldx 	#2 							; try 2 character tokens.
.0107f6	20 2c 09	jsr $01092c			jsr 	TOKKeywordSearch
.0107f9	b0 1d		bcs $010818			bcs 	_TOKFoundPunctuation
.0107fb	a2 01 00	ldx #$0001			ldx 	#1 							; failed, try 1 character token.
.0107fe	20 2c 09	jsr $01092c			jsr 	TOKKeywordSearch
.010801	b0 15		bcs $010818			bcs 	_TOKFoundPunctuation
.010803	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>010806	43 61 6e 6e 6f 74 20 70				.text 	"Cannot parse line",$00 								; with this message
>01080e	61 72 73 65 20 6c 69 6e 65 00
.010818					_TOKFoundPunctuation:
.010818	20 27 08	jsr $010827			jsr 	TOKWriteToken 				; output the token and go round again.
.01081b	80 a3		bra $0107c0			bra 	_TOKMainLoop
.01081d					_TOKNumber:
.01081d	20 46 08	jsr $010846			jsr 	TOKInteger 					; tokenise integer out of the token text.
.010820	80 9e		bra $0107c0			bra 	_TOKMainLoop
.010822					_TOKIdentifier:
.010822	20 87 09	jsr $010987			jsr 	TOKIdentifier
.010825	80 99		bra $0107c0			bra 	_TOKMainLoop
.010827					TOKWriteToken:
.010827	92 44		sta ($44)			sta 	(DTemp2)					; write out
.010829	e6 44		inc $44				inc 	DTemp2 						; bump pointer
.01082b	e6 44		inc $44				inc 	DTemp2
.01082d	a5 44		lda $44				lda 	DTemp2 						; overflow ??
.01082f	29 ff 00	and #$00ff			and 	#$00FF
.010832	f0 01		beq $010835			beq 	_TOKWriteOverflow
.010834	60		rts				rts
.010835					_TOKWriteOverflow:
.010835	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>010838	4c 69 6e 65 20 74 6f 6f				.text 	"Line too long",$00 								; with this message
>010840	20 6c 6f 6e 67 00
.010846					TOKInteger:
.010846	64 48		stz $48				stz 	DTemp3 						; we're going to build it in DTemp3
.010848	64 4a		stz $4a				stz 	DTemp3+2
.01084a					_TOKINLoop:
.01084a	a5 4a		lda $4a				lda 	DTemp3+2 					; push DTemp3+2 on the stack/A
.01084c	48		pha				pha
.01084d	a5 48		lda $48				lda 	DTemp3
.01084f	06 48		asl $48				asl 	DTemp3 						; multiply it by 4
.010851	26 4a		rol $4a				rol 	DTemp3+2
.010853	06 48		asl $48				asl 	DTemp3
.010855	26 4a		rol $4a				rol 	DTemp3+2
.010857	18		clc				clc
.010858	65 48		adc $48				adc 	DTemp3 						; add saved value, so it's x 5
.01085a	85 48		sta $48				sta 	DTemp3
.01085c	68		pla				pla
.01085d	65 4a		adc $4a				adc 	DTemp3+2
.01085f	85 4a		sta $4a				sta 	DTemp3+2
.010861	06 48		asl $48				asl 	DTemp3 						; multiply it by 2, e.g. x 10
.010863	26 4a		rol $4a				rol 	DTemp3+2
.010865	a5 4a		lda $4a				lda 	DTemp3+2 					; we can't cope with that big an integer
.010867	29 00 f0	and #$f000			and 	#$F000						; can't directly tokenise MAXINT.
.01086a	d0 44		bne $0108b0			bne 	_TOKINSize
.01086c	a7 40		lda [$40]			lda 	[DTemp1]					; get the character value, we know this is 0-9
.01086e	29 0f 00	and #$000f			and 	#15
.010871	18		clc				clc
.010872	65 48		adc $48				adc 	DTemp3 						; add to the running count
.010874	85 48		sta $48				sta 	DTemp3
.010876	90 02		bcc $01087a			bcc 	_TOKINNoCarry
.010878	e6 4a		inc $4a				inc 	DTemp3+2
.01087a					_TOKINNoCarry:
.01087a	e6 40		inc $40				inc 	DTemp1 						; look at next
.01087c	a7 40		lda [$40]			lda 	[DTemp1] 					; loop back if 0..9
.01087e	29 ff 00	and #$00ff			and 	#$00FF
.010881	c9 30 00	cmp #$0030			cmp 	#"0"
.010884	90 05		bcc $01088b			bcc 	_TOKINGotInteger
.010886	c9 3a 00	cmp #$003a			cmp 	#"9"+1
.010889	90 bf		bcc $01084a			bcc		_TOKINLoop
.01088b					_TOKINGotInteger:
.01088b	a5 48		lda $48				lda 	DTemp3 						; lower word
.01088d	29 ff 7f	and #$7fff			and 	#$7FFF 						; convert to a token
.010890	18		clc				clc
.010891	69 00 40	adc #$4000			adc 	#$4000
.010894	48		pha				pha 								; save it.
.010895	06 48		asl $48				asl 	DTemp3 						; shift bit15 into the high word
.010897	26 4a		rol $4a				rol 	DTemp3+2 					; which is the constant shift.
.010899	a5 4a		lda $4a				lda 	DTemp3+2 					; look at C/Shift
.01089b	c9 00 10	cmp #$1000			cmp 	#$1000	 					; overflow ?
.01089e	b0 10		bcs $0108b0			bcs 	_TOKINSize 					; if so, we can't tokenise the number.
.0108a0	29 ff 0f	and #$0fff			and 	#$0FFF 						; get bits / check zero
.0108a3	f0 06		beq $0108ab			beq 	_TOKINNoShift 				; don't need constant shift.
.0108a5	09 00 10	ora #$1000			ora 	#$1000	 					; make token $1xxx
.0108a8	20 27 08	jsr $010827			jsr 	TOKWriteToken
.0108ab					_TOKINNoShift:
.0108ab	68		pla				pla 								; get lower its token
.0108ac	20 27 08	jsr $010827			jsr 	TOKWriteToken 				; output it
.0108af	60		rts				rts
.0108b0					_TOKINSize:
.0108b0	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>0108b3	49 6e 74 65 67 65 72 20				.text 	"Integer too large",$00 								; with this message
>0108bb	74 6f 6f 20 6c 61 72 67 65 00
.0108c5					TOKQuotedString:
.0108c5	e6 40		inc $40				inc 	DTemp1 						; skip over the initial quote
.0108c7	a5 40		lda $40				lda 	DTemp1 						; save start of string in DTemp4
.0108c9	85 4c		sta $4c				sta 	DTemp4
.0108cb	a5 42		lda $42				lda 	DTemp1+2
.0108cd	85 4e		sta $4e				sta 	DTemp4+2
.0108cf					_TOKQFindSize:
.0108cf	a7 40		lda [$40]			lda 	[DTemp1]					; get character, bump pointer
.0108d1	e6 40		inc $40				inc 	DTemp1
.0108d3	29 ff 00	and #$00ff			and 	#$00FF						; mask 8 bits
.0108d6	f0 3b		beq $010913			beq 	_TOQImbalance 				; end of line, and no quote found.
.0108d8	c9 22 00	cmp #$0022			cmp 	#34
.0108db	d0 f2		bne $0108cf			bne 	_TOKQFindSize 				; at end DTemp1 points after quote.
.0108dd	a5 40		lda $40				lda 	DTemp1 						; work out length, save in DTemp3+2
.0108df	38		sec				sec
.0108e0	e5 4c		sbc $4c				sbc 	DTemp4
.0108e2	3a		dec a				dec 	a 							; one less character for closing quote
.0108e3	85 4a		sta $4a				sta 	DTemp3+2
.0108e5	18		clc				clc
.0108e6	69 04 00	adc #$0004			adc 	#2+1+1 						; two for header, 1 for size, 1 for round up.
.0108e9	29 fe ff	and #$fffe			and 	#$FFFE 						; force to even gives token.
.0108ec	20 27 08	jsr $010827			jsr 	TOKWriteToken
.0108ef	a5 4a		lda $4a				lda 	DTemp3+2 					; this is the count.
.0108f1	20 27 08	jsr $010827			jsr 	TOKWriteToken 				; effectively a byte-write.
.0108f4	c6 44		dec $44				dec 	DTemp2
.0108f6	a6 4a		ldx $4a				ldx 	DTemp3+2 					; this the count.
.0108f8	f0 0f		beq $010909			beq		_TOKQWriteEnd 				; if zero, no need to write anything
.0108fa					_TOKQWriteString:
.0108fa	a7 4c		lda [$4c]			lda 	[DTemp4] 					; read character from start
.0108fc	29 ff 00	and #$00ff			and 	#$00FF
.0108ff	20 27 08	jsr $010827			jsr 	TOKWriteToken 				; effectively a byte-write.
.010902	c6 44		dec $44				dec 	DTemp2
.010904	e6 4c		inc $4c				inc 	DTemp4 						; advance character
.010906	ca		dex				dex 								; do X times
.010907	d0 f1		bne $0108fa			bne 	_TOKQWriteString
.010909					_TOKQWriteEnd:
.010909	a5 44		lda $44				lda 	DTemp2 						; are we on an even byte.
.01090b	29 01 00	and #$0001			and 	#1
.01090e	f0 02		beq $010912			beq 	_TOKQExit
.010910	e6 44		inc $44				inc 	DTemp2 						; we wrote values with the high byte 0, so just correct
.010912					_TOKQExit:
.010912	60		rts				rts
.010913					_TOQImbalance:
.010913	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>010916	4d 69 73 73 69 6e 67 20				.text 	"Missing closing quote",$00 								; with this message
>01091e	63 6c 6f 73 69 6e 67 20 71 75 6f 74 65 00
.01092c					TOKKeywordSearch:
.01092c	86 4c		stx $4c				stx 	DTemp4 						; save length in DTemp4
.01092e	a9 01 00	lda #$0001			lda 	#1 							; token number in DTemp4+2
.010931	85 4e		sta $4e				sta 	DTemp4+2
.010933	a2 00 00	ldx #$0000			ldx 	#0
.010936					_TOKScan:
.010936	bf 9e 00 01	lda $01009e,x			lda 	TokenText,x 				; read the first byte
.01093a	29 0f 00	and #$000f			and 	#$000F 						; and the Nibble which is skip to the next.
.01093d	f0 46		beq $010985			beq 	_TOKFail 					; if zero then we have failed.
.01093f	3a		dec a				dec 	a 							; -1 gives the length.
.010940	c5 4c		cmp $4c				cmp 	DTemp4 						; is this token that length.
.010942	d0 2f		bne $010973			bne 	_TOKNext 					; no, then skip to next token.
.010944	da		phx				phx 								; save X
.010945	a0 00 00	ldy #$0000			ldy 	#0 							; start comparing
.010948					_TOKCompare:
.010948	b7 40		lda [$40],y			lda 	[DTemp1],y 					; get character
.01094a	5f 9f 00 01	eor $01009f,x			eor 	TokenText+1,x
.01094e	29 ff 00	and #$00ff			and 	#$00FF
.010951	d0 1f		bne $010972			bne 	_TOKPopNext 				; if different, pop and goto next.
.010953	e8		inx				inx 								; bump X and Y.
.010954	c8		iny				iny
.010955	c4 4c		cpy $4c				cpy 	DTemp4 						; matched whole length
.010957	d0 ef		bne $010948			bne 	_TOKCompare
.010959	98		tya				tya 								; add length to the text pointer
.01095a	18		clc				clc
.01095b	65 40		adc $40				adc 	DTemp1
.01095d	85 40		sta $40				sta 	DTemp1
.01095f	fa		plx				plx 								; restore X.
.010960	bf 9e 00 01	lda $01009e,x			lda 	TokenText,x 				; get the type/token bit.
.010964	29 f0 00	and #$00f0			and 	#$00F0 						; get the type out
.010967	4a		lsr a				lsr 	a 							; shift into bit 1, then swap into bit 9
.010968	4a		lsr a				lsr		a
.010969	4a		lsr a				lsr 	a
.01096a	eb		xba				xba
.01096b	05 4e		ora $4e				ora 	DTemp4+2 					; OR in keyword number
.01096d	09 00 20	ora #$2000			ora 	#$2000 						; set upper bits
.010970	38		sec				sec
.010971	60		rts				rts
.010972					_TOKPopNext:
.010972	fa		plx				plx 								; restore X.
.010973					_TOKNext:
.010973	bf 9e 00 01	lda $01009e,x			lda 	TokenText,x 				; get the token skip again.
.010977	29 0f 00	and #$000f			and 	#$000F
.01097a	85 16		sta $16				sta 	DSignCount 					; save it in DTemp3 so we can add it to X
.01097c	8a		txa				txa
.01097d	18		clc				clc
.01097e	65 16		adc $16				adc 	DSignCount
.010980	aa		tax				tax
.010981	e6 4e		inc $4e				inc 	DTemp4+2 					; bump keyword index
.010983	80 b1		bra $010936			bra 	_TOKScan
.010985					_TOKFail:
.010985	18		clc				clc
.010986	60		rts				rts
.010987					TOKIdentifier:
.010987	a5 40		lda $40				lda 	DTemp1 						; save start of identifier in DTemp3
.010989	85 48		sta $48				sta 	DTemp3
.01098b					_TOKIFindLength:
.01098b	e6 40		inc $40				inc 	DTemp1						; we know the first one is A-Z
.01098d	a7 40		lda [$40]			lda 	[DTemp1]
.01098f	29 ff 00	and #$00ff			and 	#$00FF
.010992	20 32 0a	jsr $010a32			jsr 	TOKIsIdentifierCharacter
.010995	b0 f4		bcs $01098b			bcs 	_TOKIFindLength
.010997	a5 40		lda $40				lda 	DTemp1 						; calculate base identifier length.
.010999	38		sec				sec
.01099a	e5 48		sbc $48				sbc 	DTemp3 						; i.e. the # characters in the actual name
.01099c	85 50		sta $50				sta 	DTemp5
.01099e	85 52		sta $52				sta 	DTemp5+2 					; this is the name length including $(
.0109a0	a9 00 c0	lda #$c000			lda 	#$C000						; this is the upper bits - 11<type><arr> 1xxx
.0109a3	85 4a		sta $4a				sta 	DTemp3+2 					; used for building an identifier.
.0109a5	a7 40		lda [$40]			lda 	[DTemp1]					; string follows
.0109a7	29 ff 00	and #$00ff			and 	#$00FF
.0109aa	c9 24 00	cmp #$0024			cmp 	#"$"
.0109ad	d0 0b		bne $0109ba			bne 	_TOKINotString
.0109af	e6 40		inc $40				inc 	DTemp1 						; skip $
.0109b1	e6 52		inc $52				inc 	DTemp5+2 					; token length.
.0109b3	a5 4a		lda $4a				lda 	DTemp3+2 					; set type mask bit
.0109b5	09 00 20	ora #$2000			ora 	#IDTypeMask
.0109b8	85 4a		sta $4a				sta 	DTemp3+2
.0109ba					_TOKINotString:
.0109ba	a7 40		lda [$40]			lda 	[DTemp1]					; string follows
.0109bc	29 ff 00	and #$00ff			and 	#$00FF
.0109bf	c9 28 00	cmp #$0028			cmp 	#"("
.0109c2	d0 0b		bne $0109cf			bne 	_TOKINotArray
.0109c4	e6 40		inc $40				inc 	DTemp1 						; skip (
.0109c6	e6 52		inc $52				inc 	DTemp5+2 					; token length.
.0109c8	a5 4a		lda $4a				lda 	DTemp3+2 					; set type mask bit
.0109ca	09 00 10	ora #$1000			ora 	#IDArrayMask
.0109cd	85 4a		sta $4a				sta 	DTemp3+2
.0109cf					_TOKINotArray:
.0109cf	a5 48		lda $48				lda 	DTemp3 						; reset the scan position
.0109d1	85 40		sta $40				sta 	DTemp1
.0109d3	a6 52		ldx $52				ldx 	DTemp5+2 					; so see if it is a token first.
.0109d5	20 2c 09	jsr $01092c			jsr 	TOKKeywordSearch
.0109d8	90 04		bcc $0109de			bcc 	_TOKIIdentifier 			; if CC it's an identifier.
.0109da	20 27 08	jsr $010827			jsr 	TOKWriteToken 				; if CS write token and exit.
.0109dd	60		rts				rts
.0109de					_TOKIIdentifier:
.0109de	a7 40		lda [$40]			lda 	[DTemp1]					; get the first character
.0109e0	e6 40		inc $40				inc 	DTemp1
.0109e2	20 1e 0a	jsr $010a1e			jsr		_TOKIToConstant 			; convert to range 0-35
.0109e5	05 4a		ora $4a				ora 	DTemp3+2 					; put in the upper bits.
.0109e7	c6 50		dec $50				dec 	DTemp5 						; decrement the identifier length
.0109e9	f0 1d		beq $010a08			beq 	_TOKINoSecond
.0109eb	48		pha				pha 								; save current on stack.
.0109ec	a7 40		lda [$40]			lda 	[DTemp1]					; get the next character
.0109ee	e6 40		inc $40				inc 	DTemp1
.0109f0	20 1e 0a	jsr $010a1e			jsr		_TOKIToConstant 			; convert to range 0-35
.0109f3	85 16		sta $16				sta 	DSignCount 					; save it.
.0109f5	0a		asl a				asl 	a 							; x 4
.0109f6	0a		asl a				asl 	a
.0109f7	65 16		adc $16				adc 	DSignCount 					; x 5
.0109f9	0a		asl a				asl 	a 							; x 10
.0109fa	65 16		adc $16				adc 	DSignCount 					; x 11
.0109fc	0a		asl a				asl 	a 							; x 22
.0109fd	0a		asl a				asl 	a 							; x 44
.0109fe	65 16		adc $16				adc 	DSignCount 					; x 45
.010a00	85 16		sta $16				sta 	DSignCount
.010a02	68		pla				pla 								; get old token and add x 45
.010a03	18		clc				clc
.010a04	65 16		adc $16				adc 	DSignCount
.010a06	c6 50		dec $50				dec 	DTemp5 						; decrement the count.
.010a08					_TOKINoSecond:
.010a08	a6 50		ldx $50				ldx 	DTemp5 						; is the count now zero.
.010a0a	f0 03		beq $010a0f			beq 	_TOKINotLast				; if yes
.010a0c	09 00 08	ora #$0800			ora 	#IDContMask 				; set the continuation bit.
.010a0f					_TOKINotLast:
.010a0f	20 27 08	jsr $010827			jsr 	TOKWriteToken 				; output the token
.010a12	a5 50		lda $50				lda 	DTemp5						; loop back if more to do.
.010a14	d0 c8		bne $0109de			bne 	_TOKIIdentifier
.010a16					_TOKIOut:
.010a16	a5 48		lda $48				lda 	DTemp3 						; get original start position
.010a18	18		clc				clc
.010a19	65 52		adc $52				adc 	DTemp5+2					; add overall length
.010a1b	85 40		sta $40				sta 	DTemp1 						; this is the end position
.010a1d	60		rts				rts
.010a1e					_TOKIToConstant:
.010a1e	29 ff 00	and #$00ff			and 	#$00FF 						; byte value
.010a21	c9 41 00	cmp #$0041			cmp 	#65
.010a24	90 04		bcc $010a2a			bcc 	_TOKITInteger
.010a26	29 1f 00	and #$001f			and 	#31 						; it's A-Z, so return 1-26
.010a29	60		rts				rts
.010a2a					_TOKITInteger:
.010a2a	29 0f 00	and #$000f			and 	#15 						; its 0-9 which are 27-36
.010a2d	18		clc				clc
.010a2e	69 1b 00	adc #$001b			adc 	#27
.010a31	60		rts				rts
.010a32					TOKIsIdentifierCharacter:
.010a32	c9 30 00	cmp #$0030			cmp 	#"0"
.010a35	90 0f		bcc $010a46			bcc 	_TOKIIFail
.010a37	c9 3a 00	cmp #$003a			cmp 	#"9"+1
.010a3a	90 0c		bcc $010a48			bcc 	_TOKIIOk
.010a3c	c9 41 00	cmp #$0041			cmp 	#"A"
.010a3f	90 05		bcc $010a46			bcc 	_TOKIIFail
.010a41	c9 5b 00	cmp #$005b			cmp 	#"Z"+1
.010a44	90 02		bcc $010a48			bcc 	_TOKIIOk
.010a46					_TOKIIFail:
.010a46	18		clc				clc
.010a47	60		rts				rts
.010a48					_TOKIIOk:
.010a48	38		sec				sec
.010a49	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/binary/arithmetic.asm

.010a4a					Binary_Add:
.010a4a	b5 04		lda $04,x		lda 	EXSPrecType+0,x 					; check both same type
.010a4c	55 0a		eor $0a,x		eor 	EXSPrecType+EXSNext,x
.010a4e	30 12		bmi $010a62		bmi 	_BATypeError
.010a50	b5 04		lda $04,x		lda 	EXSPrecType+0,x 					; see if they are strings
.010a52	30 3f		bmi $010a93		bmi 	_BAConcatenateString 				; if so , do the concatenation code.
.010a54	18		clc			clc 										; add the results
.010a55	b5 00		lda $00,x		lda		EXSValueL+0,x
.010a57	75 06		adc $06,x		adc 	EXSValueL+EXSNext,x
.010a59	95 00		sta $00,x		sta 	EXSValueL+0,x
.010a5b	b5 02		lda $02,x		lda		EXSValueH+0,x
.010a5d	75 08		adc $08,x		adc 	EXSValueH+EXSNext,x
.010a5f	95 02		sta $02,x		sta 	EXSValueH+0,x
.010a61	60		rts			rts
.010a62					_BATypeError:
.010a62	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>010a65	2b 20 6f 70 65 72 61 74				.text 	"+ operator can't mix types",$00 								; with this message
>010a6d	6f 72 20 63 61 6e 27 74 20 6d 69 78 20 74 79 70
>010a7d	65 73 00
.010a80					_BALengthError:
.010a80	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>010a83	53 74 72 69 6e 67 20 74				.text 	"String too long",$00 								; with this message
>010a8b	6f 6f 20 6c 6f 6e 67 00
.010a93					_BAConcatenateString:
.010a93	b5 00		lda $00,x		lda 	EXSValueL+0,x 						; save pointers in DTemp1/DTemp2
.010a95	85 40		sta $40			sta 	DTemp1 								; they are the first and second strings.
.010a97	b5 06		lda $06,x		lda 	EXSValueL+EXSNext,x
.010a99	85 44		sta $44			sta 	DTemp2
.010a9b	e2 20		sep #$20		sep 	#$20								; switch into byte mode.
.010a9d	18		clc			clc 										; work out the total length
.010a9e	b2 40		lda ($40)		lda 	(DTemp1)
.010aa0	72 44		adc ($44)		adc 	(DTemp2)
.010aa2	b0 14		bcs $010ab8		bcs 	_BAConcatLengthError 				; string is too long.
.010aa4	c2 20		rep #$20		rep 	#$20 								; back to 16 bit mode.
.010aa6	20 21 07	jsr $010721		jsr 	StringTempAllocate 					; allocate string of that size in temp memory.
.010aa9	95 00		sta $00,x		sta 	EXSValueL+0,x 						; update the return value to that address.
.010aab	74 02		stz $02,x		stz 	EXSValueH+0,x
.010aad	a5 40		lda $40			lda 	DTemp1 								; copy first string there.
.010aaf	20 5f 07	jsr $01075f		jsr 	StringCreateCopy
.010ab2	a5 44		lda $44			lda 	DTemp2 								; copy second string there.
.010ab4	20 5f 07	jsr $01075f		jsr 	StringCreateCopy
.010ab7	60		rts			rts
.010ab8					_BAConcatLengthError:
.010ab8	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>010abb	53 74 72 69 6e 67 20 74				.text 	"String too long",$00 								; with this message
>010ac3	6f 6f 20 6c 6f 6e 67 00
.010acb					Binary_Subtract:
.010acb	20 0c 06	jsr $01060c		jsr 	CheckBothNumeric 					; check both values are numeric
.010ace	38		sec			sec
.010acf	b5 00		lda $00,x		lda		EXSValueL+0,x
.010ad1	f5 06		sbc $06,x		sbc 	EXSValueL+EXSNext,x
.010ad3	95 00		sta $00,x		sta 	EXSValueL+0,x
.010ad5	b5 02		lda $02,x		lda		EXSValueH+0,x
.010ad7	f5 08		sbc $08,x		sbc 	EXSValueH+EXSNext,x
.010ad9	95 02		sta $02,x		sta 	EXSValueH+0,x
.010adb	60		rts			rts
.010adc					Binary_ShiftRight:
.010adc	20 0c 06	jsr $01060c		jsr 	CheckBothNumeric 					; check both values are numeric
.010adf	b5 06		lda $06,x		lda 	EXSValueL+EXSNext,x
.010ae1	29 3f 00	and #$003f		and 	#63
.010ae4	f0 07		beq $010aed		beq		_Binary_SRExit
.010ae6					_Binary_SRLoop:
.010ae6	56 02		lsr $02,x		lsr 	EXSValueH+0,x
.010ae8	76 00		ror $00,x		ror 	EXSValueL+0,x
.010aea	3a		dec a			dec 	a
.010aeb	d0 f9		bne $010ae6		bne 	_Binary_SRLoop
.010aed					_Binary_SRExit:
.010aed	60		rts			rts
.010aee					Binary_ShiftLeft:
.010aee	20 0c 06	jsr $01060c		jsr 	CheckBothNumeric 					; check both values are numeric
.010af1	b5 06		lda $06,x		lda 	EXSValueL+EXSNext,x
.010af3	29 3f 00	and #$003f		and 	#63
.010af6	f0 07		beq $010aff		beq		_Binary_SLExit
.010af8					_Binary_SLLoop:
.010af8	16 00		asl $00,x		asl 	EXSValueL+0,x
.010afa	36 02		rol $02,x		rol 	EXSValueH+0,x
.010afc	3a		dec a			dec 	a
.010afd	d0 f9		bne $010af8		bne 	_Binary_SLLoop
.010aff					_Binary_SLExit:
.010aff	60		rts			rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/binary/bitwise.asm

.010b00					Binary_And:
.010b00	20 0c 06	jsr $01060c		jsr 	CheckBothNumeric 					; check both values are numeric
.010b03	b5 00		lda $00,x		lda		EXSValueL+0,x
.010b05	35 06		and $06,x		and 	EXSValueL+EXSNext,x
.010b07	95 00		sta $00,x		sta 	EXSValueL+0,x
.010b09	b5 02		lda $02,x		lda		EXSValueH+0,x
.010b0b	35 08		and $08,x		and 	EXSValueH+EXSNext,x
.010b0d	95 02		sta $02,x		sta 	EXSValueH+0,x
.010b0f	60		rts			rts
.010b10					Binary_Or:
.010b10	20 0c 06	jsr $01060c		jsr 	CheckBothNumeric 					; check both values are numeric
.010b13	b5 00		lda $00,x		lda		EXSValueL+0,x
.010b15	15 06		ora $06,x		ora 	EXSValueL+EXSNext,x
.010b17	95 00		sta $00,x		sta 	EXSValueL+0,x
.010b19	b5 02		lda $02,x		lda		EXSValueH+0,x
.010b1b	15 08		ora $08,x		ora 	EXSValueH+EXSNext,x
.010b1d	95 02		sta $02,x		sta 	EXSValueH+0,x
.010b1f	60		rts			rts
.010b20					Binary_Xor:
.010b20	20 0c 06	jsr $01060c		jsr 	CheckBothNumeric 					; check both values are numeric
.010b23	b5 00		lda $00,x		lda		EXSValueL+0,x
.010b25	55 06		eor $06,x		eor 	EXSValueL+EXSNext,x
.010b27	95 00		sta $00,x		sta 	EXSValueL+0,x
.010b29	b5 02		lda $02,x		lda		EXSValueH+0,x
.010b2b	55 08		eor $08,x		eor 	EXSValueH+EXSNext,x
.010b2d	95 02		sta $02,x		sta 	EXSValueH+0,x
.010b2f	60		rts			rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/binary/comparison.asm

.010b30					Binary_Equals:
.010b30	20 e9 0b	jsr $010be9		jsr 	CompareTypeCheck 				; which types are we comparing ?
.010b33	b0 0e		bcs $010b43		bcs 	_BEString
.010b35	b5 00		lda $00,x		lda 	EXSValueL,x 					; numeric comparison
.010b37	d5 06		cmp $06,x		cmp 	EXSValueL+EXSNext,x
.010b39	d0 4f		bne $010b8a		bne 	Compare_Fail
.010b3b	b5 02		lda $02,x		lda 	EXSValueH,x
.010b3d	d5 08		cmp $08,x		cmp 	EXSValueH+EXSNext,x
.010b3f	d0 49		bne $010b8a		bne 	Compare_Fail
.010b41	80 3f		bra $010b82		bra 	Compare_Succeed
.010b43					_BEString:
.010b43	09 00 00	ora #$0000		ora 	#$0000
.010b46	f0 3a		beq $010b82		beq 	Compare_Succeed
.010b48	80 40		bra $010b8a		bra 	Compare_Fail
.010b4a					Binary_NotEquals:
.010b4a	20 e9 0b	jsr $010be9		jsr 	CompareTypeCheck 				; which types are we comparing ?
.010b4d	b0 0e		bcs $010b5d		bcs 	_BNEString
.010b4f	b5 00		lda $00,x		lda 	EXSValueL,x 					; numeric comparison
.010b51	d5 06		cmp $06,x		cmp 	EXSValueL+EXSNext,x
.010b53	d0 2d		bne $010b82		bne 	Compare_Succeed
.010b55	b5 02		lda $02,x		lda 	EXSValueH,x
.010b57	d5 08		cmp $08,x		cmp 	EXSValueH+EXSNext,x
.010b59	d0 27		bne $010b82		bne 	Compare_Succeed
.010b5b	80 2d		bra $010b8a		bra 	Compare_Fail
.010b5d					_BNEString:
.010b5d	09 00 00	ora #$0000		ora 	#$0000
.010b60	d0 20		bne $010b82		bne 	Compare_Succeed
.010b62	80 26		bra $010b8a		bra 	Compare_Fail
.010b64					Binary_Less:
.010b64	20 e9 0b	jsr $010be9		jsr 	CompareTypeCheck 				; which types are we comparing ?
.010b67	b0 12		bcs $010b7b		bcs 	_BLString
.010b69	38		sec			sec
.010b6a	b5 00		lda $00,x		lda 	EXSValueL,x 					; signed numeric <
.010b6c	f5 06		sbc $06,x		sbc 	EXSValueL+EXSNext,x
.010b6e	b5 02		lda $02,x		lda 	EXSValueH,x
.010b70	f5 08		sbc $08,x		sbc 	EXSValueH+EXSNext,x
.010b72	50 03		bvc $010b77		bvc 	*+5
.010b74	49 00 80	eor #$8000		eor 	#$8000
.010b77	30 09		bmi $010b82		bmi 	Compare_Succeed
.010b79	80 0f		bra $010b8a		bra 	Compare_Fail
.010b7b					_BLString:
.010b7b	c9 ff ff	cmp #$ffff		cmp 	#$FFFF 							; string
.010b7e	f0 02		beq $010b82		beq 	Compare_Succeed
.010b80	80 08		bra $010b8a		bra 	Compare_Fail
.010b82					Compare_Succeed:
.010b82	a9 ff ff	lda #$ffff		lda 	#$FFFF
.010b85	95 00		sta $00,x		sta 	EXSValueL,x
.010b87	95 02		sta $02,x		sta 	EXSValueH,x
.010b89	60		rts			rts
.010b8a					Compare_Fail:
.010b8a	74 00		stz $00,x		stz 	EXSValueL,x
.010b8c	74 02		stz $02,x		stz 	EXSValueH,x
.010b8e	60		rts			rts
.010b8f					Binary_GreaterEqual:
.010b8f	20 e9 0b	jsr $010be9		jsr 	CompareTypeCheck 				; which types are we comparing ?
.010b92	b0 12		bcs $010ba6		bcs 	_BGEString
.010b94	38		sec			sec
.010b95	b5 00		lda $00,x		lda 	EXSValueL,x 					; numeric >= signed
.010b97	f5 06		sbc $06,x		sbc 	EXSValueL+EXSNext,x
.010b99	b5 02		lda $02,x		lda 	EXSValueH,x
.010b9b	f5 08		sbc $08,x		sbc 	EXSValueH+EXSNext,x
.010b9d	50 03		bvc $010ba2		bvc 	*+5
.010b9f	49 00 80	eor #$8000		eor 	#$8000
.010ba2	10 de		bpl $010b82		bpl 	Compare_Succeed
.010ba4	80 e4		bra $010b8a		bra 	Compare_Fail
.010ba6					_BGEString:
.010ba6	09 00 00	ora #$0000		ora 	#$0000
.010ba9	10 d7		bpl $010b82		bpl 	Compare_Succeed
.010bab	80 dd		bra $010b8a		bra 	Compare_Fail
.010bad					Binary_LessEqual:
.010bad	20 e9 0b	jsr $010be9		jsr 	CompareTypeCheck 				; which types are we comparing ?
.010bb0	b0 12		bcs $010bc4		bcs 	_BLEString
.010bb2	18		clc			clc 									; numeric <= signed
.010bb3	b5 00		lda $00,x		lda 	EXSValueL,x
.010bb5	f5 06		sbc $06,x		sbc 	EXSValueL+EXSNext,x
.010bb7	b5 02		lda $02,x		lda 	EXSValueH,x
.010bb9	f5 08		sbc $08,x		sbc 	EXSValueH+EXSNext,x
.010bbb	50 03		bvc $010bc0		bvc 	*+5
.010bbd	49 00 80	eor #$8000		eor 	#$8000
.010bc0	30 c0		bmi $010b82		bmi 	Compare_Succeed
.010bc2	80 c6		bra $010b8a		bra 	Compare_Fail
.010bc4					_BLEString:
.010bc4	c9 01 00	cmp #$0001		cmp 	#$0001 							; string
.010bc7	d0 b9		bne $010b82		bne 	Compare_Succeed
.010bc9	80 bf		bra $010b8a		bra 	Compare_Fail
.010bcb					Binary_Greater:
.010bcb	20 e9 0b	jsr $010be9		jsr 	CompareTypeCheck 				; which types are we comparing ?
.010bce	b0 12		bcs $010be2		bcs 	_BGString
.010bd0	18		clc			clc 									; numeric > signed
.010bd1	b5 00		lda $00,x		lda 	EXSValueL,x
.010bd3	f5 06		sbc $06,x		sbc 	EXSValueL+EXSNext,x
.010bd5	b5 02		lda $02,x		lda 	EXSValueH,x
.010bd7	f5 08		sbc $08,x		sbc 	EXSValueH+EXSNext,x
.010bd9	50 03		bvc $010bde		bvc 	*+5
.010bdb	49 00 80	eor #$8000		eor 	#$8000
.010bde	10 a2		bpl $010b82		bpl 	Compare_Succeed
.010be0	80 a8		bra $010b8a		bra 	Compare_Fail
.010be2					_BGString:
.010be2	c9 01 00	cmp #$0001		cmp 	#$0001
.010be5	f0 9b		beq $010b82		beq 	Compare_Succeed
.010be7	80 a1		bra $010b8a		bra 	Compare_Fail
.010be9					CompareTypeCheck:
.010be9	b5 04		lda $04,x		lda 	EXSPrecType+0,x 				; xor the type bits (bit 15)
.010beb	55 0a		eor $0a,x		eor 	EXSPrecType+EXSNext,x
.010bed	30 06		bmi $010bf5		bmi 	_CTCFail 						; if different types cannot be compared, must be the same !
.010bef	b5 04		lda $04,x		lda 	EXSPrecType+0,x 				; get the type they (both) are.
.010bf1	30 1c		bmi $010c0f		bmi 	_CTCStringCompare 				; if strings, do a string comparison.
.010bf3	18		clc			clc 									; if numbers return with carry clear and calculate it.
.010bf4	60		rts			rts
.010bf5					_CTCFail:
.010bf5	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>010bf8	43 6f 6d 70 61 72 69 73				.text 	"Comparison mixed types",$00 								; with this message
>010c00	6f 6e 20 6d 69 78 65 64 20 74 79 70 65 73 00
.010c0f					_CTCStringCompare:
.010c0f	20 2c 06	jsr $01062c		jsr 	ResetTypeInteger 				; two strings return integer not string.
.010c12	b5 00		lda $00,x		lda 	EXSValueL+0,x 					; copy address of string 1 -> DTemp1
.010c14	85 40		sta $40			sta 	DTemp1
.010c16	b5 06		lda $06,x		lda 	EXSValueL+EXSNext,x 					; copy address of string 2 -> DTemp2
.010c18	85 44		sta $44			sta 	DTemp2
.010c1a	a9 00 00	lda #$0000		lda 	#$0000 							; clear AY
.010c1d	a8		tay			tay
.010c1e	e2 20		sep #$20		sep 	#$20 							; 8 bit data mode.
.010c20	b2 40		lda ($40)		lda 	(DTemp1) 						; get the length of the shorter string
.010c22	d2 44		cmp ($44)		cmp 	(DTemp2)
.010c24	90 02		bcc $010c28		bcc 	_CTCSmallest
.010c26	b2 44		lda ($44)		lda 	(DTemp2)
.010c28					_CTCSmallest:
.010c28	85 16		sta $16			sta		DSignCount 						; use this as a comparison count. Check to see they match fires
.010c2a					_CTCCompare:
.010c2a	c8		iny			iny 									; look at next character (done first, first char is size)
.010c2b	c6 16		dec $16			dec 	DSignCount 						; decrement counter
.010c2d	30 16		bmi $010c45		bmi 	_CTCEqualSoFar 					; if -ve the strings are the same as far as the shortest.
.010c2f	b1 40		lda ($40),y		lda 	(DTemp1),y						; compare s1[y] - s2[y]
.010c31	d1 44		cmp ($44),y		cmp 	(DTemp2),y
.010c33	f0 f5		beq $010c2a		beq 	_CTCCompare 					; if zero, try the next character.
.010c35	b0 07		bcs $010c3e		bcs 	_CTCGreater 					; Strings are different in their common length. Return -ve then s2 > s1
.010c37					_CTCLess:
.010c37	c2 20		rep #$20		rep 	#$20
.010c39	a9 ff ff	lda #$ffff		lda 	#$FFFF
.010c3c	80 14		bra $010c52		bra 	_CTCExit
.010c3e					_CTCGreater:
.010c3e	c2 20		rep #$20		rep 	#$20
.010c40	a9 01 00	lda #$0001		lda 	#$0001 							; return +1 and CS
.010c43	80 0d		bra $010c52		bra 	_CTCExit
.010c45					_CTCEqualSoFar:
.010c45	b2 40		lda ($40)		lda 	(DTemp1) 						; if len(s1) < len(s2) then s1 is the smaller
.010c47	d2 44		cmp ($44)		cmp 	(DTemp2)
.010c49	90 ec		bcc $010c37		bcc 	_CTCLess
.010c4b	d0 f1		bne $010c3e		bne 	_CTCGreater 					; if len(s1) > len(s2) then s2 is the smaller
.010c4d	c2 20		rep #$20		rep 	#$20 	 						; if lengths are the same, then the strings are the same.
.010c4f	a9 00 00	lda #$0000		lda 	#$0000
.010c52					_CTCExit:
.010c52	38		sec			sec 									; return with CS indicating string comparison.
.010c53	60		rts			rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/binary/divide.asm

.010c54					Binary_Divide:
.010c54	20 0c 06	jsr $01060c		jsr 	CheckBothNumeric 					; check both values are numeric
.010c57	b5 06		lda $06,x		lda 	EXSValueL+EXSNext,x						; check for division by zero
.010c59	15 08		ora $08,x		ora	 	EXSValueH+EXSNext,x
.010c5b	d0 14		bne $010c71		bne 	_BinaryDivide_Ok
.010c5d	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>010c60	44 69 76 69 73 69 6f 6e				.text 	"Division by zero",$00 								; with this message
>010c68	20 62 79 20 7a 65 72 6f 00
.010c71					_BinaryDivide_Ok:
.010c71	64 40		stz $40			stz 	DTemp1+0							; clear remainder (DTemp)
.010c73	64 42		stz $42			stz 	DTemp1+2
.010c75	64 16		stz $16			stz 	DSignCount  						; zero sign count.
.010c77	5a		phy			phy 										; save Y (bit counter)
.010c78	b5 08		lda $08,x		lda 	EXSValueH+EXSNext,x 				; check sign of H+2 (right)
.010c7a	10 0b		bpl $010c87		bpl 	_BinaryDivide_RightDone
.010c7c	da		phx			phx
.010c7d	e8		inx			inx
.010c7e	e8		inx			inx
.010c7f	e8		inx			inx
.010c80	e8		inx			inx
.010c81	e8		inx			inx
.010c82	e8		inx			inx
.010c83	20 bd 0c	jsr $010cbd		jsr 	Binary_DivNegate
.010c86	fa		plx			plx
.010c87					_BinaryDivide_RightDone:
.010c87	b5 02		lda $02,x		lda 	EXSValueH+0,x 				 		; check sign of H+0 (left)
.010c89	10 03		bpl $010c8e		bpl 	_BinaryDivide_LeftDone
.010c8b	20 bd 0c	jsr $010cbd		jsr 	Binary_DivNegate
.010c8e					_BinaryDivide_LeftDone:
.010c8e	a0 20 00	ldy #$0020		ldy 	#32 								; number to do.
.010c91					_BinaryDivide_Loop:
.010c91	16 00		asl $00,x		asl 	EXSValueL+0,x 						; shift Q into carry
.010c93	36 02		rol $02,x		rol 	EXSValueH+0,x
.010c95	26 40		rol $40			rol 	DTemp1+0 							; rotate A left, with carry in
.010c97	26 42		rol $42			rol 	DTemp1+2
.010c99	38		sec			sec											; calculate A-M
.010c9a	a5 40		lda $40			lda 	DTemp1+0 							; but don't save it.
.010c9c	f5 06		sbc $06,x		sbc 	EXSValueL+EXSNext,x
.010c9e	85 44		sta $44			sta 	DTemp2
.010ca0	a5 42		lda $42			lda 	DTemp1+2
.010ca2	f5 08		sbc $08,x		sbc 	EXSValueH+EXSNext,x
.010ca4	90 08		bcc $010cae		bcc 	_Binary_NoSubract 					; if A < M skip this
.010ca6	85 42		sta $42			sta 	DTemp1+2 							; save the calculated value.
.010ca8	a5 44		lda $44			lda 	DTemp2
.010caa	85 40		sta $40			sta 	DTemp1+0
.010cac	f6 00		inc $00,x		inc 	EXSValueL+0,x						; set bit 0 of Q
.010cae					_Binary_NoSubract:
.010cae	88		dey			dey 										; do it 32 times.
.010caf	d0 e0		bne $010c91		bne 	_BinaryDivide_Loop
.010cb1					_BinaryDivide_Exit:
.010cb1	a5 16		lda $16			lda 	DSignCount 							; restore sign
.010cb3	29 01 00	and #$0001		and 	#1
.010cb6	f0 03		beq $010cbb		beq 	_BinaryDivide_Exit2
.010cb8	20 bd 0c	jsr $010cbd		jsr 	Binary_DivNegate
.010cbb					_BinaryDivide_Exit2:
.010cbb	7a		ply			ply 										; restore Y
.010cbc	60		rts			rts
.010cbd					Binary_DivNegate:
.010cbd	e6 16		inc $16			inc 	DSignCount 							; increment the count of signs.
.010cbf	38		sec			sec 										; negate the value at stack X.
.010cc0	a9 00 00	lda #$0000		lda 	#$0000
.010cc3	f5 00		sbc $00,x		sbc 	EXSValueL+0,x
.010cc5	95 00		sta $00,x		sta 	EXSValueL+0,x
.010cc7	a9 00 00	lda #$0000		lda 	#$0000
.010cca	f5 02		sbc $02,x		sbc 	EXSValueH+0,x
.010ccc	95 02		sta $02,x		sta 	EXSValueH+0,x
.010cce	60		rts			rts
.010ccf					Binary_Modulus:
.010ccf	20 54 0c	jsr $010c54		jsr 	Binary_Divide 						; do the divide
.010cd2	a5 40		lda $40			lda 	DTemp1+0 							; copy modulus into data area.
.010cd4	95 00		sta $00,x		sta 	EXSValueL+0,x
.010cd6	a5 42		lda $42			lda 	DTemp1+2
.010cd8	95 02		sta $02,x		sta 	EXSValueH+0,x
.010cda	60		rts			rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/binary/multiply.asm

.010cdb					Binary_Multiply:
.010cdb	20 0c 06	jsr $01060c		jsr 	CheckBothNumeric 					; check both values are numeric
.010cde	b5 00		lda $00,x		lda 	EXSValueL+0,x 						; multiplier to DTemp1, multiplicand in Value+2
.010ce0	85 40		sta $40			sta 	DTemp1
.010ce2	b5 02		lda $02,x		lda 	EXSValueH+0,x
.010ce4	85 42		sta $42			sta		DTemp1+2
.010ce6	74 00		stz $00,x		stz 	EXSValueL+0,x						; zero result
.010ce8	74 02		stz $02,x		stz 	EXSValueH+0,x
.010cea					_BinaryMultiply_Loop:
.010cea	a5 40		lda $40			lda 	DTemp1 								; multiplier zero then exit
.010cec	05 42		ora $42			ora 	DTemp1+2
.010cee	f0 1e		beq $010d0e		beq 	_BinaryMultiply_Exit
.010cf0	a5 40		lda $40			lda 	DTemp1 								; check bit 0 of multiplier
.010cf2	29 01 00	and #$0001		and 	#1
.010cf5	f0 0d		beq $010d04		beq 	_BinaryMultiply_NoAdd
.010cf7	18		clc			clc 										; add multiplicand to result.
.010cf8	b5 00		lda $00,x		lda 	EXSValueL+0,x
.010cfa	75 06		adc $06,x		adc 	EXSValueL+EXSNext,x
.010cfc	95 00		sta $00,x		sta 	EXSValueL+0,x
.010cfe	b5 02		lda $02,x		lda 	EXSValueH+0,x
.010d00	75 08		adc $08,x		adc 	EXSValueH+EXSNext,x
.010d02	95 02		sta $02,x		sta 	EXSValueH+0,x
.010d04					_BinaryMultiply_NoAdd:
.010d04	46 42		lsr $42			lsr 	DTemp1+2 							; halve multiplier
.010d06	66 40		ror $40			ror 	DTemp1
.010d08	16 06		asl $06,x		asl 	EXSValueL+EXSNext,x					; double multiplicand
.010d0a	36 08		rol $08,x		rol 	EXSValueH+EXSNext,x
.010d0c	80 dc		bra $010cea		bra 	_BinaryMultiply_Loop 				; go round again.
.010d0e					_BinaryMultiply_Exit:
.010d0e	60		rts			rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/unary/simpleunary.asm

.010d0f					Function_Len:
.010d0f	20 2c 06	jsr $01062c			jsr 	ResetTypeInteger 			; returns an integer
.010d12	20 49 03	jsr $010349			jsr 	EvaluateNextString 			; get the value you are absoluting
.010d15	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket 			; check )
.010d18	b4 06		ldy $06,x			ldy 	EXSValueL+EXSNext,x 		; address of string.
.010d1a	b9 00 00	lda $0000,y			lda 	$0000,y 					; get the string length
.010d1d	29 ff 00	and #$00ff			and 	#$00FF 						; as a byte
.010d20	95 00		sta $00,x			sta 	EXSValueL+0,x 				; and return it
.010d22	74 02		stz $02,x			stz 	EXSValueH+0,x
.010d24	60		rts				rts
.010d25					Function_Abs:
.010d25	20 2c 06	jsr $01062c			jsr 	ResetTypeInteger 			; returns an integer
.010d28	20 2a 03	jsr $01032a			jsr 	EvaluateNextInteger 		; get the value you are absoluting
.010d2b	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket 			; check )
.010d2e	b5 08		lda $08,x			lda 	EXSValueH+EXSNext,x 		; get sign of result from the upper word.
.010d30	30 07		bmi $010d39			bmi 	_FAbsNegative 				; negate it if negative
.010d32	95 02		sta $02,x			sta 	EXSValueH+0,x 				; otherwise just copy it.
.010d34	b5 06		lda $06,x			lda 	EXSValueL+EXSNext,x
.010d36	95 00		sta $00,x			sta 	EXSValueL+0,x
.010d38	60		rts				rts
.010d39					_FAbsNegative:
.010d39	38		sec				sec 								; copy 0 - 2nd stack => 1st stack.
.010d3a	a9 00 00	lda #$0000			lda 	#0
.010d3d	f5 06		sbc $06,x			sbc 	EXSValueL+EXSNext,x
.010d3f	95 00		sta $00,x			sta 	EXSValueL+0,x
.010d41	a9 00 00	lda #$0000			lda 	#0
.010d44	f5 08		sbc $08,x			sbc 	EXSValueH+EXSNext,x
.010d46	95 02		sta $02,x			sta 	EXSValueH+0,x
.010d48	60		rts				rts
.010d49					Function_Sgn:
.010d49	20 2c 06	jsr $01062c			jsr 	ResetTypeInteger 			; returns integer
.010d4c	20 2a 03	jsr $01032a			jsr 	EvaluateNextInteger 		; get an integer
.010d4f	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket 			; check )
.010d52	74 00		stz $00,x			stz 	EXSValueL+0,x 				; zero the result
.010d54	74 02		stz $02,x			stz 	EXSValueH+0,x
.010d56	b5 08		lda $08,x			lda 	EXSValueH+EXSNext,x 		; get sign of result from high bit of upper word.
.010d58	30 07		bmi $010d61			bmi 	_FSgnNegative 				; set to -1 if signed
.010d5a	15 06		ora $06,x			ora 	EXSValueL+EXSNext,x 		; exit if zero as we already reset it.
.010d5c	f0 02		beq $010d60			beq 	_FSgnExit
.010d5e	f6 00		inc $00,x			inc 	EXSValueL+0,x 				; > 0 so make result 1 if positive and non-zero
.010d60					_FSgnExit:
.010d60	60		rts				rts
.010d61					_FSgnNegative:
.010d61	a9 ff ff	lda #$ffff			lda 	#$FFFF 						; set the return value to -1 as negative.
.010d64	95 00		sta $00,x			sta 	EXSValueL+0,x
.010d66	95 02		sta $02,x			sta 	EXSValueH+0,x
.010d68	60		rts				rts
.010d69					Function_Random:
.010d69	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket 			; check )
.010d6c	20 2c 06	jsr $01062c			jsr 	ResetTypeInteger
.010d6f	a5 54		lda $54				lda 	DRandom 					; check for non-zero
.010d71	05 56		ora $56				ora 	DRandom+2 					; they don't like these :)
.010d73	d0 0a		bne $010d7f			bne 	_Rnd_NotZero
.010d75	a9 b5 00	lda #$00b5			lda 	#$B5 						; initialise it to the same value.
.010d78	85 54		sta $54				sta 	DRandom
.010d7a	a9 ea 00	lda #$00ea			lda 	#$EA
.010d7d	85 56		sta $56				sta 	DRandom+2
.010d7f					_Rnd_NotZero:
.010d7f	20 8a 0d	jsr $010d8a			jsr 	_Rnd_Process 				; call randomiser twice
.010d82	95 02		sta $02,x			sta 	EXSValueH+0,x
.010d84	20 8a 0d	jsr $010d8a			jsr 	_Rnd_Process
.010d87	95 00		sta $00,x			sta 	EXSValueL+0,x
.010d89	60		rts				rts
.010d8a					_Rnd_Process:
.010d8a	06 54		asl $54				asl 	DRandom 					; shift right, exit
.010d8c	26 56		rol $56				rol 	DRandom+2
.010d8e	90 0e		bcc $010d9e			bcc 	_Rnd_Exit
.010d90	a5 54		lda $54				lda 	DRandom 					; taps effectively
.010d92	49 54 d4	eor #$d454			eor 	#$D454
.010d95	85 54		sta $54				sta 	DRandom
.010d97	a5 56		lda $56				lda 	DRandom+2
.010d99	49 d5 55	eor #$55d5			eor 	#$55D5
.010d9c	85 56		sta $56				sta 	DRandom+2
.010d9e					_Rnd_Exit:
.010d9e	a5 54		lda $54				lda 	DRandom
.010da0	45 56		eor $56				eor 	DRandom+2
.010da2	60		rts				rts
.010da3					Function_Chr:
.010da3	20 34 06	jsr $010634			jsr 	ResetTypeString 			; returns a string
.010da6	20 2a 03	jsr $01032a			jsr 	EvaluateNextInteger 		; get integer
.010da9	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket 			; check )
.010dac	c0 00 00	cpy #$0000			cpy 	#0 							; must be 0-255
.010daf	d0 12		bne $010dc3			bne 	_FCHBad
.010db1	48		pha				pha  								; save char # on stack
.010db2	a9 01 00	lda #$0001			lda 	#1 							; allocate a single character string
.010db5	20 21 07	jsr $010721			jsr 	StringTempAllocate
.010db8	68		pla				pla 								; restore character number
.010db9	20 51 07	jsr $010751			jsr 	StringWriteCharacter 		; write it out.
.010dbc	a5 0a		lda $0a				lda 	DStartTempString 			; return the string address
.010dbe	95 00		sta $00,x			sta 	EXSValueL+0,x 				; and return that.
.010dc0	74 02		stz $02,x			stz 	EXSValueH+0,x
.010dc2	60		rts				rts
.010dc3					_FCHBad:
.010dc3	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>010dc6	42 61 64 20 76 61 6c 75				.text 	"Bad value for chr$()",$00 								; with this message
>010dce	65 20 66 6f 72 20 63 68 72 24 28 29 00
.010ddb					Function_Asc:
.010ddb	20 2c 06	jsr $01062c			jsr 	ResetTypeInteger 			; returns an integer
.010dde	20 49 03	jsr $010349			jsr 	EvaluateNextString 			; get string
.010de1	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket 			; check )
.010de4	a8		tay				tay 								; string address in Y
.010de5	b9 00 00	lda $0000,y			lda 	$0000,y 					; check length non zero
.010de8	29 ff 00	and #$00ff			and 	#$00FF
.010deb	f0 0b		beq $010df8			beq 	_FASBad 					; what does ASC("") do ? return 0 - error here.
.010ded	b9 01 00	lda $0001,y			lda 	$0001,y 					; get first char
.010df0	29 ff 00	and #$00ff			and 	#$00FF 						; mask it
.010df3	95 00		sta $00,x			sta 	EXSValueL+0,x 				; and return that.
.010df5	74 02		stz $02,x			stz 	EXSValueH+0,x
.010df7	60		rts				rts
.010df8					_FASBad:
.010df8	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>010dfb	42 61 64 20 76 61 6c 75				.text 	"Bad value for asc()",$00 								; with this message
>010e03	65 20 66 6f 72 20 61 73 63 28 29 00
.010e0f					Function_SPC:
.010e0f	20 34 06	jsr $010634			jsr 	ResetTypeString 			; returns a string
.010e12	20 2a 03	jsr $01032a			jsr 	EvaluateNextInteger 		; get integer, which is the length.
.010e15	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket 			; check )
.010e18	c0 00 00	cpy #$0000			cpy 	#0 							; must be 0-255
.010e1b	d0 17		bne $010e34			bne 	_FSPBad
.010e1d	48		pha				pha 								; save length
.010e1e	20 21 07	jsr $010721			jsr 	StringTempAllocate 			; allocate character space
.010e21	7a		ply				ply 								; get count in Y
.010e22	f0 09		beq $010e2d			beq 	_FSPExit 					; if zero, just empty string
.010e24					_FSPCopy:
.010e24	a9 20 00	lda #$0020			lda 	#" "						; space character
.010e27	20 51 07	jsr $010751			jsr 	StringWriteCharacter 		; write it out.
.010e2a	88		dey				dey
.010e2b	d0 f7		bne $010e24			bne 	_FSPCopy	 				; do it Y times
.010e2d					_FSPExit:
.010e2d	a5 0a		lda $0a				lda 	DStartTempString 			; return that address
.010e2f	95 00		sta $00,x			sta 	EXSValueL+0,x
.010e31	74 02		stz $02,x			stz 	EXSValueH+0,x
.010e33	60		rts				rts
.010e34					_FSPBad:
.010e34	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>010e37	42 61 64 20 76 61 6c 75				.text 	"Bad value for spc()",$00 								; with this message
>010e3f	65 20 66 6f 72 20 73 70 63 28 29 00
.010e4b					Function_Inkey:
.010e4b	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket 			; check )
.010e4e	20 2c 06	jsr $01062c			jsr 	ResetTypeInteger
.010e51	20 95 1e	jsr $011e95			jsr 	HWInkey 					; read current key
.010e54	95 00		sta $00,x			sta 	EXSValueL+0,x
.010e56	74 02		stz $02,x			stz 	EXSValueH+0,x
.010e58	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/unary/string.asm

.010e59					Function_LEFT:
.010e59	20 34 06	jsr $010634			jsr 	ResetTypeString 			; returns a string.
.010e5c	20 49 03	jsr $010349			jsr 	EvaluateNextString 			; get the value you are absoluting
.010e5f	48		pha				pha 								; save string on stack.
.010e60	20 03 06	jsr $010603			jsr 	ExpectComma 				; get count
.010e63	20 2a 03	jsr $01032a			jsr 	EvaluateNextInteger
.010e66	c0 00 00	cpy #$0000			cpy 	#0 							; can't be high
.010e69	d0 6d		bne $010ed8			bne 	FNStringParameter
.010e6b	85 40		sta $40				sta 	DTemp1 						; save count.
.010e6d	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket
.010e70	7a		ply				ply 								; Y points to string.
.010e71	b9 00 00	lda $0000,y			lda 	$0000,y 					; get length of string
.010e74	29 ff 00	and #$00ff			and 	#$00FF
.010e77	f0 52		beq $010ecb			beq 	FNStringEmpty 				; return empty if zero length anyway.
.010e79	c5 40		cmp $40				cmp 	DTemp1 						; compare current vs required length
.010e7b	f0 55		beq $010ed2			beq 	FNStringY 					; return string in Y if current len = required len.
.010e7d	90 53		bcc $010ed2			bcc 	FNStringY 					; if current < required return whole thing.
.010e7f	c8		iny				iny 								; take from here - start of string
.010e80	80 33		bra $010eb5			bra 	FNDTemp1Characters
.010e82					Function_RIGHT:
.010e82	20 34 06	jsr $010634			jsr 	ResetTypeString 			; returns a string.
.010e85	20 49 03	jsr $010349			jsr 	EvaluateNextString 			; get the value you are absoluting
.010e88	48		pha				pha 								; save string on stack.
.010e89	20 03 06	jsr $010603			jsr 	ExpectComma 				; get count
.010e8c	20 2a 03	jsr $01032a			jsr 	EvaluateNextInteger
.010e8f	c0 00 00	cpy #$0000			cpy 	#0 							; can't be high
.010e92	d0 44		bne $010ed8			bne 	FNStringParameter
.010e94	85 40		sta $40				sta 	DTemp1 						; save count.
.010e96	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket
.010e99	7a		ply				ply 								; Y points to string.
.010e9a	b9 00 00	lda $0000,y			lda 	$0000,y 					; get length of string
.010e9d	29 ff 00	and #$00ff			and 	#$00FF
.010ea0	f0 29		beq $010ecb			beq 	FNStringEmpty 				; return empty if zero length anyway.
.010ea2	c5 40		cmp $40				cmp 	DTemp1 						; compare current vs required length
.010ea4	f0 2c		beq $010ed2			beq 	FNStringY 					; return string in Y if current len = required len.
.010ea6	90 2a		bcc $010ed2			bcc 	FNStringY 					; if current < required return whole thing.
.010ea8	38		sec				sec 								; current-required is the number to skip
.010ea9	e5 40		sbc $40				sbc 	DTemp1
.010eab	85 42		sta $42				sta 	DTemp1+2
.010ead	98		tya				tya
.010eae	18		clc				clc
.010eaf	65 42		adc $42				adc 	DTemp1+2
.010eb1	a8		tay				tay
.010eb2	c8		iny				iny 								; +1 for the count.
.010eb3	80 00		bra $010eb5			bra 	FNDTemp1Characters
.010eb5					FNDTemp1Characters:
.010eb5	a5 40		lda $40				lda 	DTemp1 						; we need this big a string.
.010eb7	f0 12		beq $010ecb			beq 	FNStringEmpty 				; if zero, return empty string.
.010eb9	20 21 07	jsr $010721			jsr 	StringTempAllocate
.010ebc	48		pha				pha 								; save the address
.010ebd					_FND1Loop:
.010ebd	b9 00 00	lda $0000,y			lda 	$0000,y 					; character to copy
.010ec0	20 51 07	jsr $010751			jsr 	StringWriteCharacter
.010ec3	c8		iny				iny
.010ec4	c6 40		dec $40				dec 	DTemp1 						; DTemp1 times
.010ec6	d0 f5		bne $010ebd			bne 	_FND1Loop
.010ec8	7a		ply				ply 								; string address in Y
.010ec9	80 07		bra $010ed2			bra 	FNStringY
.010ecb					FNStringEmpty:
.010ecb	a9 00 00	lda #$0000			lda 	#0 							; return an empty string.
.010ece	20 21 07	jsr $010721			jsr 	StringTempAllocate 			; put address of it in Y
.010ed1	a8		tay				tay
.010ed2					FNStringY:
.010ed2	98		tya				tya
.010ed3	95 00		sta $00,x			sta 	EXSValueL+0,x
.010ed5	74 08		stz $08,x			stz 	EXSValueH+EXSNext,x
.010ed7	60		rts				rts
.010ed8					FNStringParameter:
.010ed8	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>010edb	42 61 64 20 53 74 72 69				.text 	"Bad String Operation",$00 								; with this message
>010ee3	6e 67 20 4f 70 65 72 61 74 69 6f 6e 00
.010ef0					Function_MID:
.010ef0	20 34 06	jsr $010634			jsr 	ResetTypeString 			; returns a string.
.010ef3	20 49 03	jsr $010349			jsr 	EvaluateNextString 			; get the value you are absoluting
.010ef6	48		pha				pha 								; save string on stack.
.010ef7	20 03 06	jsr $010603			jsr 	ExpectComma 				; get offset (n)
.010efa	20 2a 03	jsr $01032a			jsr 	EvaluateNextInteger
.010efd	c0 00 00	cpy #$0000			cpy 	#0 							; can't be high
.010f00	d0 d6		bne $010ed8			bne 	FNStringParameter
.010f02	c9 00 00	cmp #$0000			cmp 	#0
.010f05	f0 d1		beq $010ed8			beq 	FNStringParameter 			; or zero
.010f07	48		pha				pha 								; save start position on stack.
.010f08	a9 ff 00	lda #$00ff			lda 	#255 						; default third parameter is 255 e.g. whole string
.010f0b	85 40		sta $40				sta 	DTemp1
.010f0d	b2 06		lda ($06)			lda 	(DCodePtr) 					; is there a comma
.010f0f	c9 24 32	cmp #$3224			cmp 	#commaTokenID
.010f12	d0 0e		bne $010f22			bne 	_FMINoThird
.010f14	e6 06		inc $06				inc 	DCodePtr 					; skip the comma
.010f16	e6 06		inc $06				inc 	DCodePtr
.010f18	20 2a 03	jsr $01032a			jsr 	EvaluateNextInteger 		; how many to do (n1)
.010f1b	c0 00 00	cpy #$0000			cpy 	#0 							; can't be high
.010f1e	d0 b8		bne $010ed8			bne 	FNStringParameter
.010f20	85 40		sta $40				sta 	DTemp1 						; save in DTemp1 (characters to count)
.010f22					_FMINoThird:
.010f22	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket
.010f25	68		pla				pla 								; get offset position
.010f26	85 44		sta $44				sta 	DTemp2
.010f28	7a		ply				ply 								; get address of string in Y
.010f29	b9 00 00	lda $0000,y			lda		$0000,y 					; get length
.010f2c	29 ff 00	and #$00ff			and 	#$00FF
.010f2f	c5 44		cmp $44				cmp 	DTemp2 						; check length of string vs offset position
.010f31	90 98		bcc $010ecb			bcc 	FNStringEmpty 				; if length <= offset position then return ""
.010f33	38		sec				sec 								; calculate number of characters left after
.010f34	e5 44		sbc $44				sbc 	DTemp2 						; offset
.010f36	1a		inc a				inc 	a 							; there is one more because of index starts at 1.
.010f37	c5 40		cmp $40				cmp 	DTemp1 						; available -- chars required.
.010f39	b0 02		bcs $010f3d			bcs 	_FMISufficient
.010f3b	85 40		sta $40				sta 	DTemp1 						; if available < chars required, only copy those
.010f3d					_FMISufficient:
.010f3d	98		tya				tya 								; get address
.010f3e	18		clc				clc
.010f3f	65 44		adc $44				adc 	DTemp2 						; add the offset, the extra 1 (index) skips length
.010f41	a8		tay				tay 								; put in Y
.010f42	82 70 ff	brl $010eb5			brl 	FNDTemp1Characters			; and copy them.

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/unary/memread.asm

.010f45					Function_Peek:
.010f45	20 2c 06	jsr $01062c			jsr 	ResetTypeInteger 			; returns an integer
.010f48	20 2a 03	jsr $01032a			jsr 	EvaluateNextInteger 		; get the value you are absoluting
.010f4b	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket 			; check )
.010f4e	85 40		sta $40				sta 	DTemp1 						; save address in DTemp
.010f50	84 42		sty $42				sty 	DTemp1+2
.010f52	a0 00 00	ldy #$0000			ldy 	#0							; read data
.010f55	b7 40		lda [$40],y			lda 	[DTemp1],y
.010f57	29 ff 00	and #$00ff			and 	#$00FF 						; mask
.010f5a	95 00		sta $00,x			sta 	EXSValueL+0,x 				; write out.
.010f5c	74 02		stz $02,x			stz 	EXSValueH+0,x
.010f5e	60		rts				rts
.010f5f					Function_Deek:
.010f5f	20 2c 06	jsr $01062c			jsr 	ResetTypeInteger 			; returns an integer
.010f62	20 2a 03	jsr $01032a			jsr 	EvaluateNextInteger 		; get the value you are absoluting
.010f65	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket 			; check )
.010f68	85 40		sta $40				sta 	DTemp1 						; save address in DTemp
.010f6a	84 42		sty $42				sty 	DTemp1+2
.010f6c	a0 00 00	ldy #$0000			ldy 	#0							; read data
.010f6f	b7 40		lda [$40],y			lda 	[DTemp1],y
.010f71	95 00		sta $00,x			sta 	EXSValueL+0,x 				; write out.
.010f73	74 02		stz $02,x			stz 	EXSValueH+0,x
.010f75	60		rts				rts
.010f76					Function_Leek:
.010f76	20 2c 06	jsr $01062c			jsr 	ResetTypeInteger 			; returns an integer
.010f79	20 2a 03	jsr $01032a			jsr 	EvaluateNextInteger 		; get the value you are absoluting
.010f7c	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket 			; check )
.010f7f	85 40		sta $40				sta 	DTemp1 						; save address in DTemp
.010f81	84 42		sty $42				sty 	DTemp1+2
.010f83	a0 00 00	ldy #$0000			ldy 	#0							; read data
.010f86	b7 40		lda [$40],y			lda 	[DTemp1],y
.010f88	95 00		sta $00,x			sta 	EXSValueL+0,x 				; write out.
.010f8a	c8		iny				iny
.010f8b	c8		iny				iny
.010f8c	b7 40		lda [$40],y			lda 	[DTemp1],y
.010f8e	95 02		sta $02,x			sta 	EXSValueH+0,x
.010f90	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/unary/val.asm

.010f91					Function_VAL:
.010f91	20 2c 06	jsr $01062c			jsr 	ResetTypeInteger 			; returns an integer
.010f94	20 49 03	jsr $010349			jsr 	EvaluateNextString 			; get the value you are absoluting
.010f97	48		pha				pha 								; put string address on stack.
.010f98	20 a8 0f	jsr $010fa8			jsr 	VALGetBase 					; process , base (shared with STR$())
.010f9b	7a		ply				ply 								; get string address back
.010f9c	da		phx				phx 								; save X on stack
.010f9d	aa		tax				tax 								; base in X
.010f9e	98		tya				tya 								; address in A
.010f9f	20 e2 0f	jsr $010fe2			jsr 	StringToInteger
.010fa2	fa		plx				plx 								; restore X
.010fa3	95 00		sta $00,x			sta 	EXSValueL+0,x
.010fa5	94 02		sty $02,x			sty 	EXSValueH+0,x
.010fa7	60		rts				rts
.010fa8					VALGetBase:
.010fa8	b2 06		lda ($06)			lda 	(DCodePtr)					; look at next
.010faa	c9 24 32	cmp #$3224			cmp 	#commaTokenID 				; if comma, go to get base code.
.010fad	f0 07		beq $010fb6			beq 	_VGBAlternate
.010faf	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket			; expect ), and return 10.
.010fb2	a9 0a 00	lda #$000a			lda 	#10
.010fb5	60		rts				rts
.010fb6					_VGBAlternate:
.010fb6	20 03 06	jsr $010603			jsr 	ExpectComma 				; skip comma.
.010fb9	20 2a 03	jsr $01032a			jsr 	EvaluateNextInteger 		; get base
.010fbc	c0 00 00	cpy #$0000			cpy 	#0							; check base legal
.010fbf	d0 0e		bne $010fcf			bne 	_VGBBadBase
.010fc1	c9 02 00	cmp #$0002			cmp 	#2
.010fc4	90 09		bcc $010fcf			bcc 	_VGBBadBase
.010fc6	c9 11 00	cmp #$0011			cmp 	#16+1						; 0-9A-F
.010fc9	b0 04		bcs $010fcf			bcs 	_VGBBadBase
.010fcb	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket 			; get right bracket and return.
.010fce	60		rts				rts
.010fcf					_VGBBadBase:
.010fcf	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>010fd2	42 61 64 20 4e 75 6d 62				.text 	"Bad Number Base",$00 								; with this message
>010fda	65 72 20 42 61 73 65 00
.010fe2					StringToInteger:
.010fe2	85 48		sta $48				sta 	DTemp3 						; DTemp3 is the character pointer
.010fe4	b2 48		lda ($48)			lda 	(DTemp3)					; DTemp3+2 is the character count to do.
.010fe6	29 ff 00	and #$00ff			and 	#$00FF
.010fe9	85 4a		sta $4a				sta 	DTemp3+2
.010feb	f0 6e		beq $01105b			beq 	_STIError 					; if length zero it's bad.
.010fed	e6 48		inc $48				inc 	DTemp3 						; skip length byte.
.010fef	86 16		stx $16				stx 	DSignCount 					; Signcount is the base, 2-16.
.010ff1	64 40		stz $40				stz 	DTemp1 						; Zero DTemp1, this is the result register.
.010ff3	64 42		stz $42				stz 	DTemp1+2
.010ff5	b2 48		lda ($48)			lda 	(DTemp3)					; look at first character
.010ff7	29 ff 00	and #$00ff			and 	#$00FF 						; mask off
.010ffa	48		pha				pha 								; push on stack
.010ffb	c9 2d 00	cmp #$002d			cmp 	#"-"						; if not -, skip
.010ffe	d0 06		bne $011006			bne 	_STILoop
.011000	e6 48		inc $48				inc 	DTemp3 						; advance pointer over minus sign
.011002	c6 4a		dec $4a				dec 	DTemp3+2					; dec count
.011004	f0 55		beq $01105b			beq 	_STIError 					; if only - then error.
.011006					_STILoop:
.011006	a5 16		lda $16				lda 	DSignCount 					; multiply DTemp1 by DSignCount
.011008	20 7a 10	jsr $01107a			jsr 	MultiplyTemp1ByA
.01100b	b2 48		lda ($48)			lda 	(DTemp3)					; get character, mask
.01100d	29 ff 00	and #$00ff			and 	#$00FF
.011010	20 6b 10	jsr $01106b			jsr 	ConvertUpperCase	 		; make U/C
.011013	c9 30 00	cmp #$0030			cmp 	#'0' 						; validate it check if 0-9
.011016	90 43		bcc $01105b			bcc 	_STIError
.011018	c9 3a 00	cmp #$003a			cmp 	#'9'+1
.01101b	90 0e		bcc $01102b			bcc 	_STIOkay1
.01101d	c9 41 00	cmp #$0041			cmp 	#'A' 						; check if A-Z
.011020	90 39		bcc $01105b			bcc 	_STIError
.011022	c9 5b 00	cmp #$005b			cmp 	#'Z'+1
.011025	b0 34		bcs $01105b			bcs 	_STIError
.011027	18		clc				clc 								; shift to correct range.
.011028	69 09 00	adc #$0009			adc 	#9
.01102b					_STIOkay1:
.01102b	29 0f 00	and #$000f			and 	#15 						; now in range 0-35
.01102e	c5 16		cmp $16				cmp 	DSignCount 					; error if >= base
.011030	b0 29		bcs $01105b			bcs 	_STIError
.011032	18		clc				clc 								; add A to DTemp1
.011033	65 40		adc $40				adc 	DTemp1
.011035	85 40		sta $40				sta 	DTemp1
.011037	90 02		bcc $01103b			bcc 	_STINoCarry
.011039	e6 42		inc $42				inc 	DTemp1+2
.01103b					_STINoCarry:
.01103b	e6 48		inc $48				inc 	DTemp3 						; get character, pre-increment because of count byte
.01103d	c6 4a		dec $4a				dec 	DTemp3+2 					; decrement counter
.01103f	d0 c5		bne $011006			bne 	_STILoop 					; loop back.
.011041	68		pla				pla 								; get optional minus bac
.011042	c9 2d 00	cmp #$002d			cmp 	#"-"
.011045	d0 0f		bne $011056			bne 	_STINotNegative 			; handle the negative character
.011047	38		sec				sec 								; negate DTemp1
.011048	a9 00 00	lda #$0000			lda 	#0
.01104b	e5 40		sbc $40				sbc 	DTemp1
.01104d	85 40		sta $40				sta 	DTemp1
.01104f	a9 00 00	lda #$0000			lda 	#0
.011052	e5 42		sbc $42				sbc 	DTemp1+2
.011054	85 42		sta $42				sta 	DTemp1+2
.011056					_STINotNegative:
.011056	a5 40		lda $40				lda 	DTemp1 						; get the result
.011058	a4 42		ldy $42				ldy 	DTemp1+2
.01105a	60		rts				rts
.01105b					_STIError:
.01105b	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>01105e	42 61 64 20 63 6f 6e 73				.text 	"Bad constant",$00 								; with this message
>011066	74 61 6e 74 00
.01106b					ConvertUpperCase:
.01106b	c9 61 00	cmp #$0061			cmp 	#'a'
.01106e	90 09		bcc $011079			bcc 	_CUCExit
.011070	c9 7b 00	cmp #$007b			cmp 	#'z'+1
.011073	b0 04		bcs $011079			bcs 	_CUCExit
.011075	38		sec				sec
.011076	e9 20 00	sbc #$0020			sbc 	#32
.011079					_CUCExit:
.011079	60		rts				rts
.01107a					MultiplyTemp1ByA:
.01107a					_MTGeneral:
.01107a	da		phx				phx
.01107b	aa		tax				tax 								; multiplier in X
.01107c	a5 40		lda $40				lda 	DTemp1 						; copy DTemp1 to DTemp2
.01107e	85 44		sta $44				sta 	DTemp2
.011080	a5 42		lda $42				lda 	DTemp1+2
.011082	85 46		sta $46				sta 	DTemp2+2
.011084	64 40		stz $40				stz 	DTemp1 						; zero DTemp1
.011086	64 42		stz $42				stz 	DTemp1+2
.011088	a0 00 00	ldy #$0000			ldy 	#0 		 					; this is the 'high byte' of the result.
.01108b					_MTLoop:
.01108b	8a		txa				txa 								; shift X right into C
.01108c	4a		lsr a				lsr 	a
.01108d	aa		tax				tax
.01108e	90 10		bcc $0110a0			bcc 	_MTNoAdd
.011090	18		clc				clc
.011091	a5 40		lda $40				lda 	DTemp1 						; add if LSB set
.011093	65 44		adc $44				adc 	DTemp2
.011095	85 40		sta $40				sta 	DTemp1
.011097	a5 42		lda $42				lda 	DTemp1+2
.011099	65 46		adc $46				adc 	DTemp2+2
.01109b	85 42		sta $42				sta 	DTemp1+2
.01109d	90 01		bcc $0110a0			bcc 	_MTNoAdd
.01109f	c8		iny				iny
.0110a0					_MTNoAdd:
.0110a0	06 44		asl $44				asl 	DTemp2  					; shift multiplicand left
.0110a2	26 46		rol $46				rol 	DTemp2+2
.0110a4	90 01		bcc $0110a7			bcc 	_MTNoOverflow
.0110a6	c8		iny				iny
.0110a7					_MTNoOverflow:
.0110a7	8a		txa				txa 								; until multiplier is zero.
.0110a8	d0 e1		bne $01108b			bne 	_MTLoop
.0110aa	98		tya				tya
.0110ab	18		clc				clc
.0110ac	69 ff ff	adc #$ffff			adc 	#$FFFF
.0110af	fa		plx				plx 								; restore X
.0110b0	60		rts				rts 								; and exit

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/unary/str.asm

.0110b1					Function_Str:
.0110b1	20 34 06	jsr $010634			jsr 	ResetTypeString 			; returns a string.
.0110b4	20 2a 03	jsr $01032a			jsr 	EvaluateNextInteger 		; get the value you are absoluting
.0110b7	48		pha				pha 								; save YA on the stack
.0110b8	5a		phy				phy
.0110b9	20 a8 0f	jsr $010fa8			jsr 	VALGetBase 					; process , base (shared with STR$())
.0110bc	85 16		sta $16				sta 	DSignCount
.0110be	7a		ply				ply 								; YA is the number
.0110bf	68		pla				pla
.0110c0	da		phx				phx
.0110c1	a6 16		ldx $16				ldx 	DSignCount 					; X is the base.
.0110c3	20 cc 10	jsr $0110cc			jsr 	ConvertToString 			; convert it to a string.
.0110c6	fa		plx				plx 								; restore X
.0110c7	95 00		sta $00,x			sta 	EXSValueL+0,x 				; save the result
.0110c9	74 02		stz $02,x			stz 	EXSValueH+0,x
.0110cb	60		rts				rts
.0110cc					ConvertToString:
.0110cc	48		pha				pha
.0110cd	a9 22 00	lda #$0022			lda 	#34 						; enough space for Base 2.
.0110d0	20 21 07	jsr $010721			jsr 	StringTempAllocate 			; allocate space for return string.
.0110d3	68		pla				pla
.0110d4					ConvertToStringAlreadyAllocated:
.0110d4	da		phx				phx 								; save X (base)
.0110d5	85 48		sta $48				sta 	DTemp3 						; save number in DTemp3
.0110d7	84 4a		sty $4a				sty 	DTemp3+2
.0110d9	86 16		stx $16				stx 	DSignCount 					; save base in DSignCount.
.0110db	a5 4a		lda $4a				lda 	DTemp3+2 					; is number -ve.
.0110dd	10 15		bpl $0110f4			bpl 	_CTSNotNegative
.0110df	a9 2d 00	lda #$002d			lda 	#"-"						; output a minus character to the new string
.0110e2	20 5e 11	jsr $01115e			jsr 	CTSOutputA
.0110e5	38		sec				sec 								; negate DTemp3 which is the number
.0110e6	a9 00 00	lda #$0000			lda 	#0
.0110e9	e5 48		sbc $48				sbc 	DTemp3
.0110eb	85 48		sta $48				sta 	DTemp3
.0110ed	a9 00 00	lda #$0000			lda 	#0
.0110f0	e5 4a		sbc $4a				sbc 	DTemp3+2
.0110f2	85 4a		sta $4a				sta 	DTemp3+2
.0110f4					_CTSNotNegative:
.0110f4	a9 01 00	lda #$0001			lda 	#1 							; push 32-bit 1 on stack, which is the first subtractor.
.0110f7	48		pha				pha
.0110f8	a9 00 00	lda #$0000			lda 	#0
.0110fb	48		pha				pha
.0110fc	a5 16		lda $16				lda 	DSignCount 					; reset DTemp1, the subtractor to the base value
.0110fe	85 40		sta $40				sta 	DTemp1
.011100	64 42		stz $42				stz 	DTemp1+2
.011102					_CTSMultiplySubtractor:
.011102	38		sec				sec 								; check number vs subtractor
.011103	a5 48		lda $48				lda 	DTemp3
.011105	e5 40		sbc $40				sbc 	DTemp1
.011107	a5 4a		lda $4a				lda 	DTemp3+2
.011109	e5 42		sbc $42				sbc 	DTemp1+2
.01110b	90 0f		bcc $01111c			bcc		_CTSScaledUp 				; if >= then scaled up.
.01110d	a5 40		lda $40				lda 	DTemp1 						; push subtractor on the stack
.01110f	48		pha				pha
.011110	a5 42		lda $42				lda 	DTemp1+2
.011112	48		pha				pha
.011113	a5 16		lda $16				lda 	DSignCount 					; multiply subtractor by base
.011115	20 7a 10	jsr $01107a			jsr 	MultiplyTemp1ByA
.011118	b0 02		bcs $01111c			bcs 	_CTSScaledUp 				; if overflow, start subtracting.
.01111a	80 e6		bra $011102			bra 	_CTSMultiplySubtractor 		; otherwise try the next x base.
.01111c					_CTSScaledUp:
.01111c	7a		ply				ply 								; YA contains the previous divider.
.01111d	68		pla				pla
.01111e	c0 00 00	cpy #$0000			cpy 	#0 							; has that divider reached one yet ?
.011121	d0 05		bne $011128			bne 	_CTSHasDigit
.011123	c9 01 00	cmp #$0001			cmp 	#1 							; if so, then we've just got that digit left.
.011126	f0 20		beq $011148			beq 	_CTSExit
.011128					_CTSHasDigit:
.011128	85 44		sta $44				sta 	DTemp2 						; save in DTemp2
.01112a	84 46		sty $46				sty 	DTemp2+2
.01112c	a2 00 00	ldx #$0000			ldx 	#0 							; this is the count.
.01112f					_CTSSubLoop:
.01112f	38		sec				sec 								; subtract subtractor from number
.011130	a5 48		lda $48				lda 	DTemp3
.011132	e5 44		sbc $44				sbc 	DTemp2
.011134	a8		tay				tay 								; intermediate in Y
.011135	a5 4a		lda $4a				lda 	DTemp3+2
.011137	e5 46		sbc $46				sbc 	DTemp2+2
.011139	90 07		bcc $011142			bcc 	_CTSFinishedSubtracting 	; if number < subtractor then completed this one.
.01113b	85 4a		sta $4a				sta 	DTemp3+2 					; output the number to DTemp3.
.01113d	84 48		sty $48				sty 	DTemp3
.01113f	e8		inx				inx 								; one more subtraction
.011140	80 ed		bra $01112f			bra 	_CTSSubLoop 				; try it again.
.011142					_CTSFinishedSubtracting:
.011142	8a		txa				txa 								; convert to ASCII.
.011143	20 51 11	jsr $011151			jsr 	CTSOutputHexDigit 			; write that out.
.011146	80 d4		bra $01111c			bra 	_CTSScaledUp 				; go pop the next subtactor and do that.
.011148					_CTSExit:
.011148	a5 48		lda $48				lda 	DTemp3 						; output last digit
.01114a	20 51 11	jsr $011151			jsr 	CTSOutputHexDigit
.01114d	a5 0a		lda $0a				lda 	DStartTempString 			; return string address.
.01114f	fa		plx				plx 								; restore X.
.011150	60		rts				rts
.011151					CTSOutputHexDigit:
.011151	c9 0a 00	cmp #$000a			cmp 	#10 						; 0-9 are 48-56
.011154	90 04		bcc $01115a			bcc 	_CTSNotLetter
.011156	18		clc				clc
.011157	69 27 00	adc #$0027			adc 	#65-58+32 					; shift for bases > 10
.01115a					_CTSNotLetter:
.01115a	18		clc				clc
.01115b	69 30 00	adc #$0030			adc 	#48
.01115e					CTSOutputA:
.01115e	5a		phy				phy 								; save Y, set Y to current pointer
.01115f	a4 0c		ldy $0c				ldy 	DCurrentTempString
.011161	99 00 00	sta $0000,y			sta 	$0000,y 					; write out, with a following zero.
.011164	e2 20		sep #$20			sep 	#$20 						; save in 8 bit mode.
.011166	b2 0a		lda ($0a)			lda 	(DStartTempString)			; increment character count.
.011168	1a		inc a				inc 	a
.011169	92 0a		sta ($0a)			sta 	(DStartTempString)
.01116b	c2 20		rep #$20			rep 	#$20
.01116d	e6 0c		inc $0c				inc 	DCurrentTempString 			; advance the pointer.
.01116f	7a		ply				ply 								; restore Y and exit.
.011170	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/unary/instr.asm

.011171					Function_INSTR:
.011171	20 2c 06	jsr $01062c			jsr 	ResetTypeInteger 			; returns a integer
.011174	20 49 03	jsr $010349			jsr 	EvaluateNextString 			; evaluate a string.
.011177	48		pha				pha 								; save string to search
.011178	20 03 06	jsr $010603			jsr 	ExpectComma
.01117b	20 49 03	jsr $010349			jsr 	EvaluateNextString 			; string to search for
.01117e	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket
.011181	85 40		sta $40				sta 	DTemp1 						; DTemp1 is the string to search for
.011183	68		pla				pla
.011184	85 44		sta $44				sta 	DTemp2 						; DTemp2 is the string to search.
.011186	74 02		stz $02,x			stz 	EXSValueH+0,x 				; set high word to zero.
.011188	74 00		stz $00,x			stz 	EXSValueL+0,x 				; zero low word.
.01118a	e2 20		sep #$20			sep 	#$20 						; calculate len(search)-len(lookfor)
.01118c	38		sec				sec
.01118d	b2 44		lda ($44)			lda 	(DTemp2)
.01118f	f2 40		sbc ($40)			sbc		(DTemp1)
.011191	c2 20		rep #$20			rep 	#$20
.011193	90 2c		bcc $0111c1			bcc 	_FINSFail 					; if the string being searched is shorter, fail.
.011195	29 ff 00	and #$00ff			and 	#$00FF
.011198	1a		inc a				inc 	a
.011199	85 48		sta $48				sta 	DTemp3 						; this is the number of matches we can try.
.01119b	b2 40		lda ($40)			lda 	(DTemp1) 					; fail if first string is ""
.01119d	29 ff 00	and #$00ff			and 	#$00FF
.0111a0	f0 22		beq $0111c4			beq 	_FINSError
.0111a2					_FINSLoop:
.0111a2	b5 00		lda $00,x			lda 	EXSValueL+0,x 				; pre-increment as we start indices at 1.
.0111a4	1a		inc a				inc 	a
.0111a5	95 00		sta $00,x			sta 	EXSValueL+0,x
.0111a7	b2 40		lda ($40)			lda 	(DTemp1) 					; characters to match
.0111a9	29 ff 00	and #$00ff			and 	#$00FF
.0111ac	a8		tay				tay									; start comparing at index 1.
.0111ad					_FINSCompare:
.0111ad	b1 40		lda ($40),y			lda 	(DTemp1),y 					; char match ?
.0111af	51 44		eor ($44),y			eor 	(DTemp2),y
.0111b1	29 ff 00	and #$00ff			and 	#$00FF
.0111b4	d0 05		bne $0111bb			bne 	_FINSNext
.0111b6	88		dey				dey
.0111b7	d0 f4		bne $0111ad			bne 	_FINSCompare
.0111b9	80 08		bra $0111c3			bra 	_FINSExit
.0111bb					_FINSNext:
.0111bb	e6 44		inc $44				inc 	DTemp2 						; bump pointer in string being searched
.0111bd	c6 48		dec $48				dec 	DTemp3 						; keep trying this many times
.0111bf	d0 e1		bne $0111a2			bne 	_FINSLoop
.0111c1					_FINSFail:
.0111c1	74 00		stz $00,x			stz 	EXSValueL+0,x 				; return 0
.0111c3					_FINSExit:
.0111c3	60		rts				rts
.0111c4					_FINSError:
.0111c4	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>0111c7	4e 6f 20 53 65 61 72 63				.text 	"No Search String",$00 								; with this message
>0111cf	68 20 53 74 72 69 6e 67 00

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/unary/caseconv.asm

.0111d8					Function_UPPER:
.0111d8	20 34 06	jsr $010634			jsr 	ResetTypeString 			; returns a string.
.0111db	20 49 03	jsr $010349			jsr 	EvaluateNextString 			; evaluate a string.
.0111de	48		pha				pha
.0111df	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket 			; close call.
.0111e2	20 21 07	jsr $010721			jsr		StringTempAllocate 			; allocate memory for it
.0111e5	68		pla				pla
.0111e6	20 5f 07	jsr $01075f			jsr 	StringCreateCopy 			; create a copy of it.
.0111e9	a5 0a		lda $0a				lda 	DStartTempString 			; A = start of temporary string.
.0111eb	95 00		sta $00,x			sta 	EXSValueL+0,x
.0111ed	a8		tay				tay 								; address in Y
.0111ee	74 02		stz $02,x			stz 	EXSValueH+0,x
.0111f0	da		phx				phx 								; save X
.0111f1	b2 0a		lda ($0a)			lda 	(DStartTempString)			; get string length
.0111f3	29 ff 00	and #$00ff			and 	#$00FF
.0111f6	f0 20		beq $011218			beq 	_FUPExit
.0111f8	aa		tax				tax 								; put in X
.0111f9					_FUPLoop:
.0111f9	c8		iny				iny 								; increment and load character
.0111fa	b9 00 00	lda $0000,y			lda 	$0000,y
.0111fd	29 ff 00	and #$00ff			and 	#$00FF
.011200	c9 61 00	cmp #$0061			cmp 	#"a" 						; check range
.011203	90 10		bcc $011215			bcc 	_FUPNoChange
.011205	c9 7b 00	cmp #$007b			cmp 	#"z"+1
.011208	b0 0b		bcs $011215			bcs 	_FUPNoChange
.01120a	38		sec				sec 								; shift case
.01120b	e9 20 00	sbc #$0020			sbc 	#32
.01120e	e2 20		sep #$20			sep 	#$20 						; write back
.011210	99 00 00	sta $0000,y			sta 	$0000,y
.011213	c2 20		rep #$20			rep 	#$20
.011215					_FUPNoChange:
.011215	ca		dex				dex 								; do X times
.011216	d0 e1		bne $0111f9			bne 	_FUPLoop
.011218					_FUPExit:
.011218	fa		plx				plx 								; restore X
.011219	60		rts				rts
.01121a					Function_LOWER:
.01121a	20 34 06	jsr $010634			jsr 	ResetTypeString 			; returns a string.
.01121d	20 49 03	jsr $010349			jsr 	EvaluateNextString 			; evaluate a string.
.011220	48		pha				pha
.011221	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket 			; close call.
.011224	20 21 07	jsr $010721			jsr		StringTempAllocate 			; allocate memory for it
.011227	68		pla				pla
.011228	20 5f 07	jsr $01075f			jsr 	StringCreateCopy 			; create a copy of it.
.01122b	a5 0a		lda $0a				lda 	DStartTempString 			; A = start of temporary string.
.01122d	95 00		sta $00,x			sta 	EXSValueL+0,x
.01122f	a8		tay				tay 								; address in Y
.011230	74 02		stz $02,x			stz 	EXSValueH+0,x
.011232	da		phx				phx 								; save X
.011233	b2 0a		lda ($0a)			lda 	(DStartTempString)			; get string length
.011235	29 ff 00	and #$00ff			and 	#$00FF
.011238	f0 20		beq $01125a			beq 	_FLOExit
.01123a	aa		tax				tax 								; put in X
.01123b					_FLOLoop:
.01123b	c8		iny				iny 								; increment and load character
.01123c	b9 00 00	lda $0000,y			lda 	$0000,y
.01123f	29 ff 00	and #$00ff			and 	#$00FF
.011242	c9 41 00	cmp #$0041			cmp 	#"A" 						; check range
.011245	90 10		bcc $011257			bcc 	_FLONoChange
.011247	c9 5b 00	cmp #$005b			cmp 	#"Z"+1
.01124a	b0 0b		bcs $011257			bcs 	_FLONoChange
.01124c	18		clc				clc 								; shift case
.01124d	69 20 00	adc #$0020			adc 	#32
.011250	e2 20		sep #$20			sep 	#$20 						; write back
.011252	99 00 00	sta $0000,y			sta 	$0000,y
.011255	c2 20		rep #$20			rep 	#$20
.011257					_FLONoChange:
.011257	ca		dex				dex 								; do X times
.011258	d0 e1		bne $01123b			bne 	_FLOLoop
.01125a					_FLOExit:
.01125a	fa		plx				plx 								; restore X
.01125b	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/let.asm

.01125c					Command_Let:
.01125c	b2 06		lda ($06)			lda 	(DCodePtr)					; get the first token, for typing.
.01125e	48		pha				pha  								; save on stack for later.
.01125f	20 9e 03	jsr $01039e			jsr 	VariableFind 				; find the variable
.011262	85 10		sta $10				sta 	DVariablePtr 				; save where it is.
.011264	b0 0c		bcs $011272			bcs 	_FLetFound 					; skip if found.
.011266	68		pla				pla 								; get and push the first token again.
.011267	48		pha				pha
.011268	29 00 10	and #$1000			and 	#IDArrayMask 				; if it is an array, you can't autoinstantiate it, you have to DIM it.
.01126b	d0 53		bne $0112c0			bne 	_FLError					; arrays, so this causes an error.
.01126d	20 51 04	jsr $010451			jsr 	VariableCreate 				; create it as a single variable.
.011270	85 10		sta $10				sta 	DVariablePtr 				; save the data address.
.011272					_FLetFound:
.011272	68		pla				pla 								; get and save the first token.
.011273	48		pha				pha
.011274	29 00 10	and #$1000			and 	#IDArrayMask				; is it an array ?
.011277	f0 0b		beq $011284			beq 	_FLetNotArray
.011279	a6 1a		ldx $1a				ldx		DStack 						; in LET, so do it from the base stack.
.01127b	e8		inx				inx
.01127c	e8		inx				inx
.01127d	a5 10		lda $10				lda 	DVariablePtr 				; variable pointer into A, first token in A
.01127f	20 15 04	jsr $010415			jsr 	VariableSubscript			; index calculation
.011282	85 10		sta $10				sta 	DVariablePtr 				; and write it back.
.011284					_FLetNotArray:
.011284	7a		ply				ply 								; get the first token into Y
.011285	a5 10		lda $10				lda 	DVariablePtr 				; save the target address on the stack.
.011287	48		pha				pha
.011288	5a		phy				phy 								; save the first token on the stack.
.011289	a9 06 22	lda #$2206			lda 	#equalTokenID 				; check the = and skip it.
.01128c	d2 06		cmp ($06)			cmp 	(DCodePtr)
.01128e	d0 23		bne $0112b3			bne 	_FLetMissingEquals
.011290	e6 06		inc $06				inc 	DCodePtr
.011292	e6 06		inc $06				inc 	DCodePtr
.011294	68		pla				pla 								; restore the first token.
.011295	29 00 20	and #$2000			and 	#IDTypeMask 				; check the type bit
.011298	d0 0f		bne $0112a9			bne 	_FLetString 				; skip if string.
.01129a	20 11 03	jsr $010311			jsr 	EvaluateInteger 			; get an integer
.01129d	7a		ply				ply 								; get address in Y
.01129e	b5 00		lda $00,x			lda 	EXSValueL+0,x				; get the low word.
.0112a0	99 00 00	sta $0000,y			sta 	$0000,y 					; save in variable low.
.0112a3	b5 02		lda $02,x			lda 	EXSValueH+0,x 				; get the high word.
.0112a5	99 02 00	sta $0002,y			sta 	$0002,y 					; save that
.0112a8	60		rts				rts
.0112a9					_FLetString:
.0112a9	20 30 03	jsr $010330			jsr 	EvaluateString 				; get a string.
.0112ac	b5 00		lda $00,x			lda 	EXSValueL+0,x				; get the low word, the address
.0112ae	7a		ply				ply 								; get address we are overwriting in Y - this is the
.0112af	20 7d 06	jsr $01067d			jsr 	StringAssign 				; assign the string in memory.
.0112b2	60		rts				rts
.0112b3					_FLetMissingEquals:
.0112b3	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>0112b6	4d 69 73 73 69 6e 67 20				.text 	"Missing =",$00 								; with this message
>0112be	3d 00
.0112c0					_FLError:
.0112c0	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>0112c3	55 6e 64 65 66 69 6e 65				.text 	"Undefined array",$00 								; with this message
>0112cb	64 20 61 72 72 61 79 00

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/procedure.asm

.0112d3					Command_PROC:
.0112d3	a9 00 02	lda #$0200			lda 	#Block_ProgramStart 		; go to start of program
.0112d6	18		clc				clc
.0112d7	65 02		adc $02				adc 	DBaseAddress
.0112d9	aa		tax				tax 								; X is used to track it
.0112da					_FPROLoop:
.0112da	bd 00 00	lda $0000,x			lda 	@w$0000,x 					; is the link zero
.0112dd	f0 62		beq $011341			beq 	_FPROUnknown
.0112df	bd 04 00	lda $0004,x			lda 	@w$0004,x 					; does it begin with DEFPROC
.0112e2	c9 48 3c	cmp #$3c48			cmp 	#defprocTokenID
.0112e5	f0 08		beq $0112ef			beq 	_FPROFoundDefProc
.0112e7					_FPRONext:
.0112e7	8a		txa				txa 								; follow the link.
.0112e8	18		clc				clc
.0112e9	7d 00 00	adc $0000,x			adc 	@w$0000,x
.0112ec	aa		tax				tax
.0112ed	80 eb		bra $0112da			bra 	_FPROLoop
.0112ef					_FPROFoundDefProc:
.0112ef	bd 06 00	lda $0006,x			lda 	@w$0006,x 					; compare the first tokens.
.0112f2	d2 06		cmp ($06)			cmp 	(DCodePtr)
.0112f4	d0 f1		bne $0112e7			bne 	_FPRONext
.0112f6	8a		txa				txa 								; DTemp1 points to the token.
.0112f7	18		clc				clc
.0112f8	69 06 00	adc #$0006			adc 	#6
.0112fb	85 40		sta $40				sta 	DTemp1
.0112fd	a0 00 00	ldy #$0000			ldy 	#0
.011300					_FPROCompare:
.011300	b1 40		lda ($40),y			lda 	(DTemp1),y
.011302	d1 06		cmp ($06),y			cmp 	(DCodePtr),y
.011304	d0 e1		bne $0112e7			bne 	_FPRONext 					; fails, different
.011306	c8		iny				iny
.011307	c8		iny				iny
.011308	29 00 08	and #$0800			and 	#IDContMask 				; while there's more to test
.01130b	d0 f3		bne $011300			bne 	_FPROCompare
.01130d	98		tya				tya 								; this is the offset to the next element
.01130e	18		clc				clc
.01130f	65 40		adc $40				adc 	DTemp1
.011311	48		pha				pha 								; push the next command on the stack
.011312	da		phx				phx 								; push the record address on the stack.
.011313	a6 1a		ldx $1a				ldx 	DStack 						; point Y to the stack.
.011315	98		tya				tya 								; work out the return address
.011316	18		clc				clc
.011317	65 06		adc $06				adc 	DCodePtr
.011319	95 02		sta $02,x			sta 	$02,x 						; save pos at +2
.01131b	a5 14		lda $14				lda 	DLineNumber 				; save line number at +4
.01131d	95 04		sta $04,x			sta 	$04,x
.01131f	a9 41 3e	lda #$3e41			lda 	#procTokenID 				; save proc token at +6
.011322	95 06		sta $06,x			sta 	$06,x
.011324	8a		txa				txa 								; advance stack by 6.
.011325	18		clc				clc
.011326	69 06 00	adc #$0006			adc 	#6
.011329	85 1a		sta $1a				sta 	DStack
.01132b	7a		ply				ply 								; line record address
.01132c	b9 02 00	lda $0002,y			lda 	$0002,y 					; get line number
.01132f	85 14		sta $14				sta 	DLineNumber
.011331	68		pla				pla 								; next command
.011332	85 06		sta $06				sta 	DCodePtr
.011334	a4 06		ldy $06				ldy 	DCodePtr 					; get the new code address, the address after  DEFPROC x
.011336	88		dey				dey 								; get the previous token
.011337	88		dey				dey
.011338	b9 00 00	lda $0000,y			lda 	$0000,y 					; read the token
.01133b	29 00 10	and #$1000			and 	#IDArrayMask 				; is it a function call - e.g. an array type ?
.01133e	d0 16		bne $011356			bne 	_FPROParameter				; if not, set up the parameters.
.011340	60		rts				rts
.011341					_FPROUnknown:
.011341	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>011344	55 6e 6b 6e 6f 77 6e 20				.text 	"Unknown procedure",$00 								; with this message
>01134c	70 72 6f 63 65 64 75 72 65 00
.011356					_FPROParameter:
.011356	a5 06		lda $06				lda	 	DCodePtr 					; save code pointer
.011358	48		pha				pha
.011359	a5 1a		lda $1a				lda 	DStack 						; get the stack.
.01135b	38		sec				sec
.01135c	e9 04 00	sbc #$0004			sbc 	#4 							; this is the address of that return value
.01135f	48		pha				pha 								; save that on the stack.
.011360	aa		tax				tax
.011361	b5 00		lda $00,x			lda 	$00,x 						; get that return address
.011363	85 06		sta $06				sta 	DCodePtr 					; and set up the code pointer.
.011365	a2 80 00	ldx #$0080			ldx 	#PRMBuffer 					; X points to the parameter buffer.
.011368					_FPROGetValues:
.011368	da		phx				phx 								; save X
.011369	20 01 02	jsr $010201			jsr 	Evaluate 					; Evaluate into YA, type into CS.
.01136c	fa		plx				plx 								; restore X
.01136d	95 00		sta $00,x			sta 	$00,x 						; save value
.01136f	98		tya				tya
.011370	95 10		sta $10,x			sta 	$10,x
.011372	a9 00 00	lda #$0000			lda 	#0 							; get the carry into A, so 0=int,1=string
.011375	2a		rol a				rol 	a
.011376	95 20		sta $20,x			sta 	$20,x 						; write into type slot.
.011378	e8		inx				inx 								; next entry into parameter table.
.011379	e8		inx				inx
.01137a	b2 06		lda ($06)			lda 	(DCodePtr) 					; get next token and skip it
.01137c	e6 06		inc $06				inc 	DCodePtr
.01137e	e6 06		inc $06				inc 	DCodePtr
.011380	c9 24 32	cmp #$3224			cmp 	#commaTokenID 				; if comma, another parameter.
.011383	f0 e3		beq $011368			beq 	_FPROGetValues
.011385	c9 28 32	cmp #$3228			cmp 	#rParenTokenID 				; if not right bracket, then error.
.011388	d0 5c		bne $0113e6			bne 	_FPROSyntax
.01138a	a9 ff ff	lda #$ffff			lda 	#$FFFF 						; store -1 in the next type slot.
.01138d	95 20		sta $20,x			sta 	$20,x 						; marks the end of the parameters.
.01138f	fa		plx				plx 								; address of return address
.011390	a5 06		lda $06				lda 	DCodePtr 					; write return address back.
.011392	95 00		sta $00,x			sta 	$00,x
.011394	68		pla				pla 								; restore old code pointer (the parameter addresses)
.011395	85 06		sta $06				sta 	DCodePtr
.011397					_FPROSetupParameters:
.011397	a2 80 00	ldx #$0080			ldx 	#PRMBuffer 					; start of buffer.
.01139a					_FPROSetupLoop:
.01139a	b5 20		lda $20,x			lda 	$20,x 						; get the type
.01139c	d0 14		bne $0113b2			bne 	_FPROSetupString
.01139e	da		phx				phx 								; localise variable, preserving X.
.01139f	20 2f 14	jsr $01142f			jsr 	LocalProcessVariable
.0113a2	fa		plx				plx
.0113a3	b0 2b		bcs $0113d0			bcs 	_FPROTypeError 				; must be integer variable.
.0113a5	a8		tay				tay  								; target address in Y.
.0113a6	b5 00		lda $00,x			lda 	$00,x 						; copy data
.0113a8	99 00 00	sta $0000,y			sta 	$0000,y
.0113ab	b5 10		lda $10,x			lda 	$10,x
.0113ad	99 02 00	sta $0002,y			sta 	$0002,y
.0113b0	80 0f		bra $0113c1			bra 	_FPRONextParameterValue
.0113b2					_FPROSetupString:
.0113b2	da		phx				phx 								; localise variable, preserving X.
.0113b3	20 2f 14	jsr $01142f			jsr 	LocalProcessVariable
.0113b6	fa		plx				plx
.0113b7	90 17		bcc $0113d0			bcc 	_FPROTypeError 				; must be integer variable.
.0113b9	a8		tay				tay  								; target address in Y.
.0113ba	b5 00		lda $00,x			lda 	$00,x 						; address of new string in A
.0113bc	da		phx				phx 								; preserve X.
.0113bd	20 7d 06	jsr $01067d			jsr 	StringAssign 				; assign the string using the function used by LET.
.0113c0	fa		plx				plx
.0113c1					_FPRONextParameterValue:
.0113c1	e8		inx				inx 								; next parameter in parameter table.
.0113c2	e8		inx				inx
.0113c3	b5 20		lda $20,x			lda 	$20,x 						; type of next
.0113c5	30 05		bmi $0113cc			bmi 	_FPROComplete 				; if -ve then we have assigned everything.
.0113c7	20 03 06	jsr $010603			jsr 	ExpectComma 				; expect a comma
.0113ca	80 ce		bra $01139a			bra 	_FPROSetupLoop 				; and do the next one.
.0113cc					_FPROComplete:
.0113cc	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket 			; the right bracket closing the parameter list
.0113cf	60		rts				rts
.0113d0					_FPROTypeError:
.0113d0	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>0113d3	42 61 64 20 70 61 72 61				.text 	"Bad parameter type",$00 								; with this message
>0113db	6d 65 74 65 72 20 74 79 70 65 00
.0113e6					_FPROSyntax:
.0113e6	82 d6 f1	brl $0105bf			brl 	SyntaxError
.0113e9					Command_ENDPROC:
.0113e9	20 ad 14	jsr $0114ad			jsr 	LocalRestore 				; restore any local variables.
.0113ec	a6 1a		ldx $1a				ldx 	DStack						; what's on the top of the stack.
.0113ee	b5 00		lda $00,x			lda 	$00,x
.0113f0	c9 41 3e	cmp #$3e41			cmp 	#procTokenID 				; check top token.
.0113f3	d0 11		bne $011406			bne 	_FENPFail
.0113f5	8a		txa				txa 								; unpick stack.
.0113f6	38		sec				sec
.0113f7	e9 06 00	sbc #$0006			sbc 	#6
.0113fa	85 1a		sta $1a				sta 	DStack
.0113fc	aa		tax				tax
.0113fd	b5 02		lda $02,x			lda 	$02,x 						; copy code pointer out.
.0113ff	85 06		sta $06				sta 	DCodePtr
.011401	b5 04		lda $04,x			lda 	$04,x 						; copy line number out
.011403	85 14		sta $14				sta 	DLineNumber
.011405	60		rts				rts
.011406					_FENPFail:
.011406	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>011409	45 6e 64 50 72 6f 63 20				.text 	"EndProc without Proc",$00 								; with this message
>011411	77 69 74 68 6f 75 74 20 50 72 6f 63 00

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/local.asm

.01141e					Command_LOCAL:
.01141e	20 2f 14	jsr $01142f			jsr 	LocalProcessVariable 		; make one variable 'local'
.011421	b2 06		lda ($06)			lda 	(DCodePtr) 					; look at next character
.011423	c9 24 32	cmp #$3224			cmp 	#commaTokenID 				; exit if not comma
.011426	d0 06		bne $01142e			bne 	_CLOExit
.011428	e6 06		inc $06				inc 	DCodePtr 					; skip comma and get next variable
.01142a	e6 06		inc $06				inc 	DCodePtr
.01142c	80 f0		bra $01141e			bra 	Command_Local
.01142e					_CLOExit:
.01142e	60		rts				rts
.01142f					LocalProcessVariable:
.01142f	b2 06		lda ($06)			lda 	(DCodePtr)					; check it is an identifier and not an array
.011431	c9 00 c0	cmp #$c000			cmp 	#$C000
.011434	90 5f		bcc $011495			bcc 	_LPVFail
.011436	29 00 10	and #$1000			and 	#IDArrayMask
.011439	d0 5a		bne $011495			bne 	_LPVFail
.01143b	b2 06		lda ($06)			lda 	(DCodePtr) 					; get type
.01143d	48		pha				pha 								; save on stack.
.01143e	20 9e 03	jsr $01039e			jsr 	VariableFind 				; find a variable
.011441	b0 03		bcs $011446			bcs 	_LPVFound
.011443	20 51 04	jsr $010451			jsr 	VariableCreate 				; create it if it doesn't exist.
.011446					_LPVFound:
.011446	a8		tay				tay 								; variable address in Y
.011447	68		pla				pla 								; get the type back
.011448	29 00 20	and #$2000			and 	#IDTypeMask 				; identify it
.01144b	d0 1e		bne $01146b			bne 	_LPVStringPush 				; if string, push that on the stack.
.01144d	a6 1a		ldx $1a				ldx 	DStack
.01144f	b9 00 00	lda $0000,y			lda 	$0000,y 					; get LSW and write
.011452	95 02		sta $02,x			sta 	$02,x
.011454	b9 02 00	lda $0002,y			lda 	$0002,y 					; get MSW and write
.011457	95 04		sta $04,x			sta 	$04,x
.011459	98		tya				tya 								; write address.
.01145a	95 06		sta $06,x			sta 	$06,x
.01145c	a9 00 c0	lda #$c000			lda 	#$C000 						; write $C000 marker.
.01145f	95 08		sta $08,x			sta 	$08,x
.011461	8a		txa				txa 								; shift to top of stack.
.011462	18		clc				clc
.011463	69 08 00	adc #$0008			adc 	#8
.011466	85 1a		sta $1a				sta 	DStack
.011468	98		tya				tya 								; return address of variable data.
.011469	18		clc				clc
.01146a	60		rts				rts
.01146b					_LPVStringPush:
.01146b	b9 00 00	lda $0000,y			lda 	$0000,y 					; if uninitialised then leave it like that.
.01146e	f0 22		beq $011492			beq		_LPVExit
.011470	5a		phy				phy 								; save storage address on stack.
.011471	85 40		sta $40				sta 	DTemp1 						; address of physical string.
.011473	a6 1a		ldx $1a				ldx 	DStack 						; get stack.
.011475	e8		inx				inx 								; point to free stack byte.
.011476	e8		inx				inx
.011477	b2 40		lda ($40)			lda 	(DTemp1) 					; get length of string.
.011479	29 ff 00	and #$00ff			and 	#$00FF
.01147c	a8		tay				tay 								; copy backwards
.01147d					_LPVPushOut:
.01147d	b1 40		lda ($40),y			lda 	(DTemp1),y 					; copy byte at a time. just do words :)
.01147f	95 00		sta $00,x			sta 	$00,x
.011481	e8		inx				inx
.011482	88		dey				dey
.011483	10 f8		bpl $01147d			bpl 	_LPVPushOut 				; push one extra because of length byte.
.011485	68		pla				pla 								; write out the address of the storage.
.011486	a8		tay				tay 								; save it in Y
.011487	95 00		sta $00,x			sta 	$00,x 						; (e.g. this address has the physical string address)
.011489	a9 00 e0	lda #$e000			lda 	#$E000 						; write $E000 out.
.01148c	95 02		sta $02,x			sta 	$02,x
.01148e	e8		inx				inx
.01148f	e8		inx				inx
.011490	86 1a		stx $1a				stx 	DStack 						; save $E000 marker
.011492					_LPVExit:
.011492	98		tya				tya  								; return address of marker.
.011493	38		sec				sec
.011494	60		rts				rts
.011495					_LPVFail:
.011495	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>011498	42 61 64 20 4c 6f 63 61				.text 	"Bad Local Identifier",$00 								; with this message
>0114a0	6c 20 49 64 65 6e 74 69 66 69 65 72 00
.0114ad					LocalRestore:
.0114ad	a6 1a		ldx $1a				ldx 	DStack 						; access basic stack.
.0114af	b5 00		lda $00,x			lda 	$00,x 						; read top word.
.0114b1	c9 00 c0	cmp #$c000			cmp 	#$C000 						; $C000-$FFFF indicates stacked local/parameter
.0114b4	f0 03		beq $0114b9			beq 	_LRIntegerPull 				; $C000 unstack integer
.0114b6	b0 18		bcs $0114d0			bcs 	_LRString 					; $C001-$FFFF unstack string
.0114b8	60		rts				rts
.0114b9					_LRIntegerPull:
.0114b9	8a		txa				txa 								; pull 8 bytes off stack.
.0114ba	38		sec				sec
.0114bb	e9 08 00	sbc #$0008			sbc 	#8
.0114be	85 1a		sta $1a				sta 	DStack
.0114c0	aa		tax				tax 								; put in X
.0114c1	b5 06		lda $06,x			lda 	$06,x 						; get address to restore
.0114c3	a8		tay				tay
.0114c4	b5 02		lda $02,x			lda 	$02,x 						; restore MSW
.0114c6	99 00 00	sta $0000,y			sta 	@w$0000,y
.0114c9	b5 04		lda $04,x			lda 	$04,x 						; and LSW
.0114cb	99 02 00	sta $0002,y			sta 	@w$0002,y
.0114ce	80 dd		bra $0114ad			bra 	LocalRestore 				; and try again.
.0114d0					_LRString:
.0114d0	ca		dex				dex									; access the address
.0114d1	ca		dex				dex
.0114d2	b5 00		lda $00,x			lda 	$00,x 						; the address of the storage address
.0114d4	a8		tay				tay
.0114d5	b9 00 00	lda $0000,y			lda 	$0000,y 					; the actual storage address
.0114d8	85 40		sta $40				sta 	DTemp1 						; save so we can write to it.
.0114da	ca		dex				dex 								; length is the next byte.
.0114db	b5 00		lda $00,x			lda 	$00,x 						; so get the length
.0114dd	29 ff 00	and #$00ff			and 	#$00FF 						; mask it off
.0114e0	a8		tay				tay 								; count in Y
.0114e1					_LRRecover:
.0114e1	b5 00		lda $00,x			lda 	$00,x 						; extract and write bytes
.0114e3	e2 20		sep #$20			sep 	#$20
.0114e5	92 40		sta ($40)			sta 	(DTemp1)
.0114e7	c2 20		rep #$20			rep 	#$20
.0114e9	ca		dex				dex 								; stack backwards
.0114ea	e6 40		inc $40				inc 	DTemp1 						; pointer forwards
.0114ec	88		dey				dey 								; do Y+1 times.
.0114ed	10 f2		bpl $0114e1			bpl 	_LRRecover
.0114ef	ca		dex				dex 								; stack should now point to next token
.0114f0	86 1a		stx $1a				stx 	DStack
.0114f2	80 b9		bra $0114ad			bra 	LocalRestore 				; and try again.

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/list.asm

.0114f4					Command_List:
.0114f4	a9 ff 00	lda #$00ff		lda 	#255 							; create a buffer to use.
.0114f7	20 21 07	jsr $010721		jsr 	StringTempAllocate
.0114fa	85 20		sta $20			sta 	DListBuffer						; save buffer.
.0114fc	64 1c		stz $1c			stz 	DIndent 						; reset the indents
.0114fe	64 1e		stz $1e			stz 	DIndent2
.011500	64 4c		stz $4c			stz 	DTemp4+0 						; low number
.011502	a9 ff 7f	lda #$7fff		lda 	#$7FFF
.011505	85 4e		sta $4e			sta 	DTemp4+2 						; high number.
.011507	b2 06		lda ($06)		lda 	(DCodePtr)						; anything else ?
.011509	f0 3b		beq $011546		beq 	_CLIList
.01150b	c9 26 32	cmp #$3226		cmp 	#colonTokenID
.01150e	f0 36		beq $011546		beq 	_CLIList
.011510	c9 24 32	cmp #$3224		cmp 	#commaTokenID 					; is it , something.
.011513	f0 13		beq $011528		beq 	_CLIComma
.011515	20 2a 03	jsr $01032a		jsr 	EvaluateNextInteger 			; yes, first number
.011518	c0 00 00	cpy #$0000		cpy 	#0
.01151b	d0 21		bne $01153e		bne 	_CLIError
.01151d	85 4c		sta $4c			sta 	DTemp4+0 						; which becomes the first and the last :)
.01151f	85 4e		sta $4e			sta 	DTemp4+2
.011521	b2 06		lda ($06)		lda 	(DCodePtr) 						; , follows ?
.011523	c9 24 32	cmp #$3224		cmp 	#commaTokenID
.011526	d0 1e		bne $011546		bne 	_CLIList
.011528					_CLIComma:
.011528	20 03 06	jsr $010603		jsr 	ExpectComma 					; skip comma
.01152b	b2 06		lda ($06)		lda 	(DCodePtr)
.01152d	f0 12		beq $011541		beq 	_CLIToEnd 						; if $0000 or :, then list to end.
.01152f	c9 26 32	cmp #$3226		cmp 	#colonTokenID
.011532	f0 0d		beq $011541		beq 	_CLIToEnd
.011534	20 2a 03	jsr $01032a		jsr 	EvaluateNextInteger 			; get end line.
.011537	85 4e		sta $4e			sta 	DTemp4+2
.011539	c0 00 00	cpy #$0000		cpy 	#0 								; if legal continue.
.01153c	f0 08		beq $011546		beq 	_CLIList
.01153e					_CLIError:
.01153e	82 7e f0	brl $0105bf		brl 	SyntaxError
.011541					_CLIToEnd:
.011541	a9 ff 7f	lda #$7fff		lda 	#$7FFF
.011544	85 4e		sta $4e			sta 	DTemp4+2
.011546					_CLIList:
.011546	a9 00 02	lda #$0200		lda 	#Block_ProgramStart 			; work out program start.
.011549	18		clc			clc
.01154a	65 02		adc $02			adc 	DBaseAddress
.01154c	a8		tay			tay 									; put in Y
.01154d					_CLINextLine:
.01154d	b9 00 00	lda $0000,y		lda 	$0000,y 						; check end of program
.011550	f0 29		beq $01157b		beq 	_CLIExit
.011552	20 e3 16	jsr $0116e3		jsr 	ScanIndent  					; scan for formatting.
.011555	b9 02 00	lda $0002,y		lda 	$0002,y 						; get line number.
.011558	c5 4c		cmp $4c			cmp 	DTemp4+0 						; check if it is in range.
.01155a	90 14		bcc $011570		bcc 	_CLIFollowLink
.01155c	c5 4e		cmp $4e			cmp 	DTemp4+2
.01155e	f0 02		beq $011562		beq 	_CLIShowLine
.011560	b0 0e		bcs $011570		bcs 	_CLIFollowLink
.011562					_CLIShowLine:
.011562	a5 20		lda $20			lda 	DListBuffer
.011564	20 7e 15	jsr $01157e		jsr 	Detokenise 						; detokenise it
.011567	5a		phy			phy
.011568	a8		tay			tay 									; print buffer out
.011569	20 5a 06	jsr $01065a		jsr 	PrintBasicString
.01156c	20 74 1e	jsr $011e74		jsr 	HWNewLine
.01156f	7a		ply			ply 									; get address
.011570					_CLIFollowLink:
.011570	98		tya			tya 									; follow link
.011571	18		clc			clc
.011572	79 00 00	adc $0000,y		adc 	$0000,y
.011575	a8		tay			tay
.011576	20 90 1e	jsr $011e90		jsr 	HWCheckBreak 					; break key pressed.
.011579	f0 d2		beq $01154d		beq 	_CLINextLine
.01157b					_CLIExit:
.01157b	64 1c		stz $1c			stz 	DIndent 						; reset the indent
.01157d	60		rts			rts
.01157e					Detokenise:
.01157e	48		pha			pha
.01157f	da		phx			phx
.011580	5a		phy			phy
.011581	85 0a		sta $0a			sta 	DStartTempString 				; set the temp Command pointers to this buffer
.011583	1a		inc a			inc 	a
.011584	85 0c		sta $0c			sta 	DCurrentTempString
.011586	64 0e		stz $0e			stz		DConstantShift
.011588	a9 00 00	lda #$0000		lda 	#$0000 							; write zero, clearing the string size.
.01158b	92 0a		sta ($0a)		sta 	(DStartTempString)
.01158d	5a		phy			phy 									; save Y
.01158e	b9 02 00	lda $0002,y		lda 	$0002,y 						; read the line number.
.011591	a0 00 00	ldy #$0000		ldy 	#$0000 							; the high byte is 0
.011594	a2 0a 00	ldx #$000a		ldx 	#10 							; in BASE 10.
.011597	20 d4 10	jsr $0110d4		jsr 	ConvertToStringAlreadyAllocated	; convert to string in situ.
.01159a	a5 1c		lda $1c			lda 	DIndent 						; work out indent, which is the smaller of this/last
.01159c	c5 1e		cmp $1e			cmp 	DIndent2
.01159e	90 02		bcc $0115a2		bcc 	_DTKSmaller
.0115a0	a5 1e		lda $1e			lda 	DIndent2
.0115a2					_DTKSmaller:
.0115a2	0a		asl a			asl 	a
.0115a3	69 06 00	adc #$0006		adc 	#6
.0115a6	85 40		sta $40			sta 	DTemp1
.0115a8					_DTKPadLineNo:
.0115a8	a9 20 00	lda #$0020		lda 	#32 							; pad out to 6+indent*2 characters.
.0115ab	20 51 07	jsr $010751		jsr 	StringWriteCharacter
.0115ae	b2 0a		lda ($0a)		lda 	(DStartTempString)
.0115b0	29 ff 00	and #$00ff		and 	#$00FF
.0115b3	c5 40		cmp $40			cmp 	DTemp1
.0115b5	d0 f1		bne $0115a8		bne 	_DTKPadLineNo
.0115b7	68		pla			pla 									; get pointer
.0115b8	18		clc			clc 									; point to start of line
.0115b9	69 04 00	adc #$0004		adc 	#4
.0115bc	a8		tay			tay 									; put back in Y.
.0115bd					_DTKMainLoop:
.0115bd	b9 00 00	lda $0000,y		lda 	$0000,y 						; look at first token.
.0115c0	d0 04		bne $0115c6		bne 	_DTKNotZero 					; if zero, return.
.0115c2	7a		ply			ply
.0115c3	fa		plx			plx
.0115c4	68		pla			pla
.0115c5	60		rts			rts
.0115c6					_DTKNotZero:
.0115c6	c9 00 01	cmp #$0100		cmp 	#$0100 							; is it a quoted string $0000-$00FF
.0115c9	b0 1c		bcs $0115e7		bcs 	_DTKNotString
.0115cb	5a		phy			phy										; save token address on stack.
.0115cc	c8		iny			iny 									; skip first token
.0115cd	c8		iny			iny
.0115ce	a9 22 00	lda #$0022		lda 	#34 							; write out opening quote
.0115d1	20 51 07	jsr $010751		jsr 	StringWriteCharacter
.0115d4	98		tya			tya 									; copy the string out.
.0115d5	20 5f 07	jsr $01075f		jsr 	StringCreateCopy
.0115d8	a9 22 00	lda #$0022		lda 	#34 							; write out closing quote
.0115db	20 51 07	jsr $010751		jsr 	StringWriteCharacter
.0115de	68		pla			pla 									; get token, which is its own offset
.0115df	a8		tay			tay
.0115e0	18		clc			clc
.0115e1	79 00 00	adc $0000,y		adc 	$0000,y
.0115e4	a8		tay			tay
.0115e5	80 d6		bra $0115bd		bra 	_DTKMainLoop
.0115e7					_DTKNotString:
.0115e7	c9 00 20	cmp #$2000		cmp 	#$2000							; if $1000-$1FFF then constant shift
.0115ea	b0 09		bcs $0115f5		bcs 	_DTKNotShift
.0115ec	29 ff 0f	and #$0fff		and 	#$0FFF 							; store in shift
.0115ef	85 0e		sta $0e			sta 	DConstantShift
.0115f1	c8		iny			iny 									; skip token.
.0115f2	c8		iny			iny
.0115f3	80 c8		bra $0115bd		bra 	_DTKMainLoop
.0115f5					_DTKNotShift:
.0115f5	c9 00 40	cmp #$4000		cmp 	#$4000 							; if $2000-$3FFF it's a token.
.0115f8	b0 07		bcs $011601		bcs 	_DTKNotKeyword
.0115fa	c8		iny			iny 									; skip over token
.0115fb	c8		iny			iny
.0115fc	20 7b 16	jsr $01167b		jsr 	_DTKDecodeKeyword 				; decode it.
.0115ff	80 bc		bra $0115bd		bra 	_DTKMainLoop
.011601					_DTKNotKeyword:
.011601	c9 00 c0	cmp #$c000		cmp 	#$C000							; if $4000-$BFFF it's a (possibly shifted) constant.
.011604	b0 18		bcs $01161e		bcs 	_DTKIdentifier 					; if $C000-$CFFF it's an identifier.
.011606	5a		phy			phy 									; save pointer
.011607	38		sec			sec  									; shift it in the range 0-32767
.011608	e9 00 40	sbc #$4000		sbc 	#$4000
.01160b	0a		asl a			asl 	a 								; shift it left, losing bit 15
.01160c	46 0e		lsr $0e			lsr 	DConstantShift 					; shift constant right into carry.
.01160e	6a		ror a			ror 	a 								; rotate that into the constant value
.01160f	a4 0e		ldy $0e			ldy 	DConstantShift 					; YA number
.011611	a2 0a 00	ldx #$000a		ldx 	#10 							; output base.
.011614	20 d4 10	jsr $0110d4		jsr 	ConvertToStringAlreadyAllocated	; convert to string in situ.
.011617	64 0e		stz $0e			stz 	DConstantShift
.011619	7a		ply			ply 									; restore pointer
.01161a	c8		iny			iny 									; skip token.
.01161b	c8		iny			iny
.01161c	80 9f		bra $0115bd		bra 	_DTKMainLoop
.01161e					_DTKIdentifier:
.01161e	48		pha			pha 									; save token for typing at end
.01161f					_DTKILoop:
.01161f	b9 00 00	lda $0000,y		lda 	$0000,y 						; get token
.011622	20 4b 16	jsr $01164b		jsr 	_DTKIDecodeToken 				; decode it.
.011625	b9 00 00	lda $0000,y		lda 	$0000,y 						; get the token again
.011628	c8		iny			iny 									; skip it
.011629	c8		iny			iny
.01162a	29 00 08	and #$0800		and 	#IDContMask 					; continuation ?
.01162d	d0 f0		bne $01161f		bne 	_DTKILoop
.01162f	68		pla			pla 									; add $( as required.
.011630	48		pha			pha 									; comes from the first token.
.011631	29 00 20	and #$2000		and 	#IDTypeMask
.011634	f0 06		beq $01163c		beq 	_DTKINotString
.011636	a9 24 00	lda #$0024		lda 	#"$"
.011639	20 51 07	jsr $010751		jsr 	StringWriteCharacter
.01163c					_DTKINotString:
.01163c	68		pla			pla
.01163d	29 00 10	and #$1000		and 	#IDArrayMask
.011640	f0 06		beq $011648		beq 	_DTKINotArray
.011642	a9 28 00	lda #$0028		lda 	#"("
.011645	20 51 07	jsr $010751		jsr 	StringWriteCharacter
.011648					_DTKINotArray:
.011648	82 72 ff	brl $0115bd		brl 	_DTKMainLoop
.01164b					_DTKIDecodeToken:
.01164b	5a		phy			phy
.01164c	29 ff 07	and #$07ff		and		#$07FF 							; mask off the identifier bit.
.01164f	a0 ff ff	ldy #$ffff		ldy 	#-1 							; first, divide by 45 getting remainder.
.011652					_DTKIDivide:
.011652	38		sec			sec
.011653	e9 2d 00	sbc #$002d		sbc 	#45
.011656	c8		iny			iny
.011657	b0 f9		bcs $011652		bcs 	_DTKIDivide
.011659	69 2d 00	adc #$002d		adc 	#45
.01165c	20 65 16	jsr $011665		jsr 	_DTKIOutA 						; output low.
.01165f	98		tya			tya
.011660	20 65 16	jsr $011665		jsr 	_DTKIOutA 						; output high
.011663	7a		ply			ply
.011664	60		rts			rts
.011665					_DTKIOutA:
.011665	09 00 00	ora #$0000		ora 	#$0000 							; exit if 0
.011668	f0 10		beq $01167a		beq 	_DTKIOutExit
.01166a	c9 1b 00	cmp #$001b		cmp 	#27 							; skip if A-Z
.01166d	90 04		bcc $011673		bcc 	_DTKIOutAlpha
.01166f	38		sec			sec  									; adjust for 0-9
.011670	e9 4b 00	sbc #$004b		sbc 	#$4B
.011673					_DTKIOutAlpha:
.011673	18		clc			clc										; adjust for A-Z
.011674	69 60 00	adc #$0060		adc 	#96
.011677	20 51 07	jsr $010751		jsr 	StringWriteCharacter
.01167a					_DTKIOutExit:
.01167a	60		rts			rts
.01167b					_DTKDecodeKeyword:
.01167b	48		pha			pha
.01167c	da		phx			phx
.01167d	5a		phy			phy
.01167e	a8		tay			tay 									; save token ID in Y
.01167f	29 00 18	and #$1800		and 	#$1800 							; is it a keyword
.011682	49 00 18	eor #$1800		eor 	#$1800 							; now zero if it is.
.011685	48		pha			pha 									; save this flag on a stack
.011686	5a		phy			phy 									; save the token ID
.011687	c9 00 00	cmp #$0000		cmp 	#0 								; check if spacing perhaps required.
.01168a	d0 19		bne $0116a5		bne 	_DTKNotSpecial1
.01168c	a4 0c		ldy $0c			ldy 	DCurrentTempString 				; what was the last character out ?
.01168e	88		dey			dey
.01168f	b9 00 00	lda $0000,y		lda 	$0000,y
.011692	29 ff 00	and #$00ff		and 	#$00FF
.011695	c9 20 00	cmp #$0020		cmp 	#" " 							; if space or colon, not needed/
.011698	f0 0b		beq $0116a5		beq 	_DTKNotSpecial1
.01169a	c9 3a 00	cmp #$003a		cmp 	#":"
.01169d	f0 06		beq $0116a5		beq 	_DTKNotSpecial1
.01169f	a9 20 00	lda #$0020		lda 	#" "							; output space otherwise.
.0116a2	20 51 07	jsr $010751		jsr 	StringWriteCharacter
.0116a5					_DTKNotSpecial1:
.0116a5	68		pla			pla
.0116a6	29 ff 01	and #$01ff		and 	#$01FF 							; this is the keyword number.
.0116a9	a8		tay			tay 									; into Y.
.0116aa	a2 00 00	ldx #$0000		ldx 	#0 								; offset into the ROM table, token text
.0116ad					_DTKDWorkThrough:
.0116ad	88		dey			dey 									; reached the token (tokens start at 1 in text table)
.0116ae	f0 0f		beq $0116bf		beq 	_DTKDFound
.0116b0	86 40		stx $40			stx 	DTemp1
.0116b2	bf 9e 00 01	lda $01009e,x		lda 	TokenText,x 					; read the type/skip byte.
.0116b6	29 0f 00	and #$000f		and 	#$000F 							; bytes to skip
.0116b9	18		clc			clc
.0116ba	65 40		adc $40			adc 	DTemp1
.0116bc	aa		tax			tax
.0116bd	80 ee		bra $0116ad		bra 	_DTKDWorkThrough
.0116bf					_DTKDFound:
.0116bf	bf 9e 00 01	lda $01009e,x		lda 	TokenText,x 					; get skip
.0116c3	29 0f 00	and #$000f		and 	#$000F 					 		; length is skip -1
.0116c6	3a		dec a			dec 	a
.0116c7	a8		tay			tay 									; put in Y
.0116c8					_DTKOut:
.0116c8	bf 9f 00 01	lda $01009f,x		lda 	TokenText+1,x 					; output it.
.0116cc	29 ff 00	and #$00ff		and 	#$00FF
.0116cf					_DTKNotLC:
.0116cf	20 51 07	jsr $010751		jsr 	StringWriteCharacter
.0116d2	e8		inx			inx
.0116d3	88		dey			dey
.0116d4	d0 f2		bne $0116c8		bne 	_DTKOut
.0116d6	68		pla			pla 									; trailing space.
.0116d7	d0 06		bne $0116df		bne 	_DTKNotSpecial2
.0116d9	a9 20 00	lda #$0020		lda 	#" "
.0116dc	20 51 07	jsr $010751		jsr 	StringWriteCharacter
.0116df					_DTKNotSpecial2:
.0116df	7a		ply			ply
.0116e0	fa		plx			plx
.0116e1	68		pla			pla
.0116e2	60		rts			rts
.0116e3					ScanIndent:
.0116e3	48		pha			pha
.0116e4	5a		phy			phy
.0116e5	a5 1c		lda $1c			lda 	DIndent  						; save the old indentation
.0116e7	85 1e		sta $1e			sta 	DIndent2
.0116e9	98		tya			tya
.0116ea	18		clc			clc 									; point to code.
.0116eb	69 04 00	adc #$0004		adc 	#4
.0116ee	a8		tay			tay
.0116ef					_SILoop:
.0116ef	b9 00 00	lda $0000,y		lda 	$0000,y 						; get token
.0116f2	f0 35		beq $011729		beq 	_SIExit
.0116f4	c9 00 01	cmp #$0100		cmp 	#$0100							; is it a string ?
.0116f7	b0 08		bcs $011701		bcs 	_SICheckKeyword
.0116f9	98		tya			tya 									; skip string.
.0116fa	18		clc			clc
.0116fb	79 00 00	adc $0000,y		adc 	$0000,y
.0116fe	a8		tay			tay
.0116ff	80 ee		bra $0116ef		bra 	_SILoop
.011701					_SICheckKeyword:
.011701	29 00 e0	and #$e000		and 	#$E000
.011704	c9 00 20	cmp #$2000		cmp 	#$2000
.011707	f0 04		beq $01170d		beq 	_SIFoundKeyword
.011709					_SIAdvance:
.011709	c8		iny			iny 									; if not, loop round.
.01170a	c8		iny			iny
.01170b	80 e2		bra $0116ef		bra 	_SILoop
.01170d					_SIFoundKeyword:
.01170d	b9 00 00	lda $0000,y		lda 	$0000,y 						; get keyword
.011710	29 00 1e	and #$1e00		and 	#15<<9							; extract type
.011713	c9 00 1c	cmp #$1c00		cmp 	#14<<9
.011716	f0 0d		beq $011725		beq 	_SIKeyPlus
.011718	c9 00 1a	cmp #$1a00		cmp 	#13<<9 							; and adjust DIndent appropriately.
.01171b	d0 ec		bne $011709		bne 	_SIAdvance
.01171d	c6 1c		dec $1c			dec 	DIndent
.01171f	10 e8		bpl $011709		bpl 	_SIAdvance
.011721	64 1c		stz $1c			stz 	DIndent
.011723	80 e4		bra $011709		bra 	_SIAdvance
.011725					_SIKeyPlus:
.011725	e6 1c		inc $1c			inc 	DIndent
.011727	80 e0		bra $011709		bra 	_SIAdvance
.011729					_SIExit:
.011729	7a		ply			ply
.01172a	68		pla			pla
.01172b	60		rts			rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/print.asm

.01172c					Command_PRINT:
.01172c	b2 06		lda ($06)			lda 	(DCodePtr) 					; look at first characteer
.01172e	f0 33		beq $011763			beq 	_FPRExitCR 					; if zero, then exit with CR, maybe.
.011730	c9 26 32	cmp #$3226			cmp 	#colonTokenID 				; likewise if a colon.
.011733	f0 2e		beq $011763			beq 	_FPRExitCR
.011735	c9 25 32	cmp #$3225			cmp 	#semicolonTokenID 			; semicolon, skip it
.011738	f0 23		beq $01175d			beq 	_FPRSkipLoop
.01173a	c9 29 32	cmp #$3229			cmp 	#squoteTokenID 				; single quote is CR
.01173d	f0 1b		beq $01175a			beq 	_FPRNewLine
.01173f	c9 24 32	cmp #$3224			cmp 	#commaTokenID 				; , is tab.
.011742	f0 11		beq $011755			beq 	_FPRTab
.011744					_FPRExpression:
.011744	20 01 02	jsr $010201			jsr 	Evaluate 					; evaluate a string or integer.
.011747	b0 06		bcs $01174f			bcs 	_FPRHaveString
.011749	a2 0a 00	ldx #$000a			ldx 	#10 						; convert to string
.01174c	20 cc 10	jsr $0110cc			jsr 	ConvertToString
.01174f					_FPRHaveString:
.01174f	a8		tay				tay 								; print the basic String.
.011750	20 5a 06	jsr $01065a			jsr 	PrintBASICString
.011753	80 d7		bra $01172c			bra 	Command_Print 				; and go round again.
.011755					_FPRTab:
.011755	20 89 1e	jsr $011e89			jsr 	HWTab
.011758	80 03		bra $01175d			bra 	_FPRSkipLoop
.01175a					_FPRNewLine:
.01175a	20 74 1e	jsr $011e74			jsr 	HWNewLine
.01175d					_FPRSkipLoop:
.01175d	e6 06		inc $06				inc 	DCodePtr
.01175f	e6 06		inc $06				inc 	DCodePtr
.011761	80 c9		bra $01172c			bra 	Command_Print
.011763					_FPRExitCR:
.011763	a4 06		ldy $06				ldy 	DCodePtr 					; was the previous token a ; or ,
.011765	88		dey				dey
.011766	88		dey				dey
.011767	b9 00 00	lda $0000,y			lda 	$0000,y
.01176a	c9 24 32	cmp #$3224			cmp 	#commaTokenID 	 			; if so, don't do a new line at the end of the instruction.
.01176d	f0 08		beq $011777			beq 	_FPRExit
.01176f	c9 25 32	cmp #$3225			cmp 	#semicolonTokenID
.011772	f0 03		beq $011777			beq 	_FPRExit
.011774	20 74 1e	jsr $011e74			jsr 	HWNewLine 					; print a new line.
.011777					_FPRExit:
.011777	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/if.asm

.011778					Command_IF:
.011778	20 11 03	jsr $010311			jsr 	EvaluateInteger 			; check success.
.01177b	84 40		sty $40				sty 	DTemp1 						; work out if non-zero
.01177d	05 40		ora $40				ora 	DTemp1
.01177f	a8		tay				tay 								; success flag in Y.
.011780	b2 06		lda ($06)			lda 	(DCodePtr) 					; does THEN follow
.011782	c9 4b 3a	cmp #$3a4b			cmp 	#thenTokenID
.011785	d0 32		bne $0117b9			bne 	_FIFExtended 				; if so, go to the extended IF.
.011787	e6 06		inc $06				inc 	DCodePtr 					; skip over THEN token.
.011789	e6 06		inc $06				inc 	DCodePtr
.01178b	c0 00 00	cpy #$0000			cpy 	#0 							; was it successful.
.01178e	f0 0f		beq $01179f			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.011790	b2 06		lda ($06)			lda 	(DCodePtr) 					; look to see if there is a number there.
.011792	c9 00 40	cmp #$4000			cmp 	#$4000 						; is it a numeric constant.
.011795	90 21		bcc $0117b8			bcc 	_FIFContinue 				; if not, just carry on exiting.
.011797	c9 00 c0	cmp #$c000			cmp 	#$C000
.01179a	b0 1c		bcs $0117b8			bcs 	_FIFContinue
.01179c	4c 1c 1a	jmp $011a1c			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.01179f					_FIFEndOfLine:
.01179f	b2 06		lda ($06)			lda 	(DCodePtr) 					; reached the end of the line.
.0117a1	f0 15		beq $0117b8			beq 	_FIFContinue 				; if done so, continue.
.0117a3	c9 00 01	cmp #$0100			cmp 	#$0100	 					; string constant ?
.0117a6	90 06		bcc $0117ae			bcc 	_FIFStringConstant
.0117a8	e6 06		inc $06				inc 	DCodePtr 					; if not, just skip the token
.0117aa	e6 06		inc $06				inc 	DCodePtr
.0117ac	80 f1		bra $01179f			bra 	_FIFEndOfLine
.0117ae					_FIFStringConstant:
.0117ae	29 ff 00	and #$00ff			and 	#$00FF 						; add to CodePtr to skip string.
.0117b1	18		clc				clc
.0117b2	65 06		adc $06				adc 	DCodePtr
.0117b4	85 06		sta $06				sta 	DCodePtr
.0117b6	80 e7		bra $01179f			bra 	_FIFEndOfLine
.0117b8					_FIFContinue:
.0117b8	60		rts				rts
.0117b9					_FIFExtended:
.0117b9	e6 1a		inc $1a				inc 	DStack 						; put IF on the top of the stack
.0117bb	e6 1a		inc $1a				inc 	DStack
.0117bd	a9 46 3c	lda #$3c46			lda 	#ifTokenID
.0117c0	a6 1a		ldx $1a				ldx 	DStack
.0117c2	95 00		sta $00,x			sta 	$00,x
.0117c4	98		tya				tya 								; see if the test was passed.
.0117c5	f0 01		beq $0117c8			beq 	_FIXSkip 					; if zero then it has failed.
.0117c7	60		rts				rts 								; test passed, so continue executing
.0117c8					_FIXSkip:
.0117c8	a9 3a 3e	lda #$3e3a			lda 	#elseTokenID 				; scan forward till found either ELSE or ENDIF
.0117cb	a2 4c 3a	ldx #$3a4c			ldx 	#endifTokenID 				; at the same level.
.0117ce	20 2e 18	jsr $01182e			jsr 	ScanForwardLevel 			; scan forward, returns what found in A.
.0117d1	e6 06		inc $06				inc 	DCodePtr 					; skip over the ELSE or ENDIF
.0117d3	e6 06		inc $06				inc 	DCodePtr
.0117d5	c9 4c 3a	cmp #$3a4c			cmp 	#endifTokenID 				; if ENDIF token ID, then throw the TOS as ended
.0117d8	d0 04		bne $0117de			bne 	_FIXNoThrow
.0117da	c6 1a		dec $1a				dec 	DStack 						; throw the token IF on the stack top.
.0117dc	c6 1a		dec $1a				dec 	DStack
.0117de					_FIXNoThrow:
.0117de	60		rts				rts
.0117df					Handler_ELSE:
.0117df	a6 1a		ldx $1a				ldx 	DStack	 					; check the top of stack is IF.
.0117e1	b5 00		lda $00,x			lda 	$00,x
.0117e3	c9 46 3c	cmp #$3c46			cmp 	#ifTokenID
.0117e6	d0 12		bne $0117fa			bne 	_HEBadStructure
.0117e8	a9 4c 3a	lda #$3a4c			lda 	#endifTokenID 				; only searching one token.
.0117eb	a2 00 00	ldx #$0000			ldx 	#$0000
.0117ee	20 2e 18	jsr $01182e			jsr 	ScanForwardLevel 			; so this will find the ENDIF
.0117f1	e6 06		inc $06				inc 	DCodePtr 					; skip over the ENDIF
.0117f3	e6 06		inc $06				inc 	DCodePtr
.0117f5	c6 1a		dec $1a				dec 	DStack 						; throw the token IF on the stack top.
.0117f7	c6 1a		dec $1a				dec 	DStack
.0117f9	60		rts				rts
.0117fa					_HEBadStructure:
.0117fa	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>0117fd	45 6c 73 65 20 77 69 74				.text 	"Else without If",$00 								; with this message
>011805	68 6f 75 74 20 49 66 00
.01180d					Handler_ENDIF:
.01180d	a6 1a		ldx $1a				ldx 	DStack	 					; check the top of stack is IF.
.01180f	b5 00		lda $00,x			lda 	$00,x
.011811	c9 46 3c	cmp #$3c46			cmp 	#ifTokenID
.011814	d0 05		bne $01181b			bne 	_HEIBadStructure
.011816	c6 1a		dec $1a				dec 	DStack 						; throw the token IF on the stack top.
.011818	c6 1a		dec $1a				dec 	DStack
.01181a	60		rts				rts
.01181b					_HEIBadStructure:
.01181b	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>01181e	45 6c 73 65 20 77 69 74				.text 	"Else without If",$00 								; with this message
>011826	68 6f 75 74 20 49 66 00
.01182e					ScanForwardLevel:
.01182e	85 40		sta $40				sta 	DTemp1 						; save test in DTemp1 and DTemp1+2
.011830	86 42		stx $42				stx 	DTemp1+2
.011832	a5 14		lda $14				lda 	DLineNumber 				; save original line number for error
.011834	85 44		sta $44				sta 	DTemp2
.011836	a2 00 00	ldx #$0000			ldx 	#0 							; X is the level counter.
.011839					_SFLLoop:
.011839	e0 00 00	cpx #$0000			cpx 	#0 							; if X != 0 then don't test tokens for exit.
.01183c	d0 0d		bne $01184b			bne 	_SFLNoCheck 				; we're in a substructure.
.01183e	b2 06		lda ($06)			lda 	(DCodePtr)					; what's there
.011840	f0 09		beq $01184b			beq 	_SFLNoCheck 				; don't check zero
.011842	c5 40		cmp $40				cmp 	DTemp1 						; does it match either token ?
.011844	f0 04		beq $01184a			beq 	_SFLFound
.011846	c5 42		cmp $42				cmp 	DTemp1+2
.011848	d0 01		bne $01184b			bne 	_SFLNoCheck
.01184a					_SFLFound:
.01184a	60		rts				rts
.01184b					_SFLNoCheck:
.01184b	b2 06		lda ($06)			lda 	(DCodePtr) 					; what is the token.
.01184d	f0 4f		beq $01189e			beq 	_SFLNextLine 				; if $0000 go to the next line (end of line marker)
.01184f	c9 00 01	cmp #$0100			cmp 	#$0100 						; is it a string.
.011852	90 40		bcc $011894			bcc 	_SFLSkipString 				; then handle that.
.011854	e6 06		inc $06				inc 	DCodePtr 					; skip over the token
.011856	e6 06		inc $06				inc 	DCodePtr
.011858	a8		tay				tay 								; put token in Y temporarily.
.011859	29 00 e0	and #$e000			and 	#$E000 						; if not a keyword 010x xxxx xxxx xxxx
.01185c	c9 00 20	cmp #$2000			cmp 	#$2000
.01185f	d0 d8		bne $011839			bne 	_SFLLoop
.011861	98		tya				tya 								; get the token back.
.011862	29 00 1e	and #$1e00			and 	#15 << 9 					; get out token type xxxA AAAx xxxx xxxx
.011865	c9 00 1e	cmp #$1e00			cmp 	#15 << 9 					; 15 is a standard keyword
.011868	f0 cf		beq $011839			beq 	_SFLLoop
.01186a	c9 00 1a	cmp #$1a00			cmp 	#13 << 9 					; < 13 is also standard
.01186d	90 ca		bcc $011839			bcc 	_SFLLoop
.01186f	e8		inx				inx 								; increment the level.
.011870	c9 00 1c	cmp #$1c00			cmp 	#14 << 9 					; if keyword +, loop back.
.011873	f0 c4		beq $011839			beq 	_SFLLoop
.011875	ca		dex				dex 								; decrement the level
.011876	ca		dex				dex 								; one overdoes the previous inx.
.011877	10 c0		bpl $011839			bpl 	_SFLLoop 					; if gone -ve then error.
.011879					_SFLError:
.011879	a5 44		lda $44				lda 	DTemp2 						; get original line number
.01187b	85 14		sta $14				sta 	DLineNumber
.01187d	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>011880	53 74 72 75 63 74 75 72				.text 	"Structure imbalance",$00 								; with this message
>011888	65 20 69 6d 62 61 6c 61 6e 63 65 00
.011894					_SFLSkipString:
.011894	29 ff 00	and #$00ff			and 	#$00FF 						; token length of string
.011897	18		clc				clc
.011898	65 06		adc $06				adc 	DCodePtr 					; add to code pointer and save out
.01189a	85 06		sta $06				sta 	DCodePtr
.01189c	80 9b		bra $011839			bra 	_SFLLoop 					; go round again.
.01189e					_SFLNextLine:
.01189e	a4 06		ldy $06				ldy 	DCodePtr 					; put code pointer into Y
.0118a0	b9 02 00	lda $0002,y			lda 	$0002,y 					; look at the link for the next line.
.0118a3	f0 d4		beq $011879			beq 	_SFLError 					; if zero, then there's no more code to search.
.0118a5	b9 04 00	lda $0004,y			lda 	$0004,y 					; update the line number so it's still correct.
.0118a8	85 14		sta $14				sta 	DLineNumber
.0118aa	18		clc				clc
.0118ab	a5 06		lda $06				lda 	DCodePtr
.0118ad	69 06 00	adc #$0006			adc 	#6 							; skip $00 marker, link, new line
.0118b0	85 06		sta $06				sta 	DCodePtr
.0118b2	80 85		bra $011839			bra 	_SFLLoop 					; and start this one.

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/for.asm

.0118b4					Command_FOR:
.0118b4	b2 06		lda ($06)			lda 	(DCodePtr)					; look at first word
.0118b6	29 00 30	and #$3000			and 	#(IDTypeMask+IDArrayMask)	; check to see if it is type $00 e.g. integer variable
.0118b9	d0 4e		bne $011909			bne		_CFOBad
.0118bb	20 9e 03	jsr $01039e			jsr 	VariableFind 				; try to find variable
.0118be	b0 03		bcs $0118c3			bcs 	_CFOExists
.0118c0	20 51 04	jsr $010451			jsr 	VariableCreate				; create it and skip token.
.0118c3					_CFOExists:
.0118c3	48		pha				pha 								; push variable address on stack
.0118c4	a9 06 22	lda #$2206			lda 	#equalTokenID 				; check for =
.0118c7	20 e0 05	jsr $0105e0			jsr 	ExpectToken
.0118ca	20 11 03	jsr $010311			jsr 	EvaluateInteger 			; this is the start value
.0118cd	bb		tyx				tyx 								; put high value in X
.0118ce	7a		ply				ply 								; address of for variable in Y
.0118cf	99 00 00	sta $0000,y			sta 	$0000,y 					; copy into variable
.0118d2	8a		txa				txa
.0118d3	99 02 00	sta $0002,y			sta 	$0002,y
.0118d6	a9 2a 38	lda #$382a			lda 	#toTokenID 					; expect the TO
.0118d9	20 e0 05	jsr $0105e0			jsr 	ExpectToken
.0118dc	a6 1a		ldx $1a				ldx 	DStack 						; get the stack.
.0118de	a5 06		lda $06				lda 	DCodePtr 					; save code ptr at +2 (after "TO")
.0118e0	95 02		sta $02,x			sta 	$02,x
.0118e2	a5 14		lda $14				lda 	DLineNumber 				; save line number at +4
.0118e4	95 04		sta $04,x			sta 	$04,x
.0118e6	98		tya				tya 								; save variable address at +6
.0118e7	95 06		sta $06,x			sta 	$06,x
.0118e9	a9 47 3c	lda #$3c47			lda 	#forTokenID 				; save for token at +8
.0118ec	95 08		sta $08,x			sta 	$08,x
.0118ee	8a		txa				txa 								; add 8 to stack position
.0118ef	18		clc				clc
.0118f0	69 08 00	adc #$0008			adc 	#8
.0118f3	85 1a		sta $1a				sta 	DStack
.0118f5	20 11 03	jsr $010311			jsr 	EvaluateInteger 			; the end value, which we don't want this time.
.0118f8	b2 06		lda ($06)			lda 	(DCodePtr)
.0118fa	c9 2b 38	cmp #$382b			cmp 	#stepTokenID 				; if STEP x is present.
.0118fd	d0 09		bne $011908			bne 	_CFONoStep
.0118ff	a9 2b 38	lda #$382b			lda 	#stepTokenID 				; skip STEP
.011902	20 e0 05	jsr $0105e0			jsr 	ExpectToken
.011905	20 11 03	jsr $010311			jsr 	EvaluateInteger 			; and whatever the step is, throw away this time.
.011908					_CFONoStep:
.011908	60		rts				rts
.011909					_CFOBad:
.011909	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>01190c	42 61 64 20 46 4f 52 20				.text 	"Bad FOR variable",$00 								; with this message
>011914	76 61 72 69 61 62 6c 65 00
.01191d					Command_NEXT:
.01191d	a6 1a		ldx $1a				ldx 	DStack 						; look at TOS
.01191f	b5 00		lda $00,x			lda 	$00,x
.011921	c9 47 3c	cmp #$3c47			cmp 	#forTokenID 				; if not FOR then error
.011924	f0 14		beq $01193a			beq 	_CNXOk
.011926	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>011929	4e 65 78 74 20 77 69 74				.text 	"Next without For",$00 								; with this message
>011931	68 6f 75 74 20 46 6f 72 00
.01193a					_CNXOk:
.01193a	b2 06		lda ($06)			lda 	(DCodePtr)					; if there's an identifier here.
.01193c	c9 00 c0	cmp #$c000			cmp 	#$C000 						; e.g. NEXT <var>
.01193f	90 22		bcc $011963			bcc 	_CNXNoVariable
.011941	20 9e 03	jsr $01039e			jsr 	VariableFind 				; get address of variable.
.011944	90 08		bcc $01194e			bcc 	_CNXNextVar 				; not found variable, it's an error.
.011946	a6 1a		ldx $1a				ldx 	DStack 						; point X to variable address
.011948	ca		dex				dex
.011949	ca		dex				dex
.01194a	d5 00		cmp $00,x			cmp 	$00,x 						; same variable as the found one.
.01194c	f0 15		beq $011963			beq 	_CNXNoVariable 				; then continue
.01194e					_CNXNextVar:
.01194e	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>011951	42 61 64 20 4e 45 58 54				.text 	"Bad NEXT variable",$00 								; with this message
>011959	20 76 61 72 69 61 62 6c 65 00
.011963					_CNXNoVariable:
.011963	a5 06		lda $06				lda 	DCodePtr 					; save the following position on the stack in case we are done.
.011965	48		pha				pha
.011966	a5 1a		lda $1a				lda 	DStack 						; subtract 8 from stack
.011968	38		sec				sec
.011969	e9 08 00	sbc #$0008			sbc 	#8
.01196c	85 1a		sta $1a				sta 	DStack
.01196e	aa		tax				tax 								; X points to the stack.
.01196f	b5 02		lda $02,x			lda 	$02,x 						; put the old pointer in the pointer (e.g. after TO)
.011971	85 06		sta $06				sta 	DCodePtr
.011973	20 11 03	jsr $010311			jsr 	EvaluateInteger 			; this is the target constant
.011976	5a		phy				phy 								; save the target on the stack
.011977	48		pha				pha
.011978	a9 01 00	lda #$0001			lda 	#1 							; set DTemp1 (the count) to 1
.01197b	85 40		sta $40				sta 	DTemp1
.01197d	64 42		stz $42				stz 	DTemp1+2
.01197f	b2 06		lda ($06)			lda 	(DCodePtr)					; does a STEP follow.
.011981	c9 2b 38	cmp #$382b			cmp 	#stepTokenID
.011984	d0 0b		bne $011991			bne 	_CNXNoStep
.011986	e6 06		inc $06				inc 	DCodePtr 					; skip over the step token.
.011988	e6 06		inc $06				inc 	DCodePtr
.01198a	20 11 03	jsr $010311			jsr 	EvaluateInteger 			; work out the step.
.01198d	85 40		sta $40				sta 	DTemp1 						; and save in DTemp1
.01198f	84 42		sty $42				sty 	DTemp1+2
.011991					_CNXNoStep:
.011991	68		pla				pla 								; save the Target in DTemp2
.011992	85 44		sta $44				sta 	DTemp2
.011994	68		pla				pla
.011995	85 46		sta $46				sta 	DTemp2+2
.011997	a6 1a		ldx $1a				ldx 	DStack 						; get the stack
.011999	b5 06		lda $06,x			lda 	$06,x 						; address of the FOR variable into Y
.01199b	a8		tay				tay
.01199c	18		clc				clc
.01199d	b9 00 00	lda $0000,y			lda 	$0000,y
.0119a0	65 40		adc $40				adc 	DTemp1
.0119a2	99 00 00	sta $0000,y			sta 	$0000,y
.0119a5	b9 02 00	lda $0002,y			lda 	$0002,y
.0119a8	65 42		adc $42				adc 	DTemp1+2
.0119aa	99 02 00	sta $0002,y			sta 	$0002,y
.0119ad	38		sec				sec
.0119ae	a5 44		lda $44				lda 	DTemp2
.0119b0	f9 00 00	sbc $0000,y			sbc 	$0000,y
.0119b3	85 44		sta $44				sta 	DTemp2
.0119b5	a5 46		lda $46				lda 	DTemp2+2
.0119b7	f9 02 00	sbc $0002,y			sbc 	$0002,y
.0119ba	85 46		sta $46				sta 	DTemp2+2
.0119bc	05 44		ora $44				ora 	DTemp2 						; if zero (Target = Result)
.0119be	f0 0a		beq $0119ca			beq 	_CNXLoopAgain 				; then loop again, as we have to be past the target.
.0119c0	a5 46		lda $46				lda 	DTemp2+2 					; if sign(target-counter) == sign(step)
.0119c2	45 42		eor $42				eor 	DTemp1+2
.0119c4	10 04		bpl $0119ca			bpl		_CNXLoopAgain 				; we aren't there yet, so loop again.
.0119c6	68		pla				pla 								; restore the original DCodePtr as we are exiting the structure
.0119c7	85 06		sta $06				sta 	DCodePtr
.0119c9	60		rts				rts
.0119ca					_CNXLoopAgain:
.0119ca	68		pla				pla 								; throw the original DCodePtr as we're going back.
.0119cb	18		clc				clc
.0119cc	a5 1a		lda $1a				lda 	DStack 						; fix the stack back so we can loop round again.
.0119ce	aa		tax				tax
.0119cf	69 08 00	adc #$0008			adc 	#8
.0119d2	85 1a		sta $1a				sta 	DStack
.0119d4	b5 04		lda $04,x			lda		$04,x 						; because we've jumped to the top, get the line number
.0119d6	85 14		sta $14				sta 	DLineNumber 				; and make that right again.
.0119d8	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/transfer.asm

.0119d9					Command_ONGOTO:
.0119d9	20 11 03	jsr $010311			jsr 	EvaluateInteger 			; on what GOTO :)
.0119dc	c0 00 00	cpy #$0000			cpy 	#0 							; check range. ON x GOTO x1,x2,x3,x4. 0 is illegal.
.0119df	d0 25		bne $011a06			bne 	_FOGoFail
.0119e1	c9 00 00	cmp #$0000			cmp 	#0
.0119e4	f0 20		beq $011a06			beq 	_FOGoFail 					; we start with index = 1
.0119e6	48		pha				pha 								; save count on stack
.0119e7	a9 36 3e	lda #$3e36			lda 	#gotoTokenID 				; expect GOTO
.0119ea	20 e0 05	jsr $0105e0			jsr 	ExpectToken
.0119ed	fa		plx				plx 								; put count in X.
.0119ee					_FOGoLoop:
.0119ee	b2 06		lda ($06)			lda 	(DCodePtr) 					; check the next value is a constant.
.0119f0	c9 00 40	cmp #$4000			cmp 	#$4000						; range 4000-BFFF
.0119f3	90 73		bcc $011a68			bcc 	FGOFail 					; if not, then we have an error.
.0119f5	c9 00 c0	cmp #$c000			cmp 	#$C000
.0119f8	b0 6e		bcs $011a68			bcs 	FGOFail
.0119fa	ca		dex				dex 								; subtract one, if done, call GOTO code
.0119fb	f0 1f		beq $011a1c			beq 	Command_GOTO
.0119fd	e6 06		inc $06				inc 	DCodePtr 					; step over the constant
.0119ff	e6 06		inc $06				inc 	DCodePtr
.011a01	20 03 06	jsr $010603			jsr 	ExpectComma 				; expect a comma
.011a04	80 e8		bra $0119ee			bra 	_FOGoLoop 					; and loop round.
.011a06					_FOGoFail:
.011a06	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>011a09	42 61 64 20 4f 6e 2e 2e				.text 	"Bad On..Goto value",$00 								; with this message
>011a11	47 6f 74 6f 20 76 61 6c 75 65 00
.011a1c					Command_GOTO:
.011a1c	b2 06		lda ($06)			lda 	(DCodePtr) 					; look at the number
.011a1e	c9 00 40	cmp #$4000			cmp 	#$4000						; range 4000-BFFF
.011a21	90 45		bcc $011a68			bcc 	FGOFail 					; we don't do calculate line numbers.
.011a23	c9 00 c0	cmp #$c000			cmp 	#$C000
.011a26	b0 40		bcs $011a68			bcs 	FGOFail
.011a28	38		sec				sec 								; convert to 0-32767
.011a29	e9 00 40	sbc #$4000			sbc 	#$4000 						; and put in X.
.011a2c	aa		tax				tax
.011a2d	a9 00 02	lda #$0200			lda 	#Block_ProgramStart 		; start of program offset
.011a30	18		clc				clc
.011a31	65 02		adc $02				adc 	DBaseAddress 				; now an address into Y
.011a33	a8		tay				tay
.011a34					_FGOSearch:
.011a34	b9 00 00	lda $0000,y			lda 	$0000,y 					; look at link , exit if zero, reached end of program.
.011a37	f0 18		beq $011a51			beq 	_FGOUnknown
.011a39	8a		txa				txa 								; does it match line number ?
.011a3a	d9 02 00	cmp $0002,y			cmp 	$0002,y
.011a3d	f0 08		beq $011a47			beq 	_FGOFound 					; yes, then found.
.011a3f	98		tya				tya 								; no follow the link
.011a40	18		clc				clc
.011a41	79 00 00	adc $0000,y			adc 	$0000,y 					; add offset to address
.011a44	a8		tay				tay
.011a45	80 ed		bra $011a34			bra 	_FGOSearch 					; and keep looking
.011a47					_FGOFound:
.011a47	85 14		sta $14				sta 	DLineNumber 				; store as new line number
.011a49	98		tya				tya 								; Y + 4 is the code pointer.
.011a4a	18		clc				clc 								; (skipping link and line #)
.011a4b	69 04 00	adc #$0004			adc 	#4
.011a4e	85 06		sta $06				sta 	DCodePtr
.011a50	60		rts				rts									; and continue
.011a51					_FGOUnknown:
.011a51	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>011a54	55 6e 6b 6e 6f 77 6e 20				.text 	"Unknown Line Number",$00 								; with this message
>011a5c	4c 69 6e 65 20 4e 75 6d 62 65 72 00
.011a68					FGOFail:
.011a68	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>011a6b	42 61 64 20 4c 69 6e 65				.text 	"Bad Line Number",$00 								; with this message
>011a73	20 4e 75 6d 62 65 72 00
.011a7b					Command_GOSUB:
.011a7b	a6 1a		ldx $1a				ldx 	DStack 						; point Y to the stack.
.011a7d	a5 06		lda $06				lda 	DCodePtr 					; save code ptr at +0 , 2 added to skip line number
.011a7f	18		clc				clc
.011a80	69 02 00	adc #$0002			adc 	#2
.011a83	95 02		sta $02,x			sta 	$02,x 						; save pos at +2
.011a85	a5 14		lda $14				lda 	DLineNumber 				; save line number at +4
.011a87	95 04		sta $04,x			sta 	$04,x
.011a89	a9 37 3e	lda #$3e37			lda 	#gosubTokenID 				; save gosub token at +6
.011a8c	95 06		sta $06,x			sta 	$06,x
.011a8e	8a		txa				txa 								; advance stack by 6.
.011a8f	18		clc				clc
.011a90	69 06 00	adc #$0006			adc 	#6
.011a93	85 1a		sta $1a				sta 	DStack
.011a95	80 85		bra $011a1c			bra 	Command_GOTO 				; and do a GOTO.
.011a97					Command_RETURN:
.011a97	a6 1a		ldx $1a				ldx 	DStack
.011a99	b5 00		lda $00,x			lda 	$00,x
.011a9b	c9 37 3e	cmp #$3e37			cmp 	#gosubTokenID 				; check top token.
.011a9e	d0 11		bne $011ab1			bne 	_FRetFail
.011aa0	8a		txa				txa 								; unpick stack.
.011aa1	38		sec				sec
.011aa2	e9 06 00	sbc #$0006			sbc 	#6
.011aa5	85 1a		sta $1a				sta 	DStack
.011aa7	aa		tax				tax
.011aa8	b5 02		lda $02,x			lda 	$02,x 						; copy code pointer out.
.011aaa	85 06		sta $06				sta 	DCodePtr
.011aac	b5 04		lda $04,x			lda 	$04,x 						; copy line number out
.011aae	85 14		sta $14				sta 	DLineNumber
.011ab0	60		rts				rts
.011ab1					_FRetFail:
.011ab1	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>011ab4	52 65 74 75 72 6e 20 77				.text 	"Return without Gosub",$00 								; with this message
>011abc	69 74 68 6f 75 74 20 47 6f 73 75 62 00

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/repeat.asm

.011ac9					Command_REPEAT:
.011ac9	a6 1a		ldx $1a				ldx 	DStack 						; point Y to the stack.
.011acb	a5 06		lda $06				lda 	DCodePtr 					; save code ptr
.011acd	95 02		sta $02,x			sta 	$02,x 						; save pos at +2
.011acf	a5 14		lda $14				lda 	DLineNumber 				; save line number at +4
.011ad1	95 04		sta $04,x			sta 	$04,x
.011ad3	a9 44 3c	lda #$3c44			lda 	#repeatTokenID 				; save repeat token at +6
.011ad6	95 06		sta $06,x			sta 	$06,x
.011ad8	8a		txa				txa 								; advance stack by 6.
.011ad9	18		clc				clc
.011ada	69 06 00	adc #$0006			adc 	#6
.011add	85 1a		sta $1a				sta 	DStack
.011adf	60		rts				rts
.011ae0					Command_UNTIL:
.011ae0	a6 1a		ldx $1a				ldx 	DStack 						; check top token is REPEAT
.011ae2	b5 00		lda $00,x			lda 	$00,x
.011ae4	c9 44 3c	cmp #$3c44			cmp 	#repeatTokenID
.011ae7	d0 26		bne $011b0f			bne 	_FUNFail
.011ae9	20 11 03	jsr $010311			jsr 	EvaluateInteger 			; .... until what.
.011aec	c0 00 00	cpy #$0000			cpy 	#0 							; exit if non-zero
.011aef	d0 15		bne $011b06			bne 	_FUNExit
.011af1	c9 00 00	cmp #$0000			cmp 	#0
.011af4	d0 10		bne $011b06			bne 	_FUNExit
.011af6	a5 1a		lda $1a				lda 	DStack 						; unpick stack but don't remove it.
.011af8	38		sec				sec
.011af9	e9 06 00	sbc #$0006			sbc 	#6
.011afc	aa		tax				tax
.011afd	b5 02		lda $02,x			lda 	$02,x 						; copy code pointer out.
.011aff	85 06		sta $06				sta 	DCodePtr
.011b01	b5 04		lda $04,x			lda 	$04,x 						; copy line number out
.011b03	85 14		sta $14				sta 	DLineNumber
.011b05	60		rts				rts
.011b06					_FUNExit:
.011b06	a5 1a		lda $1a				lda 	DStack 						; unpick stack.
.011b08	38		sec				sec
.011b09	e9 06 00	sbc #$0006			sbc 	#6
.011b0c	85 1a		sta $1a				sta 	DStack
.011b0e	60		rts				rts
.011b0f					_FUNFail:
.011b0f	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>011b12	55 6e 74 69 6c 20 77 69				.text 	"Until without Repeat",$00 								; with this message
>011b1a	74 68 6f 75 74 20 52 65 70 65 61 74 00

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/while.asm

.011b27					Command_WHILE:
.011b27	a5 06		lda $06				lda 	DCodePtr 					; get the current instruction
.011b29	48		pha				pha 								; save on stack
.011b2a	20 11 03	jsr $010311			jsr 	EvaluateInteger 			; while what.
.011b2d	c0 00 00	cpy #$0000			cpy 	#0 							; do the body if non-zero.
.011b30	d0 14		bne $011b46			bne 	_FWHExecute
.011b32	c9 00 00	cmp #$0000			cmp 	#0
.011b35	d0 0f		bne $011b46			bne 	_FWHExecute
.011b37	68		pla				pla 								; throw away current instruction
.011b38	a9 49 3a	lda #$3a49			lda 	#wendTokenID 				; skip to WEND
.011b3b	a2 00 00	ldx #$0000			ldx 	#0
.011b3e	20 2e 18	jsr $01182e			jsr 	ScanForwardLevel 			; scan forward checking structures
.011b41	e6 06		inc $06				inc 	DCodePtr 					; and skip over the WEND.
.011b43	e6 06		inc $06				inc 	DCodePtr
.011b45	60		rts				rts
.011b46					_FWHExecute:
.011b46	a6 1a		ldx $1a				ldx 	DStack 						; point Y to the stack.
.011b48	68		pla				pla 								; save code ptr-2 so we re-execute the WHILE.
.011b49	3a		dec a				dec 	a
.011b4a	3a		dec a				dec 	a
.011b4b	95 02		sta $02,x			sta 	$02,x 						; save pos at +2
.011b4d	a5 14		lda $14				lda 	DLineNumber 				; save line number at +4
.011b4f	95 04		sta $04,x			sta 	$04,x
.011b51	a9 45 3c	lda #$3c45			lda 	#whileTokenID 				; save while token at +6
.011b54	95 06		sta $06,x			sta 	$06,x
.011b56	8a		txa				txa 								; advance stack by 6.
.011b57	18		clc				clc
.011b58	69 06 00	adc #$0006			adc 	#6
.011b5b	85 1a		sta $1a				sta 	DStack
.011b5d	60		rts				rts
.011b5e					Command_WEND:
.011b5e	a6 1a		ldx $1a				ldx 	DStack 						; check top token is WHILE
.011b60	b5 00		lda $00,x			lda 	$00,x
.011b62	c9 45 3c	cmp #$3c45			cmp 	#whileTokenID
.011b65	d0 11		bne $011b78			bne 	_FWEFail
.011b67	8a		txa				txa 								; unpick stack and always loop back.
.011b68	38		sec				sec 								; we do the check at the top.
.011b69	e9 06 00	sbc #$0006			sbc 	#6
.011b6c	85 1a		sta $1a				sta 	DStack
.011b6e	aa		tax				tax
.011b6f	b5 02		lda $02,x			lda 	$02,x 						; copy code pointer out.
.011b71	85 06		sta $06				sta 	DCodePtr 					; goes back to the WHILE token.
.011b73	b5 04		lda $04,x			lda 	$04,x 						; copy line number out
.011b75	85 14		sta $14				sta 	DLineNumber
.011b77	60		rts				rts
.011b78					_FWEFail:
.011b78	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>011b7b	57 65 6e 64 20 77 69 74				.text 	"Wend without While",$00 								; with this message
>011b83	68 6f 75 74 20 57 68 69 6c 65 00

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/run.asm

.011b8e					Command_END:
.011b8e	4c 72 1f	jmp $011f72			jmp 	WarmStart
.011b91					Command_RUN:
.011b91	20 1c 1c	jsr $011c1c			jsr 	Command_CLEAR 				; clear all variables.
.011b94	a5 02		lda $02				lda 	DBaseAddress 				; work out the first instruction.
.011b96	18		clc				clc
.011b97	69 00 02	adc #$0200			adc 	#Block_ProgramStart 		; so run from here.
.011b9a	80 0c		bra $011ba8			bra 	FRun_NextLineNumber
.011b9c					RUNExecuteTokenBuffer:
.011b9c	64 14		stz $14				stz 	DLineNumber					; zero line number
.011b9e	a9 00 01	lda #$0100			lda 	#Block_TokenBuffer 			; work out code address/
.011ba1	18		clc				clc
.011ba2	65 02		adc $02				adc 	DBaseAddress
.011ba4	85 06		sta $06				sta 	DCodePtr 					; set the code pointer.
.011ba6	80 12		bra $011bba			bra 	FRun_NextInstruction
.011ba8					FRun_NextLineNumber:
.011ba8	a8		tay				tay 								; put in Y
.011ba9	b9 00 00	lda $0000,y			lda 	$0000,y 					; read the link token.
.011bac	f0 e0		beq $011b8e			beq 	Command_END 				; if zero, off the end of the program, so END the program
.011bae	b9 02 00	lda $0002,y			lda 	$0002,y 					; read the line number
.011bb1	85 14		sta $14				sta 	DLineNumber 				; and save it.
.011bb3	98		tya				tya 								; get address back
.011bb4	18		clc				clc 								; skip over the link/line number
.011bb5	69 04 00	adc #$0004			adc 	#4
.011bb8	85 06		sta $06				sta 	DCodePtr
.011bba					FRun_NextInstruction:
.011bba	64 08		stz $08				stz 	DTempStringPointer 			; force reset on next string allocation.
.011bbc	20 90 1e	jsr $011e90			jsr 	HWCheckBreak 				; break key pressed.
.011bbf	d0 40		bne $011c01			bne 	_FRun_Break
.011bc1	b2 06		lda ($06)			lda 	(DCodePtr)					; what's next
.011bc3	f0 32		beq $011bf7			beq 	_FRun_EndInstruction		; if end of this line, then go to next line.
.011bc5	c9 26 32	cmp #$3226			cmp 	#colonTokenID 				; colon then skip
.011bc8	f0 18		beq $011be2			beq 	_FRun_Colon
.011bca	a8		tay				tay 								; save in Y
.011bcb	29 00 e8	and #$e800			and 	#$E800 						; see if it is a keyword. 1111 1xxk kkkk kkkk e.g. types 11xx
.011bce	c9 00 28	cmp #$2800			cmp 	#$2800 						; so it only runs 1100-1111 keywords.
.011bd1	d0 15		bne $011be8			bne 	_FRun_TryLET 				; if not, try LET as a default.
.011bd3	98		tya				tya 								; get token back
.011bd4	29 ff 01	and #$01ff			and 	#$01FF 						; mask out keyword
.011bd7	0a		asl a				asl 	a 							; double it into X
.011bd8	aa		tax				tax
.011bd9	e6 06		inc $06				inc 	DCodePtr 					; skip over token
.011bdb	e6 06		inc $06				inc 	DCodePtr
.011bdd	fc 00 00	jsr ($010000,x)			jsr 	(CommandJumpTable,x)		; and call that routine
.011be0	80 d8		bra $011bba			bra 	FRun_NextInstruction 		; do the following instruction.
.011be2					_FRun_Colon:
.011be2	e6 06		inc $06				inc 	DCodePtr 					; skip over token
.011be4	e6 06		inc $06				inc 	DCodePtr
.011be6	80 d2		bra $011bba			bra 	FRun_NextInstruction 		; do the following instruction.
.011be8					_FRun_TryLET:
.011be8	b2 06		lda ($06)			lda 	(DCodePtr) 					; look to see if it's an identifier.
.011bea	c9 00 c0	cmp #$c000			cmp 	#$C000
.011bed	90 05		bcc $011bf4			bcc		_FRunSyntax 				; no, must be syntax.
.011bef	20 5c 12	jsr $01125c			jsr 	Command_LET 				; try as a LET.
.011bf2	80 c6		bra $011bba			bra 	FRun_NextInstruction 		; if we get away with it, go to next instruction.
.011bf4					_FRunSyntax:
.011bf4	82 c8 e9	brl $0105bf			brl 	SyntaxError
.011bf7					_FRun_EndInstruction:
.011bf7	a5 14		lda $14				lda 	DLineNumber 				; if line number 0, warm start.
.011bf9	f0 0f		beq $011c0a			beq 	_FRun_WarmStart
.011bfb	a5 06		lda $06				lda 	DCodePtr 					; address of terminating NULL.
.011bfd	1a		inc a				inc 	a 							; go to link for next line
.011bfe	1a		inc a				inc 	a
.011bff	80 a7		bra $011ba8			bra 	FRun_NextLineNumber
.011c01					_FRun_Break:
.011c01	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>011c04	42 72 65 61 6b 00				.text 	"Break",$00 								; with this message
.011c0a					_FRun_WarmStart:
.011c0a	82 65 03	brl $011f72			brl 	WarmStart
.011c0d					Command_NEW:
.011c0d	a9 00 02	lda #$0200			lda	 	#Block_ProgramStart
.011c10	18		clc				clc
.011c11	65 02		adc $02				adc 	DBaseAddress
.011c13	a8		tay				tay
.011c14	a9 00 00	lda #$0000			lda 	#$0000
.011c17	99 00 00	sta $0000,y			sta 	$0000,y
.011c1a	80 00		bra $011c1c			bra 	Command_Clear
.011c1c					Command_CLEAR:
.011c1c	20 28 1c	jsr $011c28			jsr 	ClearVariablesPointersAndStacks
.011c1f	60		rts				rts
.011c20					Command_STOP:
.011c20	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>011c23	53 74 6f 70 00					.text 	"Stop",$00 								; with this message
.011c28					ClearVariablesPointersAndStacks:
.011c28	a9 c0 00	lda #$00c0			lda 	#BASStack
.011c2b	85 1a		sta $1a				sta 	DStack
.011c2d	64 c0		stz $c0				stz 	BASStack 					; any structure popping this => error
.011c2f	a0 0c 00	ldy #$000c			ldy 	#Block_NullString
.011c32	a9 00 00	lda #$0000			lda 	#$0000
.011c35	91 02		sta ($02),y			sta 	(DBaseAddress),y
.011c37	20 63 1c	jsr $011c63			jsr 	FindCodeEnd 				; find where the program ends.
.011c3a	a8		tay				tay 								; Y points to it.
.011c3b	a9 ee ee	lda #$eeee			lda 	#$EEEE 						; put the marker in.
.011c3e	99 02 00	sta $0002,y			sta 	$0002,y
.011c41	99 04 00	sta $0004,y			sta 	$0004,y
.011c44	98		tya				tya 								; start of working memory up
.011c45	18		clc				clc
.011c46	69 06 00	adc #$0006			adc 	#6
.011c49	a0 08 00	ldy #$0008			ldy 	#Block_LowMemoryPtr
.011c4c	91 02		sta ($02),y			sta 	(DBaseAddress),y
.011c4e	a0 80 00	ldy #$0080			ldy 	#Block_HashTable
.011c51					_FCLoop:
.011c51	a9 00 00	lda #$0000			lda 	#$0000
.011c54	91 02		sta ($02),y			sta 	(DBaseAddress),y
.011c56	c8		iny				iny
.011c57	c8		iny				iny
.011c58	c0 00 01	cpy #$0100			cpy 	#Block_HashTable+Block_HashTableEntrySize*4*2
.011c5b	d0 f4		bne $011c51			bne 	_FCLoop
.011c5d	64 08		stz $08				stz 	DTempStringPointer
.011c5f	20 74 06	jsr $010674			jsr 	StringResetPermanent
.011c62	60		rts				rts
.011c63					FindCodeEnd:
.011c63	a9 00 02	lda #$0200			lda 	#Block_ProgramStart 		; offset to program
.011c66	18		clc				clc
.011c67	65 02		adc $02				adc 	DBaseAddress 				; now an actual address
.011c69	a8		tay				tay
.011c6a					_FCELoop:
.011c6a	b9 00 00	lda $0000,y			lda 	$0000,y 					; get link.
.011c6d	f0 08		beq $011c77			beq 	_FCEExit
.011c6f	98		tya				tya 								; add offset
.011c70	18		clc				clc
.011c71	79 00 00	adc $0000,y			adc 	$0000,y
.011c74	a8		tay				tay
.011c75	80 f3		bra $011c6a			bra 	_FCELoop
.011c77					_FCEExit:
.011c77	98		tya				tya 								; return in A
.011c78	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/dim.asm

.011c79					Function_Dim:
.011c79	b2 06		lda ($06)			lda 	(DCodePtr)					; get the first token, for typing.
.011c7b	29 00 10	and #$1000			and 	#IDArrayMask 				; is it an array ?
.011c7e	f0 2e		beq $011cae			beq		_FDIMNotArray 				; no, error.
.011c80	20 9e 03	jsr $01039e			jsr 	VariableFind 				; try to find it.
.011c83	b0 34		bcs $011cb9			bcs 	_FDIMExists 				; if it does, that's an error.
.011c85	20 51 04	jsr $010451			jsr 	VariableCreate 				; create the empty variable.
.011c88	48		pha				pha 								; save array address on the stack.
.011c89	20 11 03	jsr $010311			jsr 	EvaluateInteger 			; evaluate the size
.011c8c	20 fa 05	jsr $0105fa			jsr 	ExpectRightBracket 			; check the ) following.
.011c8f	c0 00 00	cpy #$0000			cpy 	#0 							; if MSWord is non zero, obviously it's a non starter.
.011c92	d0 3b		bne $011ccf			bne 	_FDIMSize
.011c94	c9 00 00	cmp #$0000			cmp 	#0 							; need at least one element.
.011c97	f0 36		beq $011ccf			beq 	_FDIMSize
.011c99	20 e0 1c	jsr $011ce0			jsr 	DIMCreateArrayBlock 		; create and return empty array, size A+1.
.011c9c	7a		ply				ply 								; this is where it goes.
.011c9d	99 00 00	sta $0000,y			sta 	$0000,y 					; pointer to first array level block.
.011ca0	b2 06		lda ($06)			lda 	(DCodePtr)					; look at next character
.011ca2	c9 24 32	cmp #$3224			cmp 	#commaTokenID 				; if not a comma, exit
.011ca5	d0 06		bne $011cad			bne 	_FDIMExit
.011ca7	e6 06		inc $06				inc 	DCodePtr 					; skip comma
.011ca9	e6 06		inc $06				inc 	DCodePtr
.011cab	80 cc		bra $011c79			bra 	Function_DIM 				; and do another
.011cad					_FDIMExit:
.011cad	60		rts				rts
.011cae					_FDIMNotArray:
.011cae	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>011cb1	42 61 64 20 44 49 4d 00				.text 	"Bad DIM",$00 								; with this message
.011cb9					_FDIMExists:
.011cb9	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>011cbc	43 61 6e 6e 6f 74 20 52				.text 	"Cannot Redimension",$00 								; with this message
>011cc4	65 64 69 6d 65 6e 73 69 6f 6e 00
.011ccf					_FDIMSize:
.011ccf	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>011cd2	44 49 4d 20 74 6f 6f 20				.text 	"DIM too large",$00 								; with this message
>011cda	6c 61 72 67 65 00
.011ce0					DIMCreateArrayBlock:
.011ce0	48		pha				pha 								; save max index for later.
.011ce1	1a		inc a				inc 	a 							; work out size + 1 x 4
.011ce2	0a		asl a				asl 	a 							; array(7) has 8 elements indexed from zero.
.011ce3	b0 34		bcs $011d19			bcs 	_DCABFail
.011ce5	0a		asl a				asl 	a
.011ce6	b0 31		bcs $011d19			bcs 	_DCABFail
.011ce8	18		clc				clc 								; 2 for size word, the first word is the max index.
.011ce9	69 02 00	adc #$0002			adc 	#2
.011cec	b0 2b		bcs $011d19			bcs 	_DCABFail
.011cee	85 40		sta $40				sta 	DTemp1 						; save this total size.
.011cf0	a0 08 00	ldy #$0008			ldy 	#Block_LowMemoryPtr 		; add to pointer.
.011cf3	b1 02		lda ($02),y			lda 	(DBaseAddress),y
.011cf5	48		pha				pha 								; save return address
.011cf6	18		clc				clc
.011cf7	65 40		adc $40				adc 	DTemp1
.011cf9	91 02		sta ($02),y			sta 	(DBaseAddress),y
.011cfb	a0 0a 00	ldy #$000a			ldy 	#Block_HighMemoryPtr
.011cfe	d1 02		cmp ($02),y			cmp 	(DBaseAddress),y
.011d00	b0 17		bcs $011d19			bcs 	_DCABFail
.011d02	a6 40		ldx $40				ldx 	DTemp1
.011d04	7a		ply				ply
.011d05	5a		phy				phy
.011d06					_DCABClear:
.011d06	a9 00 00	lda #$0000			lda 	#0
.011d09	99 00 00	sta $0000,y			sta 	$0000,y
.011d0c	c8		iny				iny
.011d0d	c8		iny				iny
.011d0e	ca		dex				dex
.011d0f	ca		dex				dex
.011d10	d0 f4		bne $011d06			bne 	_DCABClear
.011d12	7a		ply				ply 								; restore start address
.011d13	68		pla				pla 								; restore high index
.011d14	99 00 00	sta $0000,y			sta 	$0000,y 					; save high index
.011d17	98		tya				tya 								; return in A.
.011d18	60		rts				rts
.011d19					_DCABFail:
.011d19	82 b3 e8	brl $0105cf			brl 	OutOfMemoryError

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/memwrite.asm

.011d1c					Command_POKE:
.011d1c	20 11 03	jsr $010311			jsr 	EvaluateInteger 			; address
.011d1f	48		pha				pha	 								; save on stack
.011d20	5a		phy				phy
.011d21	20 03 06	jsr $010603			jsr 	ExpectComma 				; comma seperator.
.011d24	20 11 03	jsr $010311			jsr 	EvaluateInteger 			; data
.011d27	fa		plx				plx 								; pull address and store in DTemp1
.011d28	86 42		stx $42				stx 	DTemp1+2
.011d2a	fa		plx				plx
.011d2b	86 40		stx $40				stx 	DTemp1+0
.011d2d	e2 20		sep #$20			sep 	#$20 						; byte mode
.011d2f	87 40		sta [$40]			sta 	[DTemp1]					; write it
.011d31	c2 20		rep #$20			rep 	#$20 						; word mode
.011d33	60		rts				rts
.011d34					Command_DOKE:
.011d34	20 11 03	jsr $010311			jsr 	EvaluateInteger 			; address
.011d37	48		pha				pha	 								; save on stack
.011d38	5a		phy				phy
.011d39	20 03 06	jsr $010603			jsr 	ExpectComma 				; comma seperator.
.011d3c	20 11 03	jsr $010311			jsr 	EvaluateInteger 			; data
.011d3f	fa		plx				plx 								; pull address and store in DTemp1
.011d40	86 42		stx $42				stx 	DTemp1+2
.011d42	fa		plx				plx
.011d43	86 40		stx $40				stx 	DTemp1+0
.011d45	87 40		sta [$40]			sta 	[DTemp1]					; write it
.011d47	60		rts				rts
.011d48					Command_LOKE:
.011d48	20 11 03	jsr $010311			jsr 	EvaluateInteger 			; address
.011d4b	48		pha				pha	 								; save on stack
.011d4c	5a		phy				phy
.011d4d	20 03 06	jsr $010603			jsr 	ExpectComma 				; comma seperator.
.011d50	20 11 03	jsr $010311			jsr 	EvaluateInteger 			; data
.011d53	fa		plx				plx 								; pull address and store in DTemp1
.011d54	86 42		stx $42				stx 	DTemp1+2
.011d56	fa		plx				plx
.011d57	86 40		stx $40				stx 	DTemp1+0
.011d59	87 40		sta [$40]			sta 	[DTemp1]					; write it (low)
.011d5b	98		tya				tya
.011d5c	a0 02 00	ldy #$0002			ldy 	#2
.011d5f	97 40		sta [$40],y			sta 	[DTemp1],y 					; write it (high)
.011d61	60		rts				rts

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/commands/miscellany.asm

.011d62					Command_ASSERT:
.011d62	20 11 03	jsr $010311			jsr 	EvaluateInteger 			; something that returns an integer.
.011d65	84 40		sty $40				sty 	DTemp1 						; check if result is zero.
.011d67	05 40		ora $40				ora 	Dtemp1
.011d69	f0 01		beq $011d6c			beq 	_FAssFail
.011d6b	60		rts				rts
.011d6c					_FAssFail:
.011d6c	ea		nop				nop
.011d6d	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>011d70	61 73 73 65 72 74 20 66				.text 	"assert failed",$00 								; with this message
>011d78	61 69 6c 65 64 00
.011d7e					Command_CLS:
.011d7e	20 0a 1e	jsr $011e0a			jsr 	HWClearScreen
.011d81	60		rts				rts
.011d82					Command_REM:
.011d82	b2 06		lda ($06)			lda 	(DCodePtr) 					; get code ptr.
.011d84	f0 0f		beq $011d95			beq 	_FRemExit 					; no comment present
.011d86	c9 26 32	cmp #$3226			cmp 	#colonTokenID
.011d89	f0 0a		beq $011d95			beq 	_FRemExit 					; no comment present
.011d8b	c9 00 01	cmp #$0100			cmp 	#$0100 						; if not $00xx syntax error
.011d8e	b0 06		bcs $011d96			bcs 	_FRemSyntax
.011d90	18		clc				clc 								; add to DCodePtr
.011d91	65 06		adc $06				adc 	DCodePtr
.011d93	85 06		sta $06				sta 	DCodePtr
.011d95					_FRemExit:
.011d95	60		rts				rts
.011d96					_FRemSyntax:
.011d96	82 26 e8	brl $0105bf			brl 	SyntaxError
.011d99					Command_LINK:
.011d99	20 11 03	jsr $010311			jsr 	EvaluateInteger 			; call address same page.
.011d9c	85 40		sta $40				sta 	DTemp1 						; target address
.011d9e	84 42		sty $42				sty 	DTemp1+2
.011da0	7b		tdc				tda 								; work out what the actual address is
.011da1	18		clc				clc
.011da2	69 40 00	adc #$0040			adc 	#DTemp1
.011da5	8f da 1d 01	sta $011dda			sta 	_FLIExecuteIt+1 			; and overwrite it. Surely to fuck there has
.011da9	a4 02		ldy $02				ldy 	DBaseAddress 				; point Y to DBaseAddress + Load
.011dab	b9 10 00	lda $0010,y			lda 	("A"-"A")*4+Block_FastVariables,y
.011dae	48		pha				pha
.011daf	b9 6c 00	lda $006c,y			lda 	("X"-"A")*4+Block_FastVariables,y
.011db2	aa		tax				tax
.011db3	b9 70 00	lda $0070,y			lda 	("Y"-"A")*4+Block_FastVariables,y
.011db6	a8		tay				tay
.011db7	68		pla				pla
.011db8	22 d9 1d 01	jsl $011dd9			jsl 	_FLIExecuteIt
.011dbc	5a		phy				phy 								; save Y
.011dbd	a4 02		ldy $02				ldy 	DBaseAddress 				; point Y to DBaseAddress + Save
.011dbf	99 10 00	sta $0010,y			sta 	("A"-"A")*4+Block_FastVariables,y
.011dc2	8a		txa				txa
.011dc3	99 6c 00	sta $006c,y			sta 	("X"-"A")*4+Block_FastVariables,y
.011dc6	68		pla				pla
.011dc7	99 70 00	sta $0070,y			sta 	("Y"-"A")*4+Block_FastVariables,y
.011dca	c8		iny				iny 								; point to their high bytes and clear them
.011dcb	c8		iny				iny
.011dcc	a9 00 00	lda #$0000			lda 	#0
.011dcf	99 10 00	sta $0010,y			sta 	("A"-"A")*4+Block_FastVariables,y
.011dd2	99 6c 00	sta $006c,y			sta 	("X"-"A")*4+Block_FastVariables,y
.011dd5	99 70 00	sta $0070,y			sta 	("Y"-"A")*4+Block_FastVariables,y
.011dd8	60		rts				rts
.011dd9					_FLIExecuteIt:
.011dd9	dc 40 00	jmp [$0040]			jmp 	[DTemp1]					; go wherever.
.011ddc					Command_VDU:
.011ddc	20 11 03	jsr $010311			jsr 	EvaluateInteger 			; get integer to YA.
.011ddf	a8		tay				tay 								; put into Y
.011de0	29 ff 00	and #$00ff			and 	#$00FF 						; mask out LSB
.011de3	20 23 1e	jsr $011e23			jsr 	HWPrintChar 				; print the LSB.
.011de6	b2 06		lda ($06)			lda 	(DCodePtr)
.011de8	c9 24 32	cmp #$3224			cmp 	#commaTokenID 				; if , goto next
.011deb	f0 0e		beq $011dfb			beq 	_CVDUNext
.011ded	c9 25 32	cmp #$3225			cmp 	#semicolonTokenID 			; if ; print MSB and goto next
.011df0	f0 01		beq $011df3			beq 	_CVDUHighByte
.011df2					_CVDUExit:
.011df2	60		rts				rts
.011df3					_CVDUHighByte:
.011df3	98		tya				tya 								; get back.
.011df4	eb		xba				xba 								; byte swap
.011df5	29 ff 00	and #$00ff			and 	#$00FF 						; mask and print
.011df8	20 23 1e	jsr $011e23			jsr 	HWPrintChar
.011dfb					_CVDUNext:
.011dfb	e6 06		inc $06				inc 	DCodePtr 					; skip , ;
.011dfd	e6 06		inc $06				inc 	DCodePtr
.011dff	b2 06		lda ($06)			lda 	(DCodePtr)					; continue ?
.011e01	f0 ef		beq $011df2			beq		_CVDUExit
.011e03	c9 26 32	cmp #$3226			cmp 	#colonTokenID
.011e06	f0 ea		beq $011df2			beq 	_CVDUExit
.011e08	80 d2		bra $011ddc			bra 	Command_VDU

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/utility/hwinterface.asm

=$f8020					HWCursor = $F8020 							; cursor position r/w
=$f8010					HWKeyPressed = $F8010 						; current key pressed (inkey) r
=$f8000					HWBreakKey = $F8000 						; non-zero if break pressed
=$f0000					HWScreen = $F0000							; screen RAM base
=$f8100					InputBuffer = $F8100 						; area of memory for input buffer.
=$f8200					LastKey = $F8200 							; last key pressed.
=64					sWidth = 64									; this is a quick hack so these must be powers of 2
=32					sHeight = 32 								; in this implementation.
.011e0a					HWClearScreen:
.011e0a	48		pha				pha
.011e0b	da		phx				phx
.011e0c	a2 fe 07	ldx #$07fe			ldx 	#sWidth*sHeight-2 			; fill screen memory with space
.011e0f	a9 20 20	lda #$2020	_CS0:	lda 	#$2020
.011e12	9f 00 00 0f	sta $0f0000,x			sta 	$F0000,x
.011e16	ca		dex				dex
.011e17	10 f6		bpl $011e0f			bpl 	_CS0
.011e19	a9 00 00	lda #$0000			lda 	#0 							; reposition cursor
.011e1c	8f 20 80 0f	sta $0f8020			sta 	HWCursor
.011e20	fa		plx				plx
.011e21	68		pla				pla
.011e22	60		rts				rts
.011e23					HWPrintChar:
.011e23	48		pha				pha
.011e24	da		phx				phx
.011e25	5a		phy				phy
.011e26	48		pha				pha 								; cursor position -> X
.011e27	af 20 80 0f	lda $0f8020			lda 	HWCursor
.011e2b	aa		tax				tax
.011e2c	68		pla				pla
.011e2d	c9 ff ff	cmp #$ffff			cmp 	#-1
.011e30	f0 08		beq $011e3a			beq 	_HWPCNoWrite
.011e32	e2 20		sep #$20			sep 	#$20 						; write character to screen.
.011e34	9f 00 00 0f	sta $0f0000,x			sta 	$F0000,x
.011e38	c2 20		rep #$20			rep 	#$20
.011e3a					_HWPCNoWrite:
.011e3a	e8		inx				inx 								; bump cursor position.
.011e3b	8a		txa				txa
.011e3c	8f 20 80 0f	sta $0f8020			sta 	HWCursor
.011e40	c9 00 08	cmp #$0800			cmp 	#(sWidth*sHeight) 			; reached end of screen
.011e43	d0 2b		bne $011e70			bne 	_HWNotEnd
.011e45	38		sec				sec 	 							; back up one line
.011e46	e9 40 00	sbc #$0040			sbc 	#sWidth
.011e49	8f 20 80 0f	sta $0f8020			sta 	HWCursor
.011e4d	a2 00 00	ldx #$0000			ldx 	#0 							; scroll screen up.
.011e50					_HWScrollUp:
.011e50	bf 40 00 0f	lda $0f0040,x			lda 	$F0000+sWidth,x
.011e54	9f 00 00 0f	sta $0f0000,x			sta 	$F0000,x
.011e58	e8		inx				inx
.011e59	e8		inx				inx
.011e5a	e0 00 08	cpx #$0800			cpx 	#sWidth*sHeight
.011e5d	d0 f1		bne $011e50			bne 	_HWScrollUp
.011e5f	a2 c0 07	ldx #$07c0			ldx 	#(sWidth*(sHeight-1))		; clear bottom line.
.011e62					_HWBlank:
.011e62	a9 20 20	lda #$2020			lda 	#$2020
.011e65	9f 00 00 0f	sta $0f0000,x			sta 	$F0000,x
.011e69	e8		inx				inx
.011e6a	e8		inx				inx
.011e6b	e0 00 08	cpx #$0800			cpx 	#sWidth*sHeight
.011e6e	d0 f2		bne $011e62			bne 	_HWBlank
.011e70					_HWNotEnd:
.011e70	7a		ply				ply
.011e71	fa		plx				plx
.011e72	68		pla				pla
.011e73	60		rts				rts
.011e74					HWNewLine:
.011e74	48		pha				pha
.011e75	da		phx				phx
.011e76	a2 3f 00	ldx #$003f			ldx 	#sWidth-1 					; print spaces until X & position = 0
.011e79					HWMoveCursor:
.011e79	a9 ff ff	lda #$ffff			lda 	#-1
.011e7c	20 23 1e	jsr $011e23			jsr 	HWPrintChar
.011e7f	8a		txa				txa
.011e80	2f 20 80 0f	and $0f8020			and 	HWCursor
.011e84	d0 f3		bne $011e79			bne 	HWMoveCursor
.011e86	fa		plx				plx
.011e87	68		pla				pla
.011e88	60		rts				rts
.011e89	48		pha		HWTab:	pha
.011e8a	da		phx				phx
.011e8b	a2 07 00	ldx #$0007			ldx 	#7
.011e8e	80 e9		bra $011e79			bra 	HWMoveCursor
.011e90					HWCheckBreak:
.011e90	af 00 80 0f	lda $0f8000			lda 	HWBreakKey
.011e94	60		rts				rts
.011e95					HWInkey:
.011e95	af 10 80 0f	lda $0f8010			lda 	HWKeyPressed
.011e99	60		rts				rts
.011e9a					HWInputLine:
.011e9a	20 95 1e	jsr $011e95			jsr 	HWInkey 					; get a keystroke.
.011e9d	cf 00 82 0f	cmp $0f8200			cmp 	LastKey
.011ea1	f0 f7		beq $011e9a			beq 	HWInputLine
.011ea3					_HWILWait:
.011ea3	20 95 1e	jsr $011e95			jsr 	HWInkey
.011ea6	c9 00 00	cmp #$0000			cmp		#0
.011ea9	f0 f8		beq $011ea3			beq 	_HWILWait
.011eab	8f 00 82 0f	sta $0f8200			sta 	LastKey
.011eaf	c9 20 00	cmp #$0020			cmp 	#32 						; control check
.011eb2	90 2f		bcc $011ee3			bcc 	_HWILControl
.011eb4	20 23 1e	jsr $011e23			jsr 	HWPrintChar 				; print out.
.011eb7	80 e1		bra $011e9a			bra 	HWInputLine 				; loop back.
.011eb9					_HWILBackSpace:
.011eb9	af 20 80 0f	lda $0f8020			lda 	HWCursor
.011ebd	f0 db		beq $011e9a			beq 	HWInputLine
.011ebf	aa		tax				tax
.011ec0	ca		dex				dex
.011ec1	a9 20 00	lda #$0020			lda 	#" "
.011ec4	e2 20		sep #$20			sep 	#$20
.011ec6	9f 00 00 0f	sta $0f0000,x			sta 	$F0000,x
.011eca	c2 20		rep #$20			rep 	#$20
.011ecc	a2 ff ff	ldx #$ffff			ldx 	#-1
.011ecf					_HWILMove:
.011ecf	8a		txa				txa
.011ed0	18		clc				clc
.011ed1	6f 20 80 0f	adc $0f8020			adc 	HWCursor
.011ed5	29 ff 07	and #$07ff			and 	#(sWidth*sHeight-1)
.011ed8	8f 20 80 0f	sta $0f8020			sta 	HWCursor
.011edc	80 bc		bra $011e9a			bra 	HWInputLine
.011ede					_HWILClear:
.011ede	20 0a 1e	jsr $011e0a			jsr 	HWClearScreen
.011ee1	80 b7		bra $011e9a			bra 	HWInputLine
.011ee3					_HWILControl:
.011ee3	c9 09 00	cmp #$0009			cmp 	#9 							; tab
.011ee6	f0 60		beq $011f48			beq 	_HWILTab
.011ee8	c9 08 00	cmp #$0008			cmp 	#8 							; backspace.
.011eeb	f0 cc		beq $011eb9			beq 	_HWILBackSpace
.011eed	a2 c0 ff	ldx #$ffc0			ldx 	#-sWidth 					; Ctrl WASD move cursor
.011ef0	c9 17 00	cmp #$0017			cmp 	#23
.011ef3	f0 da		beq $011ecf			beq 	_HWILMove
.011ef5	a2 40 00	ldx #$0040			ldx 	#sWidth
.011ef8	c9 13 00	cmp #$0013			cmp 	#19
.011efb	f0 d2		beq $011ecf			beq 	_HWILMove
.011efd	a2 ff ff	ldx #$ffff			ldx 	#-1
.011f00	c9 01 00	cmp #$0001			cmp 	#1
.011f03	f0 ca		beq $011ecf			beq 	_HWILMove
.011f05	a2 01 00	ldx #$0001			ldx 	#1
.011f08	c9 04 00	cmp #$0004			cmp 	#4
.011f0b	f0 c2		beq $011ecf			beq 	_HWILMove
.011f0d	c9 0c 00	cmp #$000c			cmp 	#12 						; Ctrl L Clear Screen/Home
.011f10	f0 cc		beq $011ede			beq 	_HWILClear
.011f12	c9 0d 00	cmp #$000d			cmp 	#13
.011f15	d0 83		bne $011e9a			bne 	HWInputLine
.011f17	af 20 80 0f	lda $0f8020			lda 	HWCursor 					; cursor position
.011f1b	29 c0 ff	and #$ffc0			and 	#$FFC0 						; start of line.
.011f1e	85 40		sta $40				sta 	DTemp1 						; pointer in DTemp1
.011f20	a9 0f 00	lda #$000f			lda 	#$000F
.011f23	85 42		sta $42				sta 	DTemp1+2
.011f25	a0 00 00	ldy #$0000			ldy 	#0 							; set up for copy
.011f28					_HWILCopy:
.011f28	bb		tyx				tyx
.011f29	b7 40		lda [$40],y			lda 	[DTemp1],y
.011f2b	9f 00 81 0f	sta $0f8100,x			sta 	InputBuffer,x
.011f2f	c8		iny				iny
.011f30	c8		iny				iny
.011f31	c0 40 00	cpy #$0040			cpy 	#64 						; done the whole line ?
.011f34	d0 f2		bne $011f28			bne 	_HWILCopy
.011f36	a9 00 00	lda #$0000			lda 	#0
.011f39	bb		tyx				tyx
.011f3a	9f 00 81 0f	sta $0f8100,x			sta 	InputBuffer,x 				; add trailing zero.
.011f3e	20 74 1e	jsr $011e74			jsr 	HWNewLine 					; next line.
.011f41	a9 00 81	lda #$8100			lda 	#InputBuffer & $FFFF
.011f44	a0 0f 00	ldy #$000f			ldy 	#InputBuffer >> 16
.011f47	60		rts				rts
.011f48					_HWILTab:
.011f48	20 89 1e	jsr $011e89			jsr 	HWTab
.011f4b	82 4c ff	brl $011e9a			brl 	HWInputLine

;******  Return to file: ../source/basic.asm

=$2000					IDTypeMask = $2000 									; bit masks in identifier.
=$1000					IDArrayMask = $1000
=$0800					IDContMask = $0800
=8					UnaryFunction = 8 									; Unary function Token Type ID.
=9					TokenShift = 9										; Token shift to reach precedence.
.011f4e					SwitchBasicInstance:
.011f4e	c2 30		rep #$30			rep 	#$30 								; 16 bit A:X mode.
.011f50	20 0a 1e	jsr $011e0a			jsr 	HWClearScreen 						; clear screen
.011f53	29 ff 00	and #$00ff			and 	#$00FF 								; make page number 24 bit
.011f56	85 00		sta $00				sta 	DPageNumber 						; save page, base, high in RAM.
.011f58	86 02		stx $02				stx		DBaseAddress
.011f5a	84 04		sty $04				sty 	DHighAddress
.011f5c	ba		tsx				tsx 										; save the current SP.
.011f5d	86 22		stx $22				stx 	DStack65816
.011f5f	eb		xba				xba 										; put the page number (goes in the DBR) in B
.011f60	48		pha				pha 										; then copy it into B.
.011f61	ab		plb				plb
.011f62	ab		plb				plb
.011f63	20 28 1c	jsr $011c28			jsr 	ClearVariablesPointersAndStacks		; clear all variables etc.
.011f66	a0 0e 00	ldy #$000e			ldy 	#Block_BootFlag 					; if boot flag zero, warm start
.011f69	b1 02		lda ($02),y			lda 	(DBaseAddress),y
.011f6b	f0 05		beq $011f72			beq 	WarmStart
.011f6d	3a		dec a				dec 	a 									; decrement zero.
.011f6e	91 02		sta ($02),y			sta 	(DBaseAddress),y
.011f70	80 18		bra $011f8a			bra 	ExecuteTokenBuffer 					; execute contents of token buffer.
.011f72					WarmStart:
.011f72	a2 d8 1f	ldx #$1fd8			ldx 	#BasicPrompt & $FFFF
.011f75	20 3c 06	jsr $01063c			jsr 	PrintROMMessage
.011f78					NextCommand:
.011f78	a6 22		ldx $22				ldx 	DStack65816 						; reset the CPU stack
.011f7a	9a		txs				txs
.011f7b	64 08		stz $08				stz 	DTempStringPointer 					; reset the
.011f7d	a0 0e 00	ldy #$000e			ldy 	#Block_BootFlag 					; if the boot flag is non-zero
.011f80	b1 02		lda ($02),y			lda 	(DBaseAddress),y 					; then exit the emulator.
.011f82	d0 52		bne $011fd6			bne 	ExitEmulator
.011f84	20 9a 1e	jsr $011e9a			jsr 	HWInputLine 						; read line to YA.
.011f87	20 80 07	jsr $010780			jsr 	Tokenise 							; tokenise it.
.011f8a					ExecuteTokenBuffer:
.011f8a	a0 00 01	ldy #$0100			ldy 	#Block_TokenBuffer 					; get the first token
.011f8d	b1 02		lda ($02),y			lda 	(DBaseAddress),y
.011f8f	f0 e7		beq $011f78			beq 	NextCommand 						; nothing.
.011f91	c9 00 40	cmp #$4000			cmp 	#$4000 								; if not a number token, execute it
.011f94	90 27		bcc $011fbd			bcc 	_ETBCommand
.011f96	c9 00 c0	cmp #$c000			cmp 	#$C000
.011f99	b0 22		bcs $011fbd			bcs 	_ETBCommand
.011f9b	38		sec				sec
.011f9c	e9 00 40	sbc #$4000			sbc 	#$4000 								; put in range 0-32767
.011f9f	f0 1f		beq $011fc0			beq 	_ETBError
.011fa1	48		pha				pha
.011fa2	20 c4 04	jsr $0104c4			jsr 	LineDelete 							; delete the line, if it exists.
.011fa5	20 28 1c	jsr $011c28			jsr 	ClearVariablesPointersAndStacks		; clear all variables etc.
.011fa8	a9 02 01	lda #$0102			lda 	#Block_TokenBuffer+2				; get the code for the line, e.g. next token
.011fab	18		clc				clc
.011fac	65 02		adc $02				adc 	DBaseAddress
.011fae	a8		tay				tay 										; Y contains the code.
.011faf	b9 00 00	lda $0000,y			lda 	$0000,y 							; is there any code ?
.011fb2	f0 c4		beq $011f78			beq 	NextCommand 						; no, next command.
.011fb4	68		pla				pla 										; line number in A, code in Y.
.011fb5	20 ff 04	jsr $0104ff			jsr 	LineInsert 							; insert the line
.011fb8	20 28 1c	jsr $011c28			jsr 	ClearVariablesPointersAndStacks		; clear all variables etc.
.011fbb	80 bb		bra $011f78			bra 	NextCommand
.011fbd					_ETBCommand:
.011fbd	4c 9c 1b	jmp $011b9c			jmp 	RUNExecuteTokenBuffer 				; execute the token buffer
.011fc0					_ETBError:
.011fc0	20 83 05	jsr $010583			jsr 	ErrorHandler 						; call error routine
>011fc3	43 61 6e 6e 6f 74 20 68				.text 	"Cannot have line 0",$00 								; with this message
>011fcb	61 76 65 20 6c 69 6e 65 20 30 00
.011fd6					ExitEmulator:
.011fd6	02 00		cop #$00			cop 	#0
.011fd8					BasicPrompt:
>011fd8	52 65 61 64 79 2e 0d 00				.text 	"Ready.",13,0

;******  Return to file: ../source/start.asm


;******  Processing file: ../source/utility/testing.asm

.01f000	82 00 00	brl $01f003			brl 	TokenCheckCode
.01f003					TokenCheckCode:
.01f003	a9 00 b0	lda #$b000			lda 	#$B000 								; the text is at $2B000
.01f006	a0 02 00	ldy #$0002			ldy 	#2
.01f009	20 80 07	jsr $010780			jsr 	Tokenise
.01f00c	a6 02		ldx $02				ldx 	DBaseAddress
.01f00e	a0 00 00	ldy #$0000			ldy 	#0
.01f011					_TokeniserTestLoop:
.01f011	bd 00 01	lda $0100,x			lda 	Block_TokenBuffer,x					; compare workspace vs answer
.01f014	d9 00 b2	cmp $b200,y			cmp 	$B200,y
.01f017					_TokeniserError:
.01f017	d0 fe		bne $01f017			bne 	_TokeniserError
.01f019	e8		inx				inx
.01f01a	e8		inx				inx
.01f01b	c8		iny				iny
.01f01c	c8		iny				iny
.01f01d	c9 00 00	cmp #$0000			cmp 	#0
.01f020	d0 ef		bne $01f011			bne 	_TokeniserTestLoop
.01f022	02 00		cop #$00			cop 	#0 									; exit successfully.
.01f024	6b		rtl				rtl

;******  Return to file: ../source/start.asm

.024000					CodeSpace:
>024000	42 41 53 43 00 00 00 00				.binary "temp/basic.bin"
>024008	28 43 00 c0 00 00 00 00 00 00 00 00 00 00 00 00
>024018	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
;	...repeated 29 times (464 bytes)...
>0241f8	00 00 00 00 00 00 00 00 0c 00 14 00 18 c0 06 22
>024208	00 40 00 00 08 00 32 00 44 3c 00 00 16 00 64 00
>024218	46 3c 27 32 18 c0 01 20 01 40 28 32 06 22 00 40
>024228	00 00 16 00 6e 00 35 3e 18 c0 24 32 08 00 04 45
>024238	76 65 6e 00 24 32 00 00 0e 00 70 00 46 3c 18 c0
>024248	05 22 05 40 00 00 0e 00 76 00 35 3e 06 00 02 3e
>024258	35 00 00 00 08 00 77 00 3a 3e 00 00 0e 00 78 00
>024268	35 3e 06 00 03 3c 3d 35 00 00 08 00 81 00 4c 3a
>024278	00 00 08 00 82 00 3a 3e 00 00 14 00 86 00 35 3e
>024288	18 c0 24 32 06 00 03 6f 64 64 24 32 00 00 0c 00
>024298	87 00 19 c0 06 22 18 c0 00 00 30 00 88 00 44 3c
>0242a8	26 32 35 3e 19 c0 25 32 04 00 01 20 25 32 26 32
>0242b8	19 c0 06 22 19 c0 0b 24 01 40 26 32 4a 3a 19 c0
>0242c8	06 22 00 40 26 32 35 3e 00 00 08 00 8c 00 4c 3a
>0242d8	00 00 10 00 96 00 18 c0 06 22 18 c0 0a 24 01 40
>0242e8	00 00 0e 00 a0 00 4a 3a 18 c0 05 22 0a 40 00 00
>0242f8	22 00 aa 00 47 3c 09 c0 06 22 01 40 2a 38 05 40
>024308	2b 38 02 40 26 32 35 3e 09 c0 26 32 4d 3a 09 c0
>024318	00 00 08 00 b4 00 31 3e 00 00 00 00 ee ee ee ee
>024328	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
;	...repeated 1996 times (31936 bytes)...
>02bff8	00 00 00 00 00 00 00 00
.02c000					CodeEndSpace:

;******  End of listing
